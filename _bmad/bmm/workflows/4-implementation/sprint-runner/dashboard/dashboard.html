<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grimoire - Project Dashboard</title>
    <style>
        /* Reset & Base */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            /* Timeline CSS Variables */
            --timeline-label-width: 200px;
            --timeline-block-width: 120px;
            --timeline-row-height: 48px;
            --timeline-command-row-height: 28px;
            --timeline-story-color: #10b981;
            --timeline-story-in-progress-color: #fbbf24;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: #f7f6f3;
            color: #37352f;
            line-height: 1.5;
            padding: 20px;
        }

        /* Container - Full width layout (Story 5-SR-7) */
        .container {
            margin: 0 auto;
        }

        /* Header - Task 1: Modernized compact header */
        header {
            background: white;
            border-radius: 8px;
            padding: 16px 24px;
            margin-bottom: 24px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.04);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        h1 {
            font-size: 22px;
            font-weight: 600;
            color: #37352f;
            margin-bottom: 0;
        }

        .last-updated {
            font-size: 14px;
            color: #787774;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .update-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #10b981;
            animation: pulse 2s infinite;
        }

        .update-dot.inactive {
            background: #9ca3af;
            animation: none;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Summary Cards */
        .summary-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
            gap: 16px;
            margin-bottom: 24px;
        }

        .card {
            background: white;
            border-radius: 8px;
            padding: 24px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.04);
            border: 1px solid #e8e7e5;
        }

        .card-label {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #787774;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .card-value {
            font-size: 32px;
            font-weight: 700;
            color: #37352f;
        }

        .card-subtitle {
            font-size: 14px;
            color: #787774;
            margin-top: 4px;
        }

        /* Section Headers */
        .section {
            margin-bottom: 24px;
        }

        .section-title {
            font-size: 20px;
            font-weight: 600;
            color: #37352f;
            margin-bottom: 16px;
            padding-left: 4px;
        }

        /* Epic Board (Kanban) */
        .epic-board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 16px;
            margin-bottom: 24px;
        }

        .epic-column {
            background: white;
            border-radius: 8px;
            padding: 16px;
            border: 1px solid #e8e7e5;
            min-height: 200px;
        }

        .epic-column-header {
            font-size: 14px;
            font-weight: 600;
            color: #787774;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 2px solid #e8e7e5;
        }

        .epic-card {
            background: #fafaf9;
            border: 1px solid #e8e7e5;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .epic-card:hover {
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            transform: translateY(-1px);
        }

        /* Task 2: Expandable Epic Cards */
        .epic-card-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        .epic-card-title {
            font-size: 14px;
            font-weight: 600;
            color: #37352f;
            margin-bottom: 6px;
        }

        .epic-expand-icon {
            font-size: 10px;
            color: #787774;
            transition: transform 0.2s ease;
            cursor: pointer;
        }

        .epic-card.expanded .epic-expand-icon {
            transform: rotate(90deg);
        }

        .epic-card-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }

        .epic-card-progress {
            font-size: 12px;
            color: #787774;
        }

        .epic-card-duration {
            font-size: 11px;
            font-weight: 500;
            color: #065f46;
            background: #d1fae5;
            padding: 2px 6px;
            border-radius: 4px;
        }

        .epic-card-progress-bar {
            width: 100%;
            height: 4px;
            background: #e8e7e5;
            border-radius: 2px;
            margin-top: 6px;
            overflow: hidden;
        }

        .epic-card-progress-fill {
            height: 100%;
            background: #10b981;
            border-radius: 2px;
            transition: width 0.3s ease;
        }

        .epic-stories-list {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid #e8e7e5;
        }

        .epic-story-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 0;
            font-size: 13px;
            color: #37352f;
            cursor: pointer;
        }

        .epic-story-item:hover {
            background: #f0efed;
            margin: 0 -8px;
            padding: 6px 8px;
            border-radius: 4px;
        }

        .epic-story-item .story-name {
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .epic-story-item .badge {
            flex-shrink: 0;
            margin-left: 8px;
            font-size: 10px;
            padding: 2px 6px;
        }

        /* Story Tooltip */
        .story-tooltip {
            position: fixed;
            background: #37352f;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            max-width: 300px;
            z-index: 1000;
            pointer-events: none;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            opacity: 0;
            transition: opacity 0.15s ease;
        }

        .story-tooltip.visible {
            opacity: 1;
        }

        /* Story Table */
        .table-container {
            background: white;
            border-radius: 8px;
            border: 1px solid #e8e7e5;
            overflow: hidden;
            margin-bottom: 24px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        thead {
            background: #fafaf9;
            border-bottom: 1px solid #e8e7e5;
        }

        th {
            text-align: left;
            padding: 12px 16px;
            font-size: 12px;
            font-weight: 600;
            color: #787774;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        td {
            padding: 12px 16px;
            border-top: 1px solid #e8e7e5;
            font-size: 14px;
        }

        tr:hover {
            background: #fafaf9;
        }

        .story-id {
            font-family: 'SF Mono', Monaco, 'Courier New', monospace;
            font-size: 13px;
            color: #787774;
        }

        .story-duration {
            font-family: 'SF Mono', Monaco, 'Courier New', monospace;
            font-size: 12px;
            color: #787774;
        }

        /* Status Badges */
        .badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 500;
            text-transform: capitalize;
        }

        .badge-backlog {
            background: #e8e7e5;
            color: #787774;
        }

        .badge-ready-for-dev {
            background: #dbeafe;
            color: #1e40af;
        }

        .badge-in-progress {
            background: #fef3c7;
            color: #92400e;
        }

        .badge-review {
            background: #e9d5ff;
            color: #6b21a8;
        }

        .badge-done {
            background: #d1fae5;
            color: #065f46;
        }

        .badge-optional {
            background: #f3f4f6;
            color: #9ca3af;
            font-style: italic;
        }

        /* Activity Log */
        .activity-log {
            background: white;
            border-radius: 8px;
            border: 1px solid #e8e7e5;
            padding: 24px;
        }

        .activity-item {
            border-left: 3px solid #e8e7e5;
            padding-left: 16px;
            margin-bottom: 24px;
            padding-bottom: 16px;
        }

        .activity-item:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
        }

        .activity-item.completed {
            border-left-color: #10b981;
        }

        .activity-item.in-progress {
            border-left-color: #fbbf24;
        }

        .activity-item.collapsed .activity-body {
            display: none;
        }

        .activity-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            cursor: pointer;
            user-select: none;
        }

        .activity-header:hover {
            opacity: 0.8;
        }

        .activity-title-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .activity-toggle {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #787774;
            transition: transform 0.2s;
        }

        .activity-item.collapsed .activity-toggle {
            transform: rotate(-90deg);
        }

        .activity-story {
            font-size: 16px;
            font-weight: 600;
            color: #37352f;
        }

        .activity-badge {
            font-size: 11px;
            padding: 2px 8px;
            border-radius: 10px;
            background: #d1fae5;
            color: #065f46;
        }

        .activity-item.in-progress .activity-badge {
            background: #fef3c7;
            color: #92400e;
        }

        .activity-meta-right {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 2px;
        }

        .activity-duration {
            font-size: 12px;
            font-weight: 600;
            color: #37352f;
            background: #e8e7e5;
            padding: 2px 8px;
            border-radius: 4px;
        }

        .activity-date {
            font-size: 12px;
            color: #787774;
        }

        .activity-body {
            padding-top: 4px;
        }

        .activity-meta {
            font-size: 13px;
            color: #787774;
            margin-bottom: 12px;
        }

        .activity-description {
            font-size: 13px;
            color: #5a5a58;
            margin-bottom: 12px;
            line-height: 1.5;
            font-style: italic;
        }

        .activity-steps {
            background: #fafaf9;
            border-radius: 6px;
            padding: 12px;
            overflow-x: auto;
        }

        .activity-steps table {
            min-width: 600px;
        }

        .activity-steps th,
        .activity-steps td {
            padding: 8px 12px;
            font-size: 13px;
        }

        .activity-steps thead {
            background: transparent;
        }

        .step-result {
            font-size: 12px;
        }

        .step-duration {
            font-family: 'SF Mono', Monaco, 'Courier New', monospace;
            font-size: 11px;
            color: #787774;
        }

        /* Command/Task Hierarchy Styles */
        .command-group {
            border: 1px solid #e8e7e5;
            border-radius: 6px;
            margin-bottom: 8px;
            background: #fafaf9;
            overflow: hidden;
        }

        .command-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 12px;
            cursor: pointer;
            user-select: none;
            transition: background 0.15s ease;
        }

        .command-header:hover {
            background: #f0efed;
        }

        .command-header-left {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .command-toggle {
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #787774;
            transition: transform 0.2s ease;
        }

        .command-group.collapsed .command-toggle {
            transform: rotate(-90deg);
        }

        .command-name {
            font-size: 13px;
            font-weight: 600;
            color: #37352f;
        }

        .command-duration {
            font-size: 12px;
            font-weight: 500;
            color: #065f46;
            background: #d1fae5;
            padding: 2px 8px;
            border-radius: 4px;
            font-family: 'SF Mono', Monaco, monospace;
        }

        /* Simplified command row for single-task commands (no expand toggle) */
        .command-header-simple {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 12px;
        }

        .command-header-simple .command-name {
            flex: 1;
        }

        .command-header-simple .task-status {
            font-size: 14px;
        }

        .command-group.single-task {
            background: transparent;
        }

        .command-tasks {
            border-top: 1px solid #e8e7e5;
            padding: 8px 0;
        }

        .command-group.collapsed .command-tasks {
            display: none;
        }

        .task-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 12px 6px 32px;
            font-size: 13px;
        }

        .task-item:hover {
            background: #f0efed;
        }

        .task-item-left {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .task-prefix {
            color: #a8a8a8;
            font-size: 11px;
        }

        .task-name {
            color: #37352f;
        }

        .task-item-right {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .task-duration {
            font-size: 12px;
            color: #787774;
            font-family: 'SF Mono', Monaco, monospace;
        }

        .task-status {
            font-size: 11px;
        }

        .task-status.completed {
            color: #10b981;
        }

        .task-status.in-progress {
            color: #f59e0b;
        }

        .task-in-progress {
            background: linear-gradient(
                90deg,
                #fef3c7 0%,
                #fde68a 50%,
                #fef3c7 100%
            );
            background-size: 200% 100%;
            animation: shimmer 2s infinite linear;
        }

        @keyframes shimmer {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }

        /* In-progress stripe pattern for timeline bars */
        .timeline-bar.in-progress-stripe,
        .command-bar.in-progress-stripe,
        .task-bar.in-progress {
            background: repeating-linear-gradient(
                45deg,
                #fbbf24,
                #fbbf24 10px,
                #f59e0b 10px,
                #f59e0b 20px
            );
            animation: stripe-scroll 1s linear infinite;
        }

        @keyframes stripe-scroll {
            0% { background-position: 0 0; }
            100% { background-position: 28px 0; }
        }

        /* Task bar in timeline */
        .task-bar {
            position: absolute;
            height: 14px;
            top: 7px;
            border-radius: 2px;
            display: flex;
            align-items: center;
            padding: 0 4px;
            font-size: 9px;
            font-weight: 500;
            color: white;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            min-width: 20px;
            background: #6b7280;
        }

        .task-bar.completed {
            background: #10b981;
        }

        /* Timeline task rows */
        .timeline-task-row {
            display: flex;
            height: 24px;
            border-top: 1px dotted #e8e7e5;
        }

        .timeline-task-row-label {
            width: var(--timeline-label-width);
            min-width: var(--timeline-label-width);
            padding: 0 12px 0 36px;
            font-size: 11px;
            color: #a8a8a8;
            display: flex;
            align-items: center;
            background: #fafaf9;
            border-right: 1px solid #e8e7e5;
            position: sticky;
            left: 0;
            z-index: 10;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .timeline-task-row-content {
            flex-shrink: 0;
            position: relative;
            height: 24px;
        }

        /* Timeline command group (for expand/collapse) */
        .timeline-command-group {
            /* Default expanded */
        }

        .timeline-command-group.collapsed .timeline-tasks-container {
            display: none;
        }

        .timeline-command-group .cmd-expand-icon {
            display: inline-block;
            width: 12px;
            font-size: 8px;
            color: #a8a8a8;
            transition: transform 0.2s ease;
            margin-right: 4px;
            cursor: pointer;
        }

        .timeline-command-group.collapsed .cmd-expand-icon {
            transform: rotate(-90deg);
        }

        .timeline-command-group:not(.collapsed) .cmd-expand-icon {
            transform: rotate(90deg);
        }

        /* Timeline message row */
        .timeline-message-row {
            display: flex;
            height: 20px;
        }

        .timeline-message-label {
            width: var(--timeline-label-width);
            min-width: var(--timeline-label-width);
            background: #fafaf9;
            border-right: 1px solid #e8e7e5;
            position: sticky;
            left: 0;
            z-index: 10;
        }

        .timeline-message-content {
            flex-shrink: 0;
            position: relative;
            height: 20px;
            display: flex;
            align-items: center;
        }

        .timeline-message-text {
            font-size: 10px;
            color: #787774;
            font-style: italic;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 300px;
            padding-left: 4px;
        }

        /* Task message in activity log */
        .task-message {
            font-size: 11px;
            color: #787774;
            font-style: italic;
            padding: 2px 12px 6px 44px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Filters */
        .filters {
            display: flex;
            gap: 12px;
            margin-bottom: 16px;
            padding: 16px;
            background: white;
            border-radius: 8px;
            border: 1px solid #e8e7e5;
        }

        .filter-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .filter-label {
            font-size: 13px;
            font-weight: 500;
            color: #787774;
        }

        select {
            padding: 6px 12px;
            border: 1px solid #e8e7e5;
            border-radius: 6px;
            font-size: 13px;
            background: white;
            color: #37352f;
            font-family: inherit;
            cursor: pointer;
        }

        select:focus {
            outline: none;
            border-color: #3b82f6;
        }

        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 40px;
            color: #787774;
            font-size: 14px;
        }

        .dashboard-content {
            display: none;
        }

        .dashboard-content.visible {
            display: block;
        }

        /* Tab Navigation */
        .tab-nav {
            display: flex;
            gap: 4px;
            background: white;
            padding: 6px;
            border-radius: 10px;
            margin-bottom: 24px;
            border: 1px solid #e8e7e5;
        }

        .tab-btn {
            flex: 1;
            padding: 12px 24px;
            border: none;
            background: transparent;
            font-size: 14px;
            font-weight: 500;
            color: #787774;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.2s;
        }

        .tab-btn:hover {
            background: #f7f6f3;
            color: #37352f;
        }

        .tab-btn.active {
            background: #37352f;
            color: white;
        }

        .tab-btn .tab-count {
            display: inline-block;
            margin-left: 6px;
            padding: 2px 8px;
            background: rgba(0,0,0,0.1);
            border-radius: 10px;
            font-size: 12px;
        }

        .tab-btn.active .tab-count {
            background: rgba(255,255,255,0.2);
        }

        /* Tab Panels */
        .tab-panel {
            display: none;
        }

        .tab-panel.active {
            display: block;
        }

        /* ============================================================
           TIMELINE STYLES - REDESIGNED
           ============================================================ */
        .timeline-panel {
            position: relative;
        }

        .timeline-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: white;
            border: 1px solid #e8e7e5;
            border-radius: 8px 8px 0 0;
            border-bottom: none;
            height: 48px;
            gap: 16px;
        }

        .timeline-zoom {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .zoom-btn {
            width: 28px;
            height: 28px;
            border: 1px solid #e8e7e5;
            background: white;
            border-radius: 4px;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.15s ease;
        }

        .zoom-btn:hover {
            background: #f7f6f3;
        }

        .zoom-btn:focus {
            outline: 2px solid #3b82f6;
            outline-offset: 1px;
        }

        .zoom-level {
            font-size: 13px;
            font-weight: 500;
            color: #787774;
            min-width: 50px;
            text-align: center;
        }

        /* Visibility button group */
        .timeline-visibility-btns {
            display: flex;
            gap: 6px;
        }

        .visibility-btn {
            padding: 4px 10px;
            font-size: 12px;
            font-weight: 500;
            border: 1px solid #e8e7e5;
            border-radius: 4px;
            background: white;
            color: #787774;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .visibility-btn:hover {
            background: #f7f6f3;
            color: #37352f;
            border-color: #d1d0ce;
        }

        .visibility-btn:focus {
            outline: 2px solid #3b82f6;
            outline-offset: 1px;
        }

        /* Block size input group */
        .timeline-block-size {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .timeline-block-size label {
            font-size: 13px;
            color: #787774;
        }

        .timeline-block-size input {
            width: 60px;
            padding: 4px 8px;
            border: 1px solid #e8e7e5;
            border-radius: 4px;
            font-size: 13px;
            text-align: center;
        }

        .timeline-block-size input:focus {
            outline: none;
            border-color: #3b82f6;
        }

        .timeline-block-size span {
            font-size: 13px;
            color: #787774;
        }

        /* Scrollable Timeline Container */
        .timeline-scroll-container {
            background: white;
            border: 1px solid #e8e7e5;
            border-radius: 0 0 8px 8px;
            overflow-x: auto;
            overflow-y: visible;
            position: relative;
        }

        /* Vertical cursor line for alignment visualization */
        .timeline-cursor-line {
            position: absolute;
            top: 0;
            width: 1px;
            height: 10000px;
            background: rgba(239, 68, 68, 0.5);
            pointer-events: none;
            z-index: 100;
            display: none;
        }

        /* Time Header (sticky top) */
        .timeline-header {
            display: flex;
            border-bottom: 1px solid #e8e7e5;
            background: #fafaf9;
            position: sticky;
            top: 0;
            z-index: 20;
            height: 32px;
        }

        /* Resizable label column header */
        .timeline-label-spacer {
            width: var(--timeline-label-width);
            min-width: var(--timeline-label-width);
            flex-shrink: 0;
            background: #fafaf9;
            border-right: 1px solid #e8e7e5;
            position: sticky;
            left: 0;
            z-index: 25;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 12px;
            font-size: 12px;
            font-weight: 600;
            color: #787774;
        }

        /* Drag handle for resizing */
        .timeline-resize-handle {
            position: absolute;
            top: 0;
            right: 0;
            width: 6px;
            height: 100%;
            cursor: col-resize;
            background: transparent;
            transition: background 0.15s ease;
            z-index: 30;
        }

        .timeline-resize-handle:hover,
        .timeline-resize-handle.active {
            background: #3b82f6;
        }

        .timeline-hours {
            display: flex;
            flex: 1;
        }

        .timeline-hour {
            min-width: 60px;
            padding: 8px 4px;
            text-align: right;
            padding-right: 8px;
            font-size: 11px;
            font-weight: 600;
            color: #787774;
            border-right: 1px solid #e8e7e5;
            flex-shrink: 0;
            line-height: 16px;
        }

        /* Timeline Body */
        .timeline-body {
            position: relative;
            min-height: 200px;
        }

        /* Grid Lines */
        .timeline-grid {
            position: absolute;
            top: 0;
            left: var(--timeline-label-width);
            right: 0;
            bottom: 0;
            display: flex;
            pointer-events: none;
            z-index: 1;
        }

        .timeline-grid-line {
            min-width: 60px;
            border-right: 1px solid #e8e7e5;
            flex-shrink: 0;
            opacity: 0.5;
        }

        .timeline-grid-line.quarter {
            border-right: 1px dashed #e8e7e5;
        }

        /* Compact gap indicator - small width, subtle pattern */
        .timeline-hour.compact {
            min-width: 20px;
            width: 20px;
            padding: 8px 2px;
            background: repeating-linear-gradient(
                45deg,
                transparent,
                transparent 3px,
                #f0efed 3px,
                #f0efed 6px
            );
            color: transparent;
            overflow: hidden;
        }

        .timeline-grid-line.compact {
            min-width: 20px;
            width: 20px;
            background: #f7f6f3;
            border-right: 1px dashed #d1d0ce;
        }

        /* Story Rows Container */
        .timeline-rows {
            position: relative;
            z-index: 5;
        }

        /* Story Row */
        .timeline-row {
            display: flex;
            flex-direction: column;
            min-height: var(--timeline-row-height);
            position: relative;
            border-bottom: 1px solid #f0efed;
        }

        .timeline-row.expanded {
            min-height: auto;
        }

        /* Hidden story row styling - shown at bottom with muted appearance */
        .timeline-row.hidden-story {
            opacity: 0.5;
            background: #f7f6f3;
        }

        .timeline-row.hidden-story .timeline-row-label {
            background: #f7f6f3;
        }

        .timeline-row.hidden-story .timeline-row-label:hover {
            background: #efeeec;
        }

        /* Row main content (label + bar area) */
        .timeline-row-main {
            display: flex;
            height: var(--timeline-row-height);
            min-height: var(--timeline-row-height);
        }

        /* Row Label (Sticky Left) - CLICKABLE for expand */
        .timeline-row-label {
            width: var(--timeline-label-width);
            min-width: var(--timeline-label-width);
            padding: 0 12px;
            flex-shrink: 0;
            position: sticky;
            left: 0;
            background: white;
            z-index: 10;
            border-right: 1px solid #e8e7e5;
            display: flex;
            flex-direction: row;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            user-select: none;
            transition: background 0.15s ease;
        }

        .timeline-row-label:hover {
            background: #f7f6f3;
        }

        .label-title {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            font-size: 13px;
            font-weight: 500;
            color: #37352f;
        }

        .label-duration {
            flex-shrink: 0;
            margin-left: 8px;
            font-size: 11px;
            font-weight: 400;
            color: #787774;
            font-family: 'SF Mono', Monaco, monospace;
        }

        /* Story visibility checkbox */
        .story-visibility-checkbox {
            width: 14px;
            height: 14px;
            margin-right: 6px;
            cursor: pointer;
            accent-color: #10b981;
            flex-shrink: 0;
        }

        /* Expand indicator in label */
        .label-expand-icon {
            flex-shrink: 0;
            margin-right: 8px;
            font-size: 10px;
            color: #787774;
            transition: transform 0.2s ease;
        }

        .timeline-row.expanded .label-expand-icon {
            transform: rotate(90deg);
        }

        /* Row Content Area */
        .timeline-row-content {
            flex-shrink: 0;
            position: relative;
            height: var(--timeline-row-height);
            min-height: var(--timeline-row-height);
        }

        /* Story Bar - NOT clickable for expand anymore */
        .timeline-bar {
            position: absolute;
            height: 24px;
            top: 12px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            padding: 0 8px;
            font-size: 11px;
            font-weight: 500;
            color: white;
            white-space: nowrap;
            overflow: hidden;
            min-width: 40px;
            z-index: 5;
        }

        /* Story bars - ONE consistent color */
        .timeline-bar.story-bar {
            background: var(--timeline-story-color);
        }

        .timeline-bar.story-bar.in-progress {
            background: var(--timeline-story-in-progress-color);
            color: #37352f;
        }

        .bar-label {
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Command Rows Container (shown when expanded) */
        .timeline-command-rows {
            display: none;
            flex-direction: column;
            width: 100%;
        }

        .timeline-row.expanded .timeline-command-rows {
            display: flex;
        }

        /* Individual command row */
        .timeline-command-row {
            display: flex;
            height: var(--timeline-command-row-height);
            border-top: 1px dashed #e8e7e5;
        }

        .timeline-command-row-label {
            width: var(--timeline-label-width);
            min-width: var(--timeline-label-width);
            padding: 0 12px 0 24px;
            font-size: 12px;
            color: #787774;
            display: flex;
            align-items: center;
            background: #fafaf9;
            border-right: 1px solid #e8e7e5;
            position: sticky;
            left: 0;
            z-index: 10;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .timeline-command-row-content {
            flex-shrink: 0;
            position: relative;
            height: var(--timeline-command-row-height);
        }

        /* Command Bar - Different colors per type */
        .command-bar {
            position: absolute;
            height: 18px;
            top: 5px;
            border-radius: 3px;
            display: flex;
            align-items: center;
            padding: 0 6px;
            font-size: 10px;
            font-weight: 500;
            color: white;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            min-width: 30px;
        }

        /* Command Type Colors */
        .command-bar.create-story { background: #3b82f6; }
        .command-bar.story-review { background: #f59e0b; color: #37352f; }
        .command-bar.create-tech-spec { background: #6366f1; }
        .command-bar.tech-spec-review { background: #8b5cf6; }
        .command-bar.dev-story { background: #22c55e; }
        .command-bar.code-review { background: #a855f7; }
        .command-bar.default { background: #6b7280; }

        .command-label {
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Timeline Tooltip */
        .timeline-tooltip {
            position: fixed;
            background: #37352f;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            max-width: 280px;
            z-index: 1000;
            pointer-events: none;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            opacity: 0;
            transition: opacity 0.15s ease;
            line-height: 1.4;
        }

        .timeline-tooltip.visible {
            opacity: 1;
        }

        .timeline-tooltip-title {
            font-weight: 600;
            margin-bottom: 4px;
            word-break: break-word;
        }

        .timeline-tooltip-meta {
            color: #a8a8a8;
        }

        /* Empty State */
        .timeline-empty {
            text-align: center;
            padding: 60px 20px;
            color: #787774;
            font-size: 14px;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .epic-board {
                grid-template-columns: 1fr;
            }

            .summary-cards {
                grid-template-columns: 1fr;
            }

            .table-container {
                overflow-x: auto;
            }

            table {
                min-width: 600px;
            }
        }

        /* Milestone display styles */
        .step-milestones {
            margin-top: 6px;
            font-size: 0.75rem;
            line-height: 1.4;
        }

        .milestone {
            display: inline-block;
            background: #e8e8e5;
            color: #555;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
            margin: 2px 0;
        }

        .milestone-arrow {
            color: #999;
            margin: 0 4px;
            font-size: 10px;
        }

        .step-name {
            font-size: 0.85rem;
            color: #555;
            max-width: 150px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* Dark mode support */
        @media (prefers-color-scheme: dark) {
            .milestone {
                background: #3a3a3a;
                color: #ccc;
            }
            .milestone-arrow {
                color: #666;
            }
        }

        /* ============================================================
           SPRINT RUN TAB STYLES (Story 5-SR-6)
           ============================================================ */

        /* Control Panel */
        .sprint-controls {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 16px;
            background: white;
            border-radius: 8px;
            margin-bottom: 16px;
            border: 1px solid #e8e7e5;
            flex-wrap: wrap;
        }

        .sprint-controls-row {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .sprint-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .sprint-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .sprint-btn.start {
            background: #10b981;
            color: white;
        }

        .sprint-btn.start:hover:not(:disabled) {
            background: #059669;
        }

        .sprint-btn.stop {
            background: #ef4444;
            color: white;
        }

        .sprint-btn.stop:hover:not(:disabled) {
            background: #dc2626;
        }

        .batch-size-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .batch-size-group label {
            font-size: 13px;
            color: #787774;
            font-weight: 500;
        }

        .batch-size-input {
            width: 60px;
            padding: 8px 10px;
            border: 1px solid #e8e7e5;
            border-radius: 6px;
            font-size: 14px;
            text-align: center;
        }

        .batch-size-input:focus {
            outline: none;
            border-color: #3b82f6;
        }

        .batch-size-input:disabled {
            background: #f7f6f3;
            color: #9ca3af;
        }

        .run-all-group {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .run-all-group input[type="checkbox"] {
            width: 16px;
            height: 16px;
            accent-color: #10b981;
            cursor: pointer;
        }

        .run-all-group label {
            font-size: 13px;
            color: #787774;
            cursor: pointer;
        }

        /* Status Display */
        .sprint-status {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 4px;
            min-width: 200px;
        }

        .sprint-status-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .sprint-status-label {
            font-size: 12px;
            color: #787774;
            min-width: 60px;
        }

        .sprint-status-value {
            font-size: 14px;
            font-weight: 500;
            color: #37352f;
        }

        .sprint-status-value.idle {
            color: #9ca3af;
        }

        .sprint-status-value.running {
            color: #10b981;
        }

        .sprint-status-value.stopping {
            color: #f59e0b;
        }

        .sprint-status-value.error {
            color: #ef4444;
        }

        /* Progress Section */
        .sprint-progress {
            background: white;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
            border: 1px solid #e8e7e5;
        }

        .sprint-progress-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .sprint-progress-title {
            font-size: 14px;
            font-weight: 600;
            color: #37352f;
        }

        .sprint-progress-stats {
            font-size: 13px;
            color: #787774;
        }

        .sprint-progress-bar {
            width: 100%;
            height: 8px;
            background: #e8e7e5;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 12px;
        }

        .sprint-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #10b981 0%, #34d399 100%);
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        .sprint-active-stories {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .sprint-story-badge {
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 500;
            background: #e8e7e5;
            color: #787774;
        }

        .sprint-story-badge.in-progress {
            background: #fef3c7;
            color: #92400e;
        }

        .sprint-story-badge.done {
            background: #d1fae5;
            color: #065f46;
        }

        /* Event Log */
        .sprint-log {
            background: #1a1a2e;
            color: #e0e0e0;
            font-family: 'SF Mono', Monaco, 'Courier New', monospace;
            font-size: 12px;
            padding: 16px;
            border-radius: 8px;
            max-height: 500px;
            overflow-y: auto;
            border: 1px solid #2a2a4e;
        }

        .sprint-log-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 12px;
            border-bottom: 1px solid #2a2a4e;
            margin-bottom: 12px;
        }

        .sprint-log-title {
            font-size: 14px;
            font-weight: 600;
            color: white;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        .sprint-log-actions {
            display: flex;
            gap: 8px;
        }

        .sprint-log-btn {
            padding: 4px 8px;
            font-size: 11px;
            background: rgba(255,255,255,0.1);
            border: none;
            border-radius: 4px;
            color: #a0a0a0;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .sprint-log-btn:hover {
            background: rgba(255,255,255,0.2);
            color: white;
        }

        .sprint-log-entries {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .log-entry {
            padding: 6px 10px;
            border-radius: 4px;
            display: flex;
            gap: 12px;
            line-height: 1.4;
        }

        .log-entry.start {
            background: rgba(59, 130, 246, 0.15);
            border-left: 3px solid #3b82f6;
        }

        .log-entry.progress {
            background: rgba(251, 191, 36, 0.1);
            border-left: 3px solid #fbbf24;
        }

        .log-entry.end {
            background: rgba(16, 185, 129, 0.15);
            border-left: 3px solid #10b981;
        }

        .log-entry.error {
            background: rgba(239, 68, 68, 0.2);
            border-left: 3px solid #ef4444;
        }

        .log-entry.system {
            background: rgba(139, 92, 246, 0.15);
            border-left: 3px solid #8b5cf6;
        }

        .log-timestamp {
            color: #6b7280;
            flex-shrink: 0;
            width: 70px;
        }

        .log-story-key {
            color: #60a5fa;
            flex-shrink: 0;
            min-width: 80px;
        }

        .log-command {
            color: #c084fc;
            flex-shrink: 0;
            min-width: 100px;
        }

        .log-task-id {
            color: #9ca3af;
            flex-shrink: 0;
            min-width: 80px;
        }

        .log-status {
            font-weight: 600;
            flex-shrink: 0;
            min-width: 60px;
        }

        .log-status.start { color: #3b82f6; }
        .log-status.progress { color: #fbbf24; }
        .log-status.end { color: #10b981; }
        .log-status.error { color: #ef4444; }

        .log-message {
            color: #d1d5db;
            flex: 1;
            word-break: break-word;
        }

        .log-empty {
            color: #6b7280;
            text-align: center;
            padding: 40px;
            font-style: italic;
        }

        /* Connection Status */
        .ws-connection-status {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            color: #787774;
        }

        .ws-connection-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #9ca3af;
        }

        .ws-connection-dot.connected {
            background: #10b981;
            animation: pulse 2s infinite;
        }

        .ws-connection-dot.disconnected {
            background: #ef4444;
        }

        .ws-connection-dot.connecting {
            background: #fbbf24;
            animation: pulse 1s infinite;
        }

        /* Toast Notifications */
        .toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .toast {
            background: white;
            padding: 12px 16px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            display: flex;
            align-items: center;
            gap: 10px;
            max-width: 400px;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .toast.error {
            border-left: 4px solid #ef4444;
        }

        .toast.success {
            border-left: 4px solid #10b981;
        }

        .toast.warning {
            border-left: 4px solid #f59e0b;
        }

        .toast-icon {
            font-size: 18px;
            flex-shrink: 0;
        }

        .toast-content {
            flex: 1;
        }

        .toast-title {
            font-size: 14px;
            font-weight: 600;
            color: #37352f;
            margin-bottom: 2px;
        }

        .toast-message {
            font-size: 13px;
            color: #787774;
        }

        .toast-close {
            background: none;
            border: none;
            font-size: 18px;
            color: #9ca3af;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }

        .toast-close:hover {
            color: #37352f;
        }

        /* Sprint Run Tab Active Indicator */
        .tab-btn[data-tab="sprintrun"] .tab-count.active {
            background: #10b981;
            color: white;
        }

    </style>
</head>
<body>
    <!-- Toast Container (fixed position) -->
    <div class="toast-container" id="toastContainer"></div>

    <div class="container">
        <!-- Story Tooltip -->
        <div class="story-tooltip" id="storyTooltip"></div>

        <!-- Header -->
        <header>
            <h1>Grimoire</h1>
            <div class="last-updated">
                <span class="update-dot" id="updateDot"></span>
                <span id="lastUpdated">Loading...</span>
            </div>
        </header>

        <!-- Dashboard Content -->
        <div class="dashboard-content" id="dashboardContent">
            <!-- Summary Cards -->
            <div class="summary-cards">
                <div class="card">
                    <div class="card-label">Total Epics</div>
                    <div class="card-value" id="totalEpics">0</div>
                    <div class="card-subtitle">In-progress: <span id="epicsInProgress">0</span></div>
                </div>
                <div class="card">
                    <div class="card-label">Stories</div>
                    <div class="card-value" id="storiesProgress">0/0</div>
                    <div class="card-subtitle">Completion: <span id="storiesPercent">0%</span></div>
                </div>
                <div class="card">
                    <div class="card-label">Current Story</div>
                    <div class="card-value" style="font-size: 16px; line-height: 1.4;" id="currentStory">-</div>
                    <div class="card-subtitle" id="currentStoryStatus">-</div>
                </div>
            </div>

            <!-- Tab Navigation -->
            <div class="tab-nav">
                <button class="tab-btn active" data-tab="epics">Epics <span class="tab-count" id="epicsCount">0</span></button>
                <button class="tab-btn" data-tab="stories">Stories <span class="tab-count" id="storiesCount">0</span></button>
                <button class="tab-btn" data-tab="activity">Activity <span class="tab-count" id="activityCount">0</span></button>
                <button class="tab-btn" data-tab="timeline">Timeline</button>
                <button class="tab-btn" data-tab="sprintrun">Sprint Run <span class="tab-count" id="sprintrunCount"></span></button>
            </div>

            <!-- Epic Board Tab -->
            <div class="tab-panel active" id="tab-epics">
                <div class="epic-board">
                    <div class="epic-column">
                        <div class="epic-column-header">Backlog</div>
                        <div id="epicsBacklog"></div>
                    </div>
                    <div class="epic-column">
                        <div class="epic-column-header">In Progress</div>
                        <div id="epicsInProgressCol"></div>
                    </div>
                    <div class="epic-column">
                        <div class="epic-column-header">Done</div>
                        <div id="epicsDone"></div>
                    </div>
                </div>
            </div>

            <!-- Stories Tab -->
            <div class="tab-panel" id="tab-stories">
                <div class="filters">
                    <div class="filter-group">
                        <label class="filter-label">Epic:</label>
                        <select id="epicFilter">
                            <option value="all">All Epics</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label class="filter-label">Status:</label>
                        <select id="statusFilter">
                            <option value="all">All Statuses</option>
                            <option value="backlog">Backlog</option>
                            <option value="ready-for-dev">Ready for Dev</option>
                            <option value="in-progress">In Progress</option>
                            <option value="review">Review</option>
                            <option value="done">Done</option>
                        </select>
                    </div>
                </div>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr>
                                <th>Story ID</th>
                                <th>Name</th>
                                <th>Epic</th>
                                <th>Duration</th>
                                <th>Status</th>
                            </tr>
                        </thead>
                        <tbody id="storyTableBody">
                            <tr><td colspan="5" class="empty-state">No stories loaded</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Activity Tab -->
            <div class="tab-panel" id="tab-activity">
                <div class="activity-log" id="activityLog">
                    <div class="empty-state">No activity loaded</div>
                </div>
            </div>

            <!-- Timeline Tab - REDESIGNED -->
            <div class="tab-panel timeline-panel" id="tab-timeline" role="region" aria-label="Project Timeline">
                <!-- Controls Bar -->
                <div class="timeline-controls">
                    <div class="timeline-zoom">
                        <button class="zoom-btn" data-action="out" onclick="zoomTimeline('out')" aria-label="Zoom out">-</button>
                        <span class="zoom-level" id="zoomLevel">100%</span>
                        <button class="zoom-btn" data-action="in" onclick="zoomTimeline('in')" aria-label="Zoom in">+</button>
                    </div>

                    <!-- Visibility buttons -->
                    <div class="timeline-visibility-btns">
                        <button class="visibility-btn" onclick="showAllStories()">Show All</button>
                        <button class="visibility-btn" onclick="hideAllStories()">Hide All</button>
                    </div>

                    <!-- Block size input (minutes) -->
                    <div class="timeline-block-size">
                        <label for="blockSizeInput">Block (min):</label>
                        <input type="number"
                               id="blockSizeInput"
                               min="1"
                               max="480"
                               step="1"
                               value="10"
                               onkeydown="if(event.key==='Enter'){this.blur();}"
                               onblur="setBlockSizeMinutes(this.value)">
                    </div>
                </div>

                <!-- Scrollable Container -->
                <div class="timeline-scroll-container" id="timelineScrollContainer">
                    <!-- Vertical cursor line for alignment -->
                    <div class="timeline-cursor-line" id="timelineCursorLine"></div>

                    <!-- Time Header (sticky top) with resize handle -->
                    <div class="timeline-header" id="timelineHeader">
                        <div class="timeline-label-spacer">
                            <span>Story</span>
                            <div class="timeline-resize-handle" id="resizeHandle"></div>
                        </div>
                        <div class="timeline-hours" id="timelineHours">
                            <!-- Generated time blocks -->
                        </div>
                    </div>

                    <!-- Timeline Body -->
                    <div class="timeline-body" id="timelineBody">
                        <!-- Grid Lines (absolute positioned) -->
                        <div class="timeline-grid" id="timelineGrid"></div>

                        <!-- Story Rows -->
                        <div class="timeline-rows" id="timelineRows">
                            <!-- Generated story rows -->
                        </div>
                    </div>
                </div>

                <!-- Tooltip (positioned absolutely) -->
                <div class="timeline-tooltip" id="timelineTooltip"></div>
            </div>

            <!-- Sprint Run Tab (Story 5-SR-6) -->
            <div class="tab-panel" id="tab-sprintrun">
                <!-- Control Panel -->
                <div class="sprint-controls">
                    <div class="sprint-controls-row">
                        <button class="sprint-btn start" id="sprintStartBtn">
                            <span>&#9654;</span> Start
                        </button>
                        <button class="sprint-btn stop" id="sprintStopBtn" disabled>
                            <span>&#9632;</span> Stop
                        </button>
                    </div>

                    <div class="batch-size-group">
                        <label for="batchSizeInput">Batch Size:</label>
                        <input type="number" id="batchSizeInput" class="batch-size-input" value="2" min="1" max="100">
                    </div>

                    <div class="run-all-group">
                        <input type="checkbox" id="runAllCheckbox">
                        <label for="runAllCheckbox">Run All</label>
                    </div>

                    <div class="sprint-status">
                        <div class="sprint-status-row">
                            <span class="sprint-status-label">Status:</span>
                            <span class="sprint-status-value idle" id="sprintStatusValue">Idle</span>
                        </div>
                        <div class="sprint-status-row">
                            <span class="sprint-status-label">Current:</span>
                            <span class="sprint-status-value" id="sprintCurrentOp">-</span>
                        </div>
                    </div>

                    <div class="ws-connection-status">
                        <span class="ws-connection-dot" id="wsConnectionDot"></span>
                        <span id="wsConnectionText">Disconnected</span>
                    </div>
                </div>

                <!-- Progress Section (Creative Enhancement) -->
                <div class="sprint-progress" id="sprintProgressSection" style="display: none;">
                    <div class="sprint-progress-header">
                        <span class="sprint-progress-title">Cycle Progress</span>
                        <span class="sprint-progress-stats" id="sprintProgressStats">0/0 cycles</span>
                    </div>
                    <div class="sprint-progress-bar">
                        <div class="sprint-progress-fill" id="sprintProgressFill" style="width: 0%;"></div>
                    </div>
                    <div class="sprint-active-stories" id="sprintActiveStories">
                        <!-- Active story badges will be rendered here -->
                    </div>
                </div>

                <!-- Event Log -->
                <div class="sprint-log" id="sprintLog">
                    <div class="sprint-log-header">
                        <span class="sprint-log-title">Event Log</span>
                        <div class="sprint-log-actions">
                            <button class="sprint-log-btn" onclick="clearSprintLog()">Clear</button>
                            <button class="sprint-log-btn" onclick="toggleAutoScroll()">Auto-scroll: <span id="autoScrollState">ON</span></button>
                        </div>
                    </div>
                    <div class="sprint-log-entries" id="sprintLogEntries">
                        <div class="log-empty">No events yet. Start a sprint run to see live events.</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // State management
        let state = {
            sprintData: null,
            orchestratorData: null,
            lastUpdateTime: null,
            watchInterval: null,
            isWatching: false,
            autoLoadWorks: false,
            lastDataHash: null
        };

        // ============================================================
        // UI State Persistence (Story 5-SR-7)
        // ============================================================
        const UI_STATE_KEYS = {
            ACTIVE_TAB: 'dashboard-active-tab',           // existing
            TIMELINE_WIDTH: 'timeline-label-width',       // existing
            EXPANDED_EPICS: 'dashboard-expanded-epics',   // new: ['epic-1', 'epic-2']
            FILTERS: 'dashboard-filters',                 // new: {epic: 'all', status: 'all'}
            CHECKBOXES: 'dashboard-checkboxes',           // new: (reserved for future checkboxes)
            BATCH_SIZE: 'dashboard-batch-size',           // new: number or 'all'
            SORT_PREFS: 'dashboard-sort-prefs',           // new: {column: 'story', dir: 'asc'}
            SCROLL_POSITIONS: 'dashboard-scroll-positions', // new: {tableContainer: 0, activityLog: 0}
            EXPANDED_ACTIVITIES: 'dashboard-expanded-activities', // new: activity indices to keep expanded
            TIMELINE_EXPANDED_STORIES: 'dashboard-timeline-expanded-stories', // new: timeline story rows
            TIMELINE_HIDDEN_STORIES: 'dashboard-timeline-hidden-stories' // new: hidden stories
        };

        // Save all UI state to localStorage
        function saveUIState() {
            try {
                // Get expanded epic IDs
                const expandedEpics = Array.from(document.querySelectorAll('.epic-card.expanded'))
                    .map(el => el.dataset.epicId)
                    .filter(Boolean);
                localStorage.setItem(UI_STATE_KEYS.EXPANDED_EPICS, JSON.stringify(expandedEpics));

                // Get filter values
                const epicFilter = document.getElementById('epicFilter')?.value || 'all';
                const statusFilter = document.getElementById('statusFilter')?.value || 'all';
                localStorage.setItem(UI_STATE_KEYS.FILTERS, JSON.stringify({ epic: epicFilter, status: statusFilter }));

                // Get batch size (if exists)
                const batchSizeEl = document.getElementById('batchSize');
                if (batchSizeEl) {
                    localStorage.setItem(UI_STATE_KEYS.BATCH_SIZE, batchSizeEl.value);
                }

                // Get scroll positions
                const scrollPositions = {};
                const tableContainer = document.querySelector('.table-container');
                if (tableContainer) scrollPositions.tableContainer = tableContainer.scrollTop;
                const activityLog = document.getElementById('activityLog');
                if (activityLog) scrollPositions.activityLog = activityLog.scrollTop;
                const timelineScroll = document.getElementById('timelineScrollContainer');
                if (timelineScroll) scrollPositions.timelineScroll = timelineScroll.scrollLeft;
                localStorage.setItem(UI_STATE_KEYS.SCROLL_POSITIONS, JSON.stringify(scrollPositions));

                // Get expanded activity items (collapsed is default, track non-collapsed)
                const expandedActivities = Array.from(document.querySelectorAll('.activity-item:not(.collapsed)'))
                    .map((el, idx) => idx)
                    .filter(idx => idx > 0); // First item is expanded by default
                localStorage.setItem(UI_STATE_KEYS.EXPANDED_ACTIVITIES, JSON.stringify(expandedActivities));

                // Save timeline expanded stories
                localStorage.setItem(UI_STATE_KEYS.TIMELINE_EXPANDED_STORIES,
                    JSON.stringify(Array.from(timelineState.expandedStoryIds)));

                // Save timeline hidden stories
                localStorage.setItem(UI_STATE_KEYS.TIMELINE_HIDDEN_STORIES,
                    JSON.stringify(Array.from(timelineState.hiddenStories)));
            } catch (e) {
                console.warn('Failed to save UI state:', e);
            }
        }

        // Restore UI state from localStorage (call before initial render)
        function restoreUIState() {
            try {
                // Restore filters
                const filtersJson = localStorage.getItem(UI_STATE_KEYS.FILTERS);
                if (filtersJson) {
                    const filters = JSON.parse(filtersJson);
                    const epicFilter = document.getElementById('epicFilter');
                    const statusFilter = document.getElementById('statusFilter');
                    if (epicFilter && filters.epic) epicFilter.value = filters.epic;
                    if (statusFilter && filters.status) statusFilter.value = filters.status;
                }

                // Restore batch size
                const batchSize = localStorage.getItem(UI_STATE_KEYS.BATCH_SIZE);
                if (batchSize) {
                    const batchSizeEl = document.getElementById('batchSize');
                    if (batchSizeEl) batchSizeEl.value = batchSize;
                }

                // Restore timeline expanded stories
                const timelineExpandedJson = localStorage.getItem(UI_STATE_KEYS.TIMELINE_EXPANDED_STORIES);
                if (timelineExpandedJson) {
                    const expanded = JSON.parse(timelineExpandedJson);
                    timelineState.expandedStoryIds = new Set(expanded);
                }

                // Restore timeline hidden stories
                const timelineHiddenJson = localStorage.getItem(UI_STATE_KEYS.TIMELINE_HIDDEN_STORIES);
                if (timelineHiddenJson) {
                    const hidden = JSON.parse(timelineHiddenJson);
                    timelineState.hiddenStories = new Set(hidden);
                }
            } catch (e) {
                console.warn('Failed to restore UI state:', e);
            }
        }

        // Restore scroll positions (call after render)
        function restoreScrollPositions() {
            try {
                const scrollJson = localStorage.getItem(UI_STATE_KEYS.SCROLL_POSITIONS);
                if (scrollJson) {
                    const positions = JSON.parse(scrollJson);
                    const tableContainer = document.querySelector('.table-container');
                    if (tableContainer && positions.tableContainer) tableContainer.scrollTop = positions.tableContainer;
                    const activityLog = document.getElementById('activityLog');
                    if (activityLog && positions.activityLog) activityLog.scrollTop = positions.activityLog;
                    const timelineScroll = document.getElementById('timelineScrollContainer');
                    if (timelineScroll && positions.timelineScroll) timelineScroll.scrollLeft = positions.timelineScroll;
                }
            } catch (e) {
                console.warn('Failed to restore scroll positions:', e);
            }
        }

        // Restore expanded epics (call after renderEpicBoard)
        function restoreExpandedEpics() {
            try {
                const expandedJson = localStorage.getItem(UI_STATE_KEYS.EXPANDED_EPICS);
                if (expandedJson) {
                    const expandedIds = JSON.parse(expandedJson);
                    expandedIds.forEach(epicId => {
                        const card = document.querySelector(`.epic-card[data-epic-id="${CSS.escape(epicId)}"]`);
                        if (card && !card.classList.contains('expanded')) {
                            toggleEpicCard(epicId);
                        }
                    });
                }
            } catch (e) {
                console.warn('Failed to restore expanded epics:', e);
            }
        }

        // Restore expanded activities (call after renderActivityLog)
        function restoreExpandedActivities() {
            try {
                const expandedJson = localStorage.getItem(UI_STATE_KEYS.EXPANDED_ACTIVITIES);
                if (expandedJson) {
                    const expandedIndices = JSON.parse(expandedJson);
                    const items = document.querySelectorAll('.activity-item');
                    items.forEach((item, idx) => {
                        if (idx === 0) {
                            // First item should be expanded by default
                            item.classList.remove('collapsed');
                        } else if (expandedIndices.includes(idx)) {
                            item.classList.remove('collapsed');
                        }
                    });
                }
            } catch (e) {
                console.warn('Failed to restore expanded activities:', e);
            }
        }

        // Simple string hash function for change detection
        function hashString(str) {
            let hash = 0;
            if (!str || str.length === 0) return hash;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }
            return hash;
        }

        // Story descriptions cache
        let storyDescriptions = {};

        // ============================================================
        // Security: HTML Escaping Utility
        // ============================================================
        function escapeHtml(text) {
            if (text === null || text === undefined) return '';
            const str = String(text);
            const div = document.createElement('div');
            div.textContent = str;
            return div.innerHTML;
        }

        // Escape for use in JavaScript string literals (prevents XSS in inline handlers)
        function escapeJsString(text) {
            if (text === null || text === undefined) return '';
            return String(text)
                .replace(/\\/g, '\\\\')
                .replace(/'/g, "\\'")
                .replace(/"/g, '\\"')
                .replace(/\n/g, '\\n')
                .replace(/\r/g, '\\r');
        }

        // Normalize status string for CSS class usage
        function normalizeStatusForClass(status) {
            if (!status) return 'backlog';
            return String(status).toLowerCase().trim().replace(/_/g, '-');
        }

        // ============================================================
        // Incremental DOM Update Helpers (Story 5-SR-7)
        // ============================================================

        // Update element content only if changed (prevents flicker)
        function updateElement(selector, newContent) {
            const el = typeof selector === 'string' ? document.querySelector(selector) : selector;
            if (!el) return false;
            if (el.innerHTML !== newContent) {
                el.innerHTML = newContent;
                return true;
            }
            return false;
        }

        // Update text content only if changed
        function updateTextContent(selector, newText) {
            const el = typeof selector === 'string' ? document.querySelector(selector) : selector;
            if (!el) return false;
            if (el.textContent !== newText) {
                el.textContent = newText;
                return true;
            }
            return false;
        }

        // Save scroll position before updates
        function saveScrollPosition(el) {
            if (!el) return { top: 0, left: 0 };
            return { top: el.scrollTop, left: el.scrollLeft };
        }

        // Restore scroll position after updates
        function restoreScrollPosition(el, pos) {
            if (!el || !pos) return;
            el.scrollTop = pos.top;
            el.scrollLeft = pos.left;
        }

        // ============================================================
        // TIMELINE STATE - REDESIGNED
        // ============================================================
        // Fixed column width constant
        const COLUMN_WIDTH_PX = 60;  // Fixed pixel width for all columns (uniform grid)

        let timelineState = {
            zoomLevel: 100,
            labelColumnWidth: 200,
            minLabelWidth: 120,
            maxLabelWidth: 400,
            blockSizeMinutes: 10,
            expandedStoryIds: new Set(),  // Multiple stories can be expanded
            expandedCommands: new Map(),  // Track command expand/collapse state (key -> boolean, default true)
            timelineStartTs: null,
            timelineEndTs: null,
            totalTimelineWidth: 0,  // Continuous timeline width in pixels
            hiddenStories: new Set(),
            processedBlocks: []
        };

        // Column resize state
        let resizeState = {
            isResizing: false,
            startX: 0,
            startWidth: 0
        };

        // Timeline cache
        let timelineCache = {
            data: null,
            dataHash: null,
            hasScrolled: false
        };

        // Command type color mapping
        const COMMAND_COLORS = {
            'create-story': '#3b82f6',
            'story-review': '#f59e0b',
            'create-tech-spec': '#6366f1',
            'tech-spec-review': '#8b5cf6',
            'dev-story': '#22c55e',
            'code-review': '#a855f7'
        };

        // ============================================================
        // Utility Functions
        // ============================================================

        // Format unix timestamp to readable date
        function formatTimestamp(ts) {
            const date = new Date(ts * 1000);
            return date.toLocaleString('en-US', {
                month: 'short',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });
        }

        // Format ISO date string to readable date
        function formatISODate(isoString) {
            if (!isoString) return '';
            try {
                const date = new Date(isoString);
                if (isNaN(date.getTime())) return isoString;
                return date.toLocaleString('en-US', {
                    month: 'short',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });
            } catch (e) {
                return isoString;
            }
        }

        // Format duration in seconds to human readable
        function formatDuration(seconds) {
            if (!seconds || seconds <= 0) return '';
            if (seconds < 60) {
                return `${Math.round(seconds)}s`;
            } else if (seconds < 3600) {
                const mins = Math.floor(seconds / 60);
                const secs = Math.round(seconds % 60);
                return secs > 0 ? `${mins}m ${secs}s` : `${mins}m`;
            } else {
                const hours = Math.floor(seconds / 3600);
                const mins = Math.floor((seconds % 3600) / 60);
                return mins > 0 ? `${hours}h ${mins}m` : `${hours}h`;
            }
        }

        // Parse duration from ~Xm format to minutes
        function parseDurationToMinutes(durationStr) {
            if (!durationStr) return 0;
            const cleaned = String(durationStr).replace(/^~/, '').trim();
            const hourMatch = cleaned.match(/(\d+)h/);
            const minMatch = cleaned.match(/(\d+)m/);
            const secMatch = cleaned.match(/(\d+)s/);

            let minutes = 0;
            if (hourMatch) minutes += parseInt(hourMatch[1], 10) * 60;
            if (minMatch) minutes += parseInt(minMatch[1], 10);
            if (secMatch) minutes += parseInt(secMatch[1], 10) / 60;

            if (!hourMatch && !minMatch && !secMatch) {
                const numMatch = cleaned.match(/(\d+)/);
                if (numMatch) minutes = parseInt(numMatch[1], 10);
            }

            return minutes;
        }

        // Get command CSS class
        function getCommandClass(command) {
            if (!command) return 'default';
            const baseCommand = command.split(' ')[0].split('#')[0].trim();
            return COMMAND_COLORS[baseCommand] ? baseCommand : 'default';
        }

        // ============================================================
        // ORCHESTRATOR PARSERS - 7-COLUMN FORMAT (backward compatible with 6)
        // ============================================================

        // RFC 4180 compliant CSV line parser
        // Handles quoted fields with escaped quotes ("")
        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;

            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                const nextChar = line[i + 1];

                if (inQuotes) {
                    if (char === '"' && nextChar === '"') {
                        current += '"';
                        i++; // Skip escaped quote
                    } else if (char === '"') {
                        inQuotes = false;
                    } else {
                        current += char;
                    }
                } else {
                    if (char === '"') {
                        inQuotes = true;
                    } else if (char === ',') {
                        result.push(current);
                        current = '';
                    } else {
                        current += char;
                    }
                }
            }
            result.push(current);
            return result;
        }

        // Parse orchestrator CSV log
        // Format (7-column): timestamp,epicID,storyID,command,task-id,status,"message"
        // Format (6-column legacy): timestamp,epicID,storyID,command,task-id,status
        // - status = "start" or "end"
        // - Duration calculated by matching start/end pairs
        // - Orphan handling: < 30 min = in-progress, >= 30 min = ignore
        function parseOrchestratorCSV(text) {
            const THIRTY_MINUTES = 30 * 60; // 1800 seconds
            const currentTime = Math.floor(Date.now() / 1000);

            const lines = text.trim().split('\n');
            const startIndex = lines[0].includes('timestamp') || lines[0].includes('unix_timestamp') ? 1 : 0;

            // First pass: collect all entries and match start/end pairs
            // Key format: epicId|storyId|command|taskId
            const pairMap = new Map(); // key -> { start: entry, end: entry, startMessage, endMessage }
            const allEntries = [];

            for (let i = startIndex; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;

                // Use RFC 4180 parser for proper quote handling
                const parts = parseCSVLine(line);
                if (parts.length < 6) continue;

                // 6-column: timestamp,epic,story,cmd,task,status
                // 7-column: timestamp,epic,story,cmd,task,status,message
                const [timestamp, epicId, storyId, command, taskId, status, message = ''] = parts;
                const ts = parseInt(timestamp, 10);
                if (isNaN(ts)) continue;

                const entry = {
                    timestamp: ts,
                    epicId: epicId.startsWith('epic-') ? epicId : `epic-${epicId}`,
                    storyId,
                    command,
                    taskId,
                    status: status.trim().toLowerCase(),
                    message: message.trim()
                };

                allEntries.push(entry);

                // Build pairing key
                const pairKey = `${entry.epicId}|${storyId}|${command}|${taskId}`;

                if (!pairMap.has(pairKey)) {
                    pairMap.set(pairKey, { start: null, end: null, startMessage: '', endMessage: '' });
                }

                const pair = pairMap.get(pairKey);
                if (entry.status === 'start') {
                    pair.start = entry;
                    pair.startMessage = entry.message;
                } else if (entry.status === 'end') {
                    pair.end = entry;
                    pair.endMessage = entry.message;
                }
            }

            // Second pass: build hierarchical structure
            // story -> commands -> tasks
            const storyMap = new Map();

            pairMap.forEach((pair, pairKey) => {
                const startEntry = pair.start;
                const endEntry = pair.end;

                // Must have at least a start entry
                if (!startEntry) return;

                const { epicId, storyId, command, taskId } = startEntry;

                // Handle orphans (start without end)
                if (!endEntry) {
                    const age = currentTime - startEntry.timestamp;
                    const ageMinutes = Math.floor(age / 60);
                    if (age >= THIRTY_MINUTES) {
                        // Stale: ignore this command but continue processing story
                        console.log(`Orphan filtered (stale): ${storyId}/${command} - age ${ageMinutes}m`);
                        return;
                    }
                    console.log(`Orphan kept (fresh): ${storyId}/${command} - age ${ageMinutes}m`);
                    // Fresh: will be shown as in-progress
                }

                // Initialize story if needed
                if (!storyMap.has(storyId)) {
                    storyMap.set(storyId, {
                        storyId,
                        epic: epicId,
                        started: null,
                        completed: null,
                        duration: '',
                        totalDurationSecs: 0,
                        startTs: null,
                        endTs: null,
                        commands: new Map(), // command -> { tasks: [], totalDurationSecs, ... }
                        steps: [] // For timeline compatibility
                    });
                }

                const story = storyMap.get(storyId);

                // Track story timing
                if (!story.startTs || startEntry.timestamp < story.startTs) {
                    story.startTs = startEntry.timestamp;
                    story.started = formatTimestamp(startEntry.timestamp);
                }
                if (endEntry) {
                    if (!story.endTs || endEntry.timestamp > story.endTs) {
                        story.endTs = endEntry.timestamp;
                    }
                }

                // Initialize command group if needed
                if (!story.commands.has(command)) {
                    story.commands.set(command, {
                        command,
                        tasks: [],
                        totalDurationSecs: 0,
                        totalDuration: '',
                        startTs: startEntry.timestamp,
                        endTs: null
                    });
                }

                const cmdGroup = story.commands.get(command);

                // Calculate task duration and status
                let taskDurationSecs = 0;
                let taskStatus = 'in-progress';
                let taskEndTs = null;
                const MAX_IN_PROGRESS_SECS = 30 * 60; // 30 minutes cap

                if (endEntry) {
                    taskDurationSecs = endEntry.timestamp - startEntry.timestamp;
                    taskStatus = 'completed';
                    taskEndTs = endEntry.timestamp;

                    // Update command group end timestamp
                    if (!cmdGroup.endTs || endEntry.timestamp > cmdGroup.endTs) {
                        cmdGroup.endTs = endEntry.timestamp;
                    }
                } else {
                    // In-progress: use current time, capped at 30 minutes
                    const elapsedSecs = currentTime - startEntry.timestamp;
                    taskDurationSecs = Math.min(elapsedSecs, MAX_IN_PROGRESS_SECS);
                    taskEndTs = startEntry.timestamp + taskDurationSecs;

                    // Update command group end timestamp for in-progress
                    if (!cmdGroup.endTs || taskEndTs > cmdGroup.endTs) {
                        cmdGroup.endTs = taskEndTs;
                    }

                    // Also update story end timestamp for in-progress commands
                    // This ensures story bar extends to cover all commands including in-progress ones
                    if (!story.endTs || taskEndTs > story.endTs) {
                        story.endTs = taskEndTs;
                    }
                }

                // Add task to command group (include messages)
                const startMessage = pair.startMessage || '';
                const endMessage = pair.endMessage || '';
                cmdGroup.tasks.push({
                    taskId,
                    startTs: startEntry.timestamp,
                    endTs: taskEndTs,
                    durationSecs: taskDurationSecs,
                    duration: taskDurationSecs > 0 ? formatDuration(taskDurationSecs) : '',
                    status: taskStatus,
                    startMessage,
                    endMessage,
                    // Display message: end message if completed, start message if in-progress
                    message: taskStatus === 'completed' ? endMessage : startMessage
                });

                cmdGroup.totalDurationSecs += taskDurationSecs;
            });

            // Third pass: finalize story data
            const resultArr = Array.from(storyMap.values()).map(story => {
                // Convert commands Map to array and calculate totals
                const commandsArray = [];
                let storyTotalDuration = 0;
                let allTasksCompleted = true;
                let stepNumber = 0;

                story.commands.forEach((cmdGroup, cmdName) => {
                    stepNumber++;

                    // Sort tasks by start time
                    cmdGroup.tasks.sort((a, b) => a.startTs - b.startTs);

                    cmdGroup.totalDuration = formatDuration(cmdGroup.totalDurationSecs);
                    storyTotalDuration += cmdGroup.totalDurationSecs;

                    // Check if any task is in-progress
                    const hasInProgress = cmdGroup.tasks.some(t => t.status === 'in-progress');
                    if (hasInProgress) {
                        allTasksCompleted = false;
                    }

                    commandsArray.push({
                        command: cmdName,
                        tasks: cmdGroup.tasks,
                        totalDurationSecs: cmdGroup.totalDurationSecs,
                        totalDuration: cmdGroup.totalDuration,
                        startTs: cmdGroup.startTs,
                        endTs: cmdGroup.endTs
                    });

                    // Add to steps array for timeline compatibility
                    story.steps.push({
                        stepNumber,
                        stepName: cmdGroup.tasks[0]?.taskId || '',
                        command: cmdName,
                        result: hasInProgress ? 'in-progress' : 'completed',
                        duration: cmdGroup.totalDuration,
                        durationSecs: cmdGroup.totalDurationSecs,
                        startTs: cmdGroup.startTs,
                        endTs: cmdGroup.endTs,
                        tasks: cmdGroup.tasks // Include tasks for timeline task-level bars
                    });
                });

                // Sort commands by start time
                commandsArray.sort((a, b) => a.startTs - b.startTs);
                story.steps.sort((a, b) => a.startTs - b.startTs);

                story.commands = commandsArray;

                // Calculate total duration as last end - first start (wall clock time)
                const MAX_IN_PROGRESS_SECS = 30 * 60; // 30 minutes cap
                if (story.startTs && story.endTs) {
                    story.totalDurationSecs = story.endTs - story.startTs;
                    story.duration = formatDuration(story.totalDurationSecs);
                } else if (story.startTs) {
                    // Still in progress - show time since start, capped at 30 min for timeline
                    const now = Math.floor(Date.now() / 1000);
                    const elapsedSecs = now - story.startTs;
                    story.totalDurationSecs = elapsedSecs; // Display shows actual elapsed
                    story.duration = formatDuration(story.totalDurationSecs);
                    // Set endTs for timeline bar rendering, capped at 30 min
                    story.endTs = story.startTs + Math.min(elapsedSecs, MAX_IN_PROGRESS_SECS);
                } else {
                    story.totalDurationSecs = 0;
                    story.duration = '';
                }

                // Set completed timestamp if all tasks are done
                if (allTasksCompleted && story.endTs) {
                    story.completed = formatTimestamp(story.endTs);
                }

                return story;
            });

            // Sort by start time (most recent first)
            resultArr.sort((a, b) => (b.startTs || 0) - (a.startTs || 0));

            return resultArr;
        }

        // CSV parser wrapper
        function parseOrchestrator(text) {
            if (!text || !text.trim()) {
                return [];
            }
            console.log('Parsing sprint-runner.csv, lines:', text.trim().split('\n').length);
            const result = parseOrchestratorCSV(text);
            console.log('Parsed stories:', result.map(s => `${s.storyId} (${s.commands?.length || 0} cmds, ${s.completed ? 'done' : 'in-progress'})`));
            return result;
        }

        // ============================================================
        // YAML Parser
        // ============================================================

        function parseSprintStatus(text) {
            const data = {
                metadata: {},
                epics: {},
                stories: []
            };

            const lines = text.split('\n');
            let currentEpic = null;

            for (let line of lines) {
                if (line.trim().startsWith('#') || !line.trim()) continue;

                if (line.match(/^(\w+):\s*(.+)$/)) {
                    const [, key, value] = line.match(/^(\w+):\s*(.+)$/);
                    if (!line.startsWith(' ')) {
                        data.metadata[key] = value;
                    }
                }

                if (line.match(/epic-(\w+):\s*([\w-]+)/)) {
                    const [, epicId, status] = line.match(/epic-(\w+):\s*([\w-]+)/);
                    const epicKey = `epic-${epicId}`;
                    currentEpic = epicKey;

                    if (!data.epics[epicKey]) {
                        data.epics[epicKey] = {
                            id: epicKey,
                            name: `Epic ${epicId.toUpperCase()}`,
                            status: status,
                            stories: []
                        };
                    } else {
                        data.epics[epicKey].status = status;
                    }
                }

                if (line.match(/^\s+([a-z0-9-]+):\s*([\w-]+)/) && currentEpic) {
                    const [, storyId, status] = line.match(/^\s+([a-z0-9-]+):\s*([\w-]+)/);

                    if (storyId.includes('retrospective') || storyId.startsWith('epic-')) continue;

                    const story = {
                        id: storyId,
                        name: storyId.split('-').slice(2).join(' ').replace(/-/g, ' '),
                        epic: currentEpic,
                        status: status
                    };

                    data.stories.push(story);
                    if (data.epics[currentEpic]) {
                        data.epics[currentEpic].stories.push(story);
                    }
                }
            }

            return data;
        }

        // ============================================================
        // Story Descriptions
        // ============================================================

        function showStoryTooltip(event, storyId) {
            const tooltip = document.getElementById('storyTooltip');
            const description = storyDescriptions[storyId] || 'No description available';
            tooltip.textContent = description;
            tooltip.style.left = (event.clientX + 10) + 'px';
            tooltip.style.top = (event.clientY + 10) + 'px';
            tooltip.classList.add('visible');
        }

        function hideStoryTooltip() {
            const tooltip = document.getElementById('storyTooltip');
            tooltip.classList.remove('visible');
        }

        async function loadStoryDescriptions() {
            try {
                const response = await fetch('./story-descriptions.json');
                if (response.ok) {
                    storyDescriptions = await response.json();
                    console.log('Loaded story descriptions:', Object.keys(storyDescriptions).length);
                }
            } catch (e) {
                console.log('Story descriptions not available:', e);
            }
        }

        // ============================================================
        // Render Functions
        // ============================================================

        function renderSummaryCards(data) {
            const epics = Object.values(data.epics);
            const totalEpics = epics.filter(e => !e.id.includes('retrospective')).length;
            const epicsInProgress = epics.filter(e => {
                const status = (e.status || '').toLowerCase().trim();
                return status === 'in-progress' || status === 'in_progress' || status === 'inprogress';
            }).length;

            const stories = data.stories.filter(s => !s.id.includes('retrospective'));
            const storiesDone = stories.filter(s => s.status === 'done').length;
            const storiesTotal = stories.length;
            const completionPercent = storiesTotal > 0 ? Math.round((storiesDone / storiesTotal) * 100) : 0;

            const currentStory = stories.find(s => s.status !== 'done' && s.status !== 'backlog');

            document.getElementById('totalEpics').textContent = totalEpics;
            document.getElementById('epicsInProgress').textContent = epicsInProgress;
            document.getElementById('storiesProgress').textContent = `${storiesDone}/${storiesTotal}`;
            document.getElementById('storiesPercent').textContent = `${completionPercent}%`;

            if (currentStory) {
                document.getElementById('currentStory').textContent = currentStory.id;
                const statusClass = normalizeStatusForClass(currentStory.status);
                const safeStatus = escapeHtml(currentStory.status);
                document.getElementById('currentStoryStatus').innerHTML = `<span class="badge badge-${statusClass}">${safeStatus}</span>`;
            } else if (storiesDone === storiesTotal && storiesTotal > 0) {
                document.getElementById('currentStory').textContent = 'All complete!';
                document.getElementById('currentStoryStatus').textContent = '';
            } else {
                document.getElementById('currentStory').textContent = '-';
                document.getElementById('currentStoryStatus').textContent = '';
            }
        }

        function renderEpicBoard(data) {
            const backlogEl = document.getElementById('epicsBacklog');
            const inProgressEl = document.getElementById('epicsInProgressCol');
            const doneEl = document.getElementById('epicsDone');

            // Capture currently expanded epic IDs before update (Story 5-SR-7)
            const previouslyExpanded = new Set(
                Array.from(document.querySelectorAll('.epic-card.expanded'))
                    .map(el => el.dataset.epicId)
            );

            // Build map of existing cards for incremental update
            const existingCards = new Map();
            document.querySelectorAll('.epic-card').forEach(card => {
                existingCards.set(card.dataset.epicId, card);
            });

            // Clear columns (we'll re-add cards)
            backlogEl.innerHTML = '';
            inProgressEl.innerHTML = '';
            doneEl.innerHTML = '';

            const epics = Object.values(data.epics).filter(e => !e.id.includes('retrospective'));

            epics.forEach(epic => {
                const epicStories = epic.stories.filter(s => !s.id.includes('retrospective'));
                const doneStories = epicStories.filter(s => s.status === 'done').length;
                const totalStories = epicStories.length;
                const progress = totalStories > 0 ? (doneStories / totalStories) * 100 : 0;

                let totalDurationSecs = 0;
                epicStories.forEach(story => {
                    const activity = state.orchestratorData?.find(a => a.storyId === story.id);
                    if (activity?.totalDurationSecs) {
                        totalDurationSecs += activity.totalDurationSecs;
                    }
                });
                const totalDuration = totalDurationSecs > 0 ? formatDuration(totalDurationSecs) : '';

                const safeEpicName = escapeHtml(epic.name);
                const safeTotalDuration = escapeHtml(totalDuration);

                // Check if card already exists
                let card = existingCards.get(epic.id);
                const wasExpanded = previouslyExpanded.has(epic.id);

                if (card) {
                    // Update existing card in-place (incremental update)
                    const progressEl = card.querySelector('.epic-card-progress');
                    if (progressEl) progressEl.textContent = `${doneStories}/${totalStories} stories`;

                    const durationEl = card.querySelector('.epic-card-duration');
                    if (safeTotalDuration) {
                        if (durationEl) {
                            durationEl.textContent = safeTotalDuration;
                        } else {
                            const metaEl = card.querySelector('.epic-card-meta');
                            if (metaEl) {
                                const newDuration = document.createElement('span');
                                newDuration.className = 'epic-card-duration';
                                newDuration.textContent = safeTotalDuration;
                                metaEl.appendChild(newDuration);
                            }
                        }
                    } else if (durationEl) {
                        durationEl.remove();
                    }

                    const progressFill = card.querySelector('.epic-card-progress-fill');
                    if (progressFill) progressFill.style.width = `${progress}%`;

                    existingCards.delete(epic.id);
                } else {
                    // Create new card
                    card = document.createElement('div');
                    card.className = 'epic-card';
                    card.dataset.epicId = epic.id;

                    card.innerHTML = `
                        <div class="epic-card-header">
                            <div class="epic-card-title">${safeEpicName}</div>
                            <span class="epic-expand-icon">&#9654;</span>
                        </div>
                        <div class="epic-card-meta">
                            <span class="epic-card-progress">${doneStories}/${totalStories} stories</span>
                            ${safeTotalDuration ? `<span class="epic-card-duration">${safeTotalDuration}</span>` : ''}
                        </div>
                        <div class="epic-card-progress-bar">
                            <div class="epic-card-progress-fill" style="width: ${progress}%"></div>
                        </div>
                        <div class="epic-stories-list" style="display: none;"></div>
                    `;
                }

                // Auto-detect epic status based on story completion
                // (overrides YAML status for accuracy)
                let effectiveStatus;
                if (totalStories > 0 && doneStories === totalStories) {
                    // All stories done = epic is done
                    effectiveStatus = 'done';
                } else if (doneStories > 0 || epicStories.some(s => s.status !== 'backlog')) {
                    // At least one story started or done = epic in progress
                    effectiveStatus = 'in-progress';
                } else {
                    // All stories in backlog = epic in backlog
                    effectiveStatus = 'backlog';
                }

                if (effectiveStatus === 'done') {
                    doneEl.appendChild(card);
                } else if (effectiveStatus === 'in-progress') {
                    inProgressEl.appendChild(card);
                } else {
                    backlogEl.appendChild(card);
                }

                // Restore expanded state (Story 5-SR-7)
                if (wasExpanded && !card.classList.contains('expanded')) {
                    // Re-expand with fresh data
                    card.classList.add('expanded');
                    const storiesList = card.querySelector('.epic-stories-list');
                    if (storiesList && epicStories.length > 0) {
                        storiesList.innerHTML = epicStories.map(story => {
                            const safeId = escapeHtml(story.id);
                            const safeIdJs = escapeJsString(story.id);
                            const statusClass = normalizeStatusForClass(story.status);
                            const safeStatus = escapeHtml(story.status);
                            return `
                                <div class="epic-story-item"
                                     data-story-id="${safeId}"
                                     onmouseenter="showStoryTooltip(event, '${safeIdJs}')"
                                     onmouseleave="hideStoryTooltip()">
                                    <span class="story-name">${safeId}</span>
                                    <span class="badge badge-${statusClass}">${safeStatus}</span>
                                </div>
                            `;
                        }).join('');
                        storiesList.style.display = 'block';
                    }
                }
            });

            // Remove cards that no longer exist in data
            existingCards.forEach(card => card.remove());

            if (!backlogEl.children.length) {
                backlogEl.innerHTML = '<div class="empty-state">No epics</div>';
            }
            if (!inProgressEl.children.length) {
                inProgressEl.innerHTML = '<div class="empty-state">No epics</div>';
            }
            if (!doneEl.children.length) {
                doneEl.innerHTML = '<div class="empty-state">No epics</div>';
            }

            attachEpicCardHandlers();

            // Save UI state after render (Story 5-SR-7)
            saveUIState();
        }

        function toggleEpicCard(epicId) {
            const sanitizedId = CSS.escape(epicId);
            const card = document.querySelector(`.epic-card[data-epic-id="${sanitizedId}"]`);
            if (!card) return;

            const isExpanded = card.classList.toggle('expanded');
            const storiesList = card.querySelector('.epic-stories-list');

            if (isExpanded && state.sprintData) {
                const epic = state.sprintData.epics[epicId];
                if (epic && epic.stories.length > 0) {
                    const stories = epic.stories.filter(s => !s.id.includes('retrospective'));
                    storiesList.innerHTML = stories.map(story => {
                        const safeId = escapeHtml(story.id);
                        const safeIdJs = escapeJsString(story.id);
                        const statusClass = normalizeStatusForClass(story.status);
                        const safeStatus = escapeHtml(story.status);
                        return `
                            <div class="epic-story-item"
                                 data-story-id="${safeId}"
                                 onmouseenter="showStoryTooltip(event, '${safeIdJs}')"
                                 onmouseleave="hideStoryTooltip()">
                                <span class="story-name">${safeId}</span>
                                <span class="badge badge-${statusClass}">${safeStatus}</span>
                            </div>
                        `;
                    }).join('');
                    storiesList.style.display = 'block';
                }
            } else {
                storiesList.style.display = 'none';
            }

            // Save UI state when epic expansion changes (Story 5-SR-7)
            saveUIState();
        }

        function attachEpicCardHandlers() {
            document.querySelectorAll('.epic-card').forEach(card => {
                card.addEventListener('click', (e) => {
                    if (!e.target.closest('.epic-story-item')) {
                        toggleEpicCard(card.dataset.epicId);
                    }
                });
            });
        }

        function renderStoryTable(data, epicFilter = 'all', statusFilter = 'all') {
            const tbody = document.getElementById('storyTableBody');
            const tableContainer = tbody.closest('.table-container');
            const stories = data.stories.filter(s => !s.id.includes('retrospective'));

            // Save scroll position before update (Story 5-SR-7)
            const scrollPos = saveScrollPosition(tableContainer);

            let filtered = stories;
            if (epicFilter !== 'all') {
                filtered = filtered.filter(s => s.epic === epicFilter);
            }
            if (statusFilter !== 'all') {
                filtered = filtered.filter(s => s.status === statusFilter);
            }

            if (filtered.length === 0) {
                tbody.innerHTML = '<tr><td colspan="5" class="empty-state">No stories found</td></tr>';
                return;
            }

            // Build map of existing rows for incremental update (Story 5-SR-7)
            const existingRows = new Map();
            tbody.querySelectorAll('.story-row').forEach(row => {
                existingRows.set(row.dataset.storyId, row);
            });

            const newRowIds = new Set(filtered.map(s => s.id));

            filtered.forEach((story, index) => {
                const activity = state.orchestratorData?.find(a => a.storyId === story.id);
                const duration = activity?.duration || '-';
                const safeId = escapeHtml(story.id);
                const safeIdJs = escapeJsString(story.id);
                const safeName = escapeHtml(story.name || story.id);
                const safeEpic = escapeHtml(story.epic);
                const safeDuration = escapeHtml(duration);
                const statusClass = normalizeStatusForClass(story.status);
                const safeStatus = escapeHtml(story.status);

                let row = existingRows.get(story.id);

                if (row) {
                    // Update existing row in-place
                    const cells = row.querySelectorAll('td');
                    if (cells[0]) updateTextContent(cells[0], safeId);
                    if (cells[1]) updateTextContent(cells[1], safeName);
                    if (cells[2]) updateTextContent(cells[2], safeEpic);
                    if (cells[3]) updateTextContent(cells[3], safeDuration);
                    if (cells[4]) {
                        const badge = cells[4].querySelector('.badge');
                        if (badge) {
                            badge.className = `badge badge-${statusClass}`;
                            updateTextContent(badge, safeStatus);
                        }
                    }
                    existingRows.delete(story.id);

                    // Ensure row is in correct position
                    if (tbody.children[index] !== row) {
                        tbody.insertBefore(row, tbody.children[index] || null);
                    }
                } else {
                    // Create new row
                    row = document.createElement('tr');
                    row.className = 'story-row';
                    row.dataset.storyId = safeId;
                    row.setAttribute('onmouseenter', `showStoryTooltip(event, '${safeIdJs}')`);
                    row.setAttribute('onmouseleave', 'hideStoryTooltip()');
                    row.innerHTML = `
                        <td class="story-id">${safeId}</td>
                        <td>${safeName}</td>
                        <td>${safeEpic}</td>
                        <td class="story-duration">${safeDuration}</td>
                        <td><span class="badge badge-${statusClass}">${safeStatus}</span></td>
                    `;
                    // Insert at correct position
                    tbody.insertBefore(row, tbody.children[index] || null);
                }
            });

            // Remove rows that no longer exist
            existingRows.forEach(row => row.remove());

            // Restore scroll position after update (Story 5-SR-7)
            restoreScrollPosition(tableContainer, scrollPos);
        }

        function updateEpicFilter(data) {
            const select = document.getElementById('epicFilter');
            const currentValue = select.value;
            const epics = Object.values(data.epics).filter(e => !e.id.includes('retrospective'));

            select.innerHTML = '<option value="all">All Epics</option>';
            epics.forEach(epic => {
                const option = document.createElement('option');
                option.value = epic.id;
                option.textContent = epic.name;
                select.appendChild(option);
            });

            if (currentValue && Array.from(select.options).some(opt => opt.value === currentValue)) {
                select.value = currentValue;
            }
        }

        function renderActivityLog(activities) {
            const logEl = document.getElementById('activityLog');
            console.log('renderActivityLog called with', activities?.length, 'activities');
            console.log('Activity IDs:', activities?.map(a => `${a.storyId}:${a.completed ? 'done' : 'in-progress'}`));

            if (!activities || activities.length === 0) {
                logEl.innerHTML = '<div class="empty-state">No activity yet</div>';
                return;
            }

            // Capture current expanded/collapsed state before update (Story 5-SR-7)
            const expandedIndices = new Set();
            const collapsedCommands = new Map(); // Map<activityIndex, Set<cmdIndex>>
            logEl.querySelectorAll('.activity-item').forEach(item => {
                const idx = parseInt(item.dataset.index, 10);
                if (!item.classList.contains('collapsed')) {
                    expandedIndices.add(idx);
                }
                // Track collapsed commands within this activity
                const collapsedCmds = new Set();
                item.querySelectorAll('.command-group.collapsed').forEach(cmd => {
                    const cmdIdx = parseInt(cmd.dataset.cmdIndex, 10);
                    collapsedCmds.add(cmdIdx);
                });
                if (collapsedCmds.size > 0) {
                    collapsedCommands.set(idx, collapsedCmds);
                }
            });

            // Save scroll position
            const scrollPos = saveScrollPosition(logEl);

            const toRender = activities.slice(0, 10);
            console.log('Rendering', toRender.length, 'activities:', toRender.map(a => a.storyId));

            logEl.innerHTML = toRender.map((activity, index) => {
                const isCompleted = activity.completed && activity.completed !== '';
                const statusClass = isCompleted ? 'completed' : 'in-progress';
                const isCollapsed = index > 0;
                const badgeText = isCompleted ? 'Done' : 'In Progress';

                const description = escapeHtml(storyDescriptions[activity.storyId] || '');
                const safeStoryId = escapeHtml(activity.storyId);
                const safeEpic = escapeHtml(activity.epic);
                const safeStarted = escapeHtml(activity.started || '');
                const safeDuration = escapeHtml(activity.duration || '');

                // Build hierarchical command/task structure
                // Hide task-id level if command has only one task (no granularity to show)
                const commandsHtml = (activity.commands || []).map((cmd, cmdIndex) => {
                    const safeCmdName = escapeHtml(cmd.command);
                    const safeCmdDuration = escapeHtml(cmd.totalDuration || '');
                    const hasInProgressTasks = cmd.tasks && cmd.tasks.some(t => t.status === 'in-progress');
                    const hasSingleTask = !cmd.tasks || cmd.tasks.length <= 1;
                    const cmdStatusIcon = hasInProgressTasks ? '\u23f3' : '\u2713';
                    const cmdStatusClass = hasInProgressTasks ? 'in-progress' : 'completed';

                    // Only show task list if there are multiple tasks
                    let tasksHtml = '';
                    if (!hasSingleTask) {
                        tasksHtml = cmd.tasks.map(task => {
                            const safeTaskId = escapeHtml(task.taskId);
                            const safeTaskDuration = escapeHtml(task.duration || '');
                            const safeTaskMessage = escapeHtml(task.message || '');
                            const isTaskInProgress = task.status === 'in-progress';
                            const statusIcon = isTaskInProgress ? '\u23f3' : '\u2713';
                            const statusClass = isTaskInProgress ? 'in-progress' : 'completed';

                            return `
                                <div class="task-item${isTaskInProgress ? ' task-in-progress' : ''}">
                                    <div class="task-item-left">
                                        <span class="task-prefix">\u2514\u2500</span>
                                        <span class="task-name">${safeTaskId}</span>
                                    </div>
                                    <div class="task-item-right">
                                        <span class="task-duration">${safeTaskDuration || (isTaskInProgress ? 'running...' : '-')}</span>
                                        <span class="task-status ${statusClass}">${statusIcon}</span>
                                    </div>
                                </div>
                                ${safeTaskMessage ? `<div class="task-message">${safeTaskMessage}</div>` : ''}
                            `;
                        }).join('');
                    }

                    // If single task, show simpler command row without expand toggle
                    if (hasSingleTask) {
                        return `
                            <div class="command-group single-task" data-cmd-index="${cmdIndex}">
                                <div class="command-header-simple">
                                    <span class="command-name">${safeCmdName}</span>
                                    ${hasInProgressTasks ? '<span class="activity-badge" style="margin-left: 8px;">Running</span>' : ''}
                                    <span class="command-duration">${safeCmdDuration || '-'}</span>
                                    <span class="task-status ${cmdStatusClass}">${cmdStatusIcon}</span>
                                </div>
                            </div>
                        `;
                    }

                    return `
                        <div class="command-group" data-cmd-index="${cmdIndex}">
                            <div class="command-header" onclick="toggleCommand(${index}, ${cmdIndex})">
                                <div class="command-header-left">
                                    <span class="command-toggle">
                                        <svg width="12" height="12" viewBox="0 0 12 12" fill="currentColor">
                                            <path d="M4 2l4 4-4 4z"/>
                                        </svg>
                                    </span>
                                    <span class="command-name">${safeCmdName}</span>
                                    ${hasInProgressTasks ? '<span class="activity-badge" style="margin-left: 8px;">Running</span>' : ''}
                                </div>
                                <span class="command-duration">${safeCmdDuration || '-'}</span>
                            </div>
                            <div class="command-tasks">
                                ${tasksHtml}
                            </div>
                        </div>
                    `;
                }).join('');

                return `
                    <div class="activity-item ${statusClass}${isCollapsed ? ' collapsed' : ''}" data-index="${index}">
                        <div class="activity-header" onclick="toggleActivity(${index})">
                            <div class="activity-title-row">
                                <span class="activity-toggle">
                                    <svg width="12" height="12" viewBox="0 0 12 12" fill="currentColor">
                                        <path d="M4 2l4 4-4 4z"/>
                                    </svg>
                                </span>
                                <span class="activity-story">${safeStoryId}</span>
                                <span class="activity-badge">${badgeText}</span>
                            </div>
                            <div class="activity-meta-right">
                                ${safeDuration ? `<span class="activity-duration">${safeDuration}</span>` : ''}
                                <span class="activity-date">${safeStarted}</span>
                            </div>
                        </div>
                        <div class="activity-body">
                            <div class="activity-meta">
                                Epic: ${safeEpic}
                            </div>
                            ${description ? `<div class="activity-description">${description}</div>` : ''}
                            <div class="activity-commands">
                                ${commandsHtml || '<div class="empty-state">No commands recorded</div>'}
                            </div>
                        </div>
                    </div>
                `;
            }).join('');

            // Restore expanded/collapsed state (Story 5-SR-7)
            logEl.querySelectorAll('.activity-item').forEach(item => {
                const idx = parseInt(item.dataset.index, 10);
                // First item defaults to expanded, others to collapsed
                // But if we captured a state, honor it
                if (expandedIndices.size > 0) {
                    // Use captured state
                    if (expandedIndices.has(idx)) {
                        item.classList.remove('collapsed');
                    } else if (idx > 0) {
                        item.classList.add('collapsed');
                    }
                }
                // Restore collapsed commands
                const collapsedCmds = collapsedCommands.get(idx);
                if (collapsedCmds) {
                    item.querySelectorAll('.command-group').forEach(cmd => {
                        const cmdIdx = parseInt(cmd.dataset.cmdIndex, 10);
                        if (collapsedCmds.has(cmdIdx)) {
                            cmd.classList.add('collapsed');
                        }
                    });
                }
            });

            // Restore scroll position (Story 5-SR-7)
            restoreScrollPosition(logEl, scrollPos);

            // Save UI state (Story 5-SR-7)
            saveUIState();
        }

        function toggleActivity(index) {
            const item = document.querySelector(`.activity-item[data-index="${index}"]`);
            if (item) {
                item.classList.toggle('collapsed');
                // Save UI state when activity expansion changes (Story 5-SR-7)
                saveUIState();
            }
        }

        function toggleCommand(activityIndex, cmdIndex) {
            const item = document.querySelector(`.activity-item[data-index="${activityIndex}"]`);
            if (item) {
                const cmdGroup = item.querySelectorAll('.command-group')[cmdIndex];
                if (cmdGroup) {
                    cmdGroup.classList.toggle('collapsed');
                }
            }
            event.stopPropagation();
        }

        // ============================================================
        // TIMELINE VIEW - REDESIGNED IMPLEMENTATION
        // ============================================================

        // Initialize column resize functionality
        function initColumnResize() {
            const handle = document.getElementById('resizeHandle');
            if (!handle) return;

            handle.addEventListener('mousedown', startResize);
            document.addEventListener('mousemove', doResize);
            document.addEventListener('mouseup', stopResize);
        }

        // Initialize cursor line for timeline alignment visualization
        function initTimelineCursorLine() {
            const container = document.getElementById('timelineScrollContainer');
            const cursorLine = document.getElementById('timelineCursorLine');
            if (!container || !cursorLine) return;

            container.addEventListener('mousemove', (e) => {
                const rect = container.getBoundingClientRect();
                const x = e.clientX - rect.left + container.scrollLeft;
                cursorLine.style.left = x + 'px';
                cursorLine.style.display = 'block';
            });

            container.addEventListener('mouseleave', () => {
                cursorLine.style.display = 'none';
            });
        }

        function startResize(e) {
            resizeState.isResizing = true;
            resizeState.startX = e.clientX;
            resizeState.startWidth = timelineState.labelColumnWidth;
            document.getElementById('resizeHandle').classList.add('active');
            document.body.style.cursor = 'col-resize';
            document.body.style.userSelect = 'none';
            e.preventDefault();
        }

        function doResize(e) {
            if (!resizeState.isResizing) return;

            const diff = e.clientX - resizeState.startX;
            const newWidth = Math.min(
                Math.max(resizeState.startWidth + diff, timelineState.minLabelWidth),
                timelineState.maxLabelWidth
            );

            timelineState.labelColumnWidth = newWidth;
            document.documentElement.style.setProperty('--timeline-label-width', newWidth + 'px');
        }

        function stopResize() {
            if (!resizeState.isResizing) return;

            resizeState.isResizing = false;
            document.getElementById('resizeHandle')?.classList.remove('active');
            document.body.style.cursor = '';
            document.body.style.userSelect = '';

            // Persist to localStorage
            localStorage.setItem('timeline-label-width', timelineState.labelColumnWidth);
        }

        // Restore column width from localStorage
        function restoreColumnWidth() {
            const saved = localStorage.getItem('timeline-label-width');
            if (saved) {
                const width = parseInt(saved, 10);
                if (!isNaN(width) && width >= timelineState.minLabelWidth && width <= timelineState.maxLabelWidth) {
                    timelineState.labelColumnWidth = width;
                    document.documentElement.style.setProperty('--timeline-label-width', width + 'px');
                }
            }
        }

        // Set block size in minutes
        function setBlockSizeMinutes(minutes) {
            const parsed = parseInt(minutes, 10);
            if (isNaN(parsed) || parsed < 1 || parsed > 480) {
                document.getElementById('blockSizeInput').value = timelineState.blockSizeMinutes;
                return;
            }

            timelineState.blockSizeMinutes = parsed;
            renderTimeline();
        }

        /**
         * Convert timestamp to X position using compacted block layout.
         * Uses timestampToXCompact when compacted blocks are available.
         */
        function timestampToX(timestamp) {
            // Use compact positioning if available
            if (timelineState.compactedBlocks && timelineState.compactedBlocks.length > 0) {
                return timestampToXCompact(timestamp);
            }

            // Fallback to linear positioning
            const { timelineStartTs, blockSizeMinutes, zoomLevel } = timelineState;
            if (!timelineStartTs || !blockSizeMinutes) return 0;

            const blockWidthPx = COLUMN_WIDTH_PX * (zoomLevel / 100);
            const timeOffset = timestamp - timelineStartTs;
            const timeOffsetMinutes = timeOffset / 60;
            return (timeOffsetMinutes / blockSizeMinutes) * blockWidthPx;
        }

        /**
         * Generate time blocks based on timeline bounds.
         * These blocks are then passed to compactEmptyBlocks() which merges
         * consecutive empty blocks and calculates final positions.
         */
        function generateTimeBlocks() {
            const { timelineStartTs, timelineEndTs, blockSizeMinutes, zoomLevel } = timelineState;

            if (!timelineStartTs || !timelineEndTs) return [];

            // Fixed column width scaled by zoom
            const blockWidthPx = COLUMN_WIDTH_PX * (zoomLevel / 100);
            const totalSeconds = timelineEndTs - timelineStartTs;
            const totalMinutes = totalSeconds / 60;
            const blockCount = Math.ceil(totalMinutes / blockSizeMinutes);

            // Initial width estimate (will be recalculated after compaction)
            timelineState.totalTimelineWidth = blockCount * blockWidthPx;

            const blocks = [];
            for (let i = 0; i < blockCount; i++) {
                const blockStartTs = timelineStartTs + (i * blockSizeMinutes * 60);
                const minutesFromStart = i * blockSizeMinutes;

                // Format label based on total minutes (smart format)
                let label;
                if (minutesFromStart >= 60) {
                    const hours = Math.floor(minutesFromStart / 60);
                    const mins = minutesFromStart % 60;
                    label = mins > 0 ? `${hours}h ${mins}m` : `${hours}h`;
                } else {
                    label = `${minutesFromStart}m`;
                }

                blocks.push({
                    timestamp: blockStartTs,
                    label: label,
                    widthPx: blockWidthPx,
                    xPosition: i * blockWidthPx  // Pre-calculate X position for grid line
                });
            }

            return blocks;
        }

        /**
         * Detect empty blocks and compact consecutive empty blocks into single gap indicators.
         * Returns compacted blocks with position mapping for bar rendering.
         */
        function compactEmptyBlocks(blocks, activities, blockSizeMinutes, blockWidthPx) {
            const COMPACT_WIDTH = 20;
            const blockSizeSeconds = blockSizeMinutes * 60;

            // First, mark which blocks are empty
            const markedBlocks = blocks.map((block) => {
                const blockStart = block.timestamp;
                const blockEnd = blockStart + blockSizeSeconds;

                const hasContent = activities.some(activity => {
                    const storyOverlaps = (
                        activity.startTs < blockEnd &&
                        (activity.endTs || activity.startTs + 3600) > blockStart
                    );
                    if (storyOverlaps) return true;

                    return (activity.steps || []).some(step => {
                        const stepEnd = step.endTs || step.startTs + 60;
                        return step.startTs < blockEnd && stepEnd > blockStart;
                    });
                });

                return { ...block, isEmpty: !hasContent };
            });

            // Merge consecutive empty blocks into single compact gaps
            // Labels restart at 0 after each gap
            const compactedBlocks = [];
            let currentGap = null;
            let xPosition = 0;
            let minutesSinceGap = 0; // Reset after each gap

            // Helper to format time label
            function formatLabel(minutes) {
                if (minutes >= 60) {
                    const hours = Math.floor(minutes / 60);
                    const mins = minutes % 60;
                    return mins > 0 ? `${hours}h ${mins}m` : `${hours}h`;
                }
                return `${minutes}m`;
            }

            markedBlocks.forEach((block) => {
                if (block.isEmpty) {
                    if (!currentGap) {
                        // Start new gap
                        currentGap = {
                            isCompact: true,
                            isEmpty: true,
                            label: '',
                            gapStartTs: block.timestamp,
                            gapEndTs: block.timestamp + blockSizeSeconds,
                            widthPx: COMPACT_WIDTH
                        };
                    } else {
                        // Extend existing gap
                        currentGap.gapEndTs = block.timestamp + blockSizeSeconds;
                    }
                } else {
                    // Flush pending gap and reset minute counter
                    if (currentGap) {
                        currentGap.xPosition = xPosition;
                        compactedBlocks.push(currentGap);
                        xPosition += COMPACT_WIDTH;
                        currentGap = null;
                        minutesSinceGap = 0; // Reset after gap
                    }
                    // Add non-empty block with label showing block END time
                    minutesSinceGap += blockSizeMinutes;
                    compactedBlocks.push({
                        ...block,
                        label: formatLabel(minutesSinceGap),
                        isCompact: false,
                        xPosition: xPosition,
                        widthPx: blockWidthPx
                    });
                    xPosition += blockWidthPx;
                }
            });

            // Flush final gap
            if (currentGap) {
                currentGap.xPosition = xPosition;
                compactedBlocks.push(currentGap);
                xPosition += COMPACT_WIDTH;
            }

            // Store total width and position mapping
            timelineState.totalTimelineWidth = xPosition;
            timelineState.compactedBlocks = compactedBlocks;

            return compactedBlocks;
        }

        /**
         * Convert timestamp to X position accounting for compacted gaps.
         */
        function timestampToXCompact(timestamp) {
            const blocks = timelineState.compactedBlocks;
            if (!blocks || blocks.length === 0) return 0;

            const blockSizeSeconds = timelineState.blockSizeMinutes * 60;

            for (let i = 0; i < blocks.length; i++) {
                const block = blocks[i];

                if (block.isCompact) {
                    // Gap block - check if timestamp falls within gap
                    if (timestamp >= block.gapStartTs && timestamp < block.gapEndTs) {
                        // Position at start of compact gap (don't interpolate within gap)
                        return block.xPosition;
                    }
                } else {
                    // Normal block
                    const blockStart = block.timestamp;
                    const blockEnd = blockStart + blockSizeSeconds;

                    if (timestamp >= blockStart && timestamp < blockEnd) {
                        // Interpolate within block
                        const progress = (timestamp - blockStart) / blockSizeSeconds;
                        return block.xPosition + (progress * block.widthPx);
                    }
                }
            }

            // After last block - return end position
            const lastBlock = blocks[blocks.length - 1];
            return lastBlock.xPosition + lastBlock.widthPx;
        }

        // Toggle story visibility via checkbox
        function toggleStoryVisibility(storyId, visible) {
            if (visible) {
                timelineState.hiddenStories.delete(storyId);
            } else {
                timelineState.hiddenStories.add(storyId);
            }

            // Re-render timeline to update sort order and bounds
            renderTimeline();

            // Save UI state when visibility changes (Story 5-SR-7)
            saveUIState();
        }

        // Hide all stories in timeline
        function hideAllStories() {
            const timelineData = getTimelineData(state.orchestratorData);
            if (!timelineData) return;

            timelineData.forEach(activity => {
                timelineState.hiddenStories.add(activity.storyId);
            });

            // Re-render timeline with all stories hidden (moved to bottom)
            renderTimeline();
        }

        // Show all stories in timeline
        function showAllStories() {
            timelineState.hiddenStories.clear();

            // Remove any empty state message
            document.querySelectorAll('.timeline-empty').forEach(el => el.remove());

            // Rebuild timeline with full bounds
            renderTimeline();
        }

        // Get timeline data with processing
        function getTimelineData(orchestratorData) {
            if (!orchestratorData) return null;

            const hash = hashString(JSON.stringify(orchestratorData));
            if (hash === timelineCache.dataHash && timelineCache.data) {
                return timelineCache.data;
            }

            // Filter activities with valid data - newest first (matches Activity tab order)
            const validActivities = orchestratorData
                .filter(a => a.steps && a.steps.length > 0);

            timelineCache.data = validActivities;
            timelineCache.dataHash = hash;
            return timelineCache.data;
        }

        // Zoom timeline
        function zoomTimeline(direction) {
            const levels = [50, 75, 100, 150, 200];
            const currentIndex = levels.indexOf(timelineState.zoomLevel);

            if (direction === 'in' && currentIndex < levels.length - 1) {
                timelineState.zoomLevel = levels[currentIndex + 1];
            } else if (direction === 'out' && currentIndex > 0) {
                timelineState.zoomLevel = levels[currentIndex - 1];
            }

            document.getElementById('zoomLevel').textContent = timelineState.zoomLevel + '%';
            renderTimeline();
        }

        // Toggle story row expansion via label click (multiple can be expanded)
        function toggleStoryRow(storyId) {
            const sanitizedId = CSS.escape(String(storyId || ''));
            const row = document.querySelector(`.timeline-row[data-story-id="${sanitizedId}"]`);
            if (!row) return;

            const wasExpanded = row.classList.contains('expanded');

            // Toggle current row (allow multiple expansions)
            row.classList.toggle('expanded', !wasExpanded);

            if (wasExpanded) {
                timelineState.expandedStoryIds.delete(storyId);
            } else {
                timelineState.expandedStoryIds.add(storyId);
            }

            // Save UI state when timeline row expansion changes (Story 5-SR-7)
            saveUIState();
        }

        // Toggle command expand/collapse in timeline
        function toggleTimelineCommand(cmdKey) {
            const cmdGroup = document.querySelector(`.timeline-command-group[data-cmd-key="${CSS.escape(cmdKey)}"]`);
            if (!cmdGroup) return;

            const wasExpanded = !cmdGroup.classList.contains('collapsed');
            cmdGroup.classList.toggle('collapsed', wasExpanded);

            // Store state (default is expanded=true, so we only store when collapsed)
            if (wasExpanded) {
                timelineState.expandedCommands.set(cmdKey, false);
            } else {
                timelineState.expandedCommands.delete(cmdKey); // Remove to use default (expanded)
            }
        }

        // Show timeline tooltip
        function showTimelineTooltip(event, storyId, duration, stepCount, started) {
            const tooltip = document.getElementById('timelineTooltip');
            if (!tooltip) return;

            const safeSteps = Math.max(0, parseInt(stepCount, 10) || 0);

            const titleDiv = document.createElement('div');
            titleDiv.className = 'timeline-tooltip-title';
            titleDiv.textContent = storyId || ''; // textContent handles escaping

            const metaDiv = document.createElement('div');
            metaDiv.className = 'timeline-tooltip-meta';

            // Build meta content safely using DOM methods
            metaDiv.appendChild(document.createTextNode('Duration: ' + (duration || 'In progress')));
            metaDiv.appendChild(document.createElement('br'));
            metaDiv.appendChild(document.createTextNode('Steps: ' + safeSteps));
            if (started) {
                metaDiv.appendChild(document.createElement('br'));
                metaDiv.appendChild(document.createTextNode('Started: ' + started));
            }

            tooltip.innerHTML = '';
            tooltip.appendChild(titleDiv);
            tooltip.appendChild(metaDiv);

            tooltip.style.left = (event.clientX + 10) + 'px';
            tooltip.style.top = (event.clientY - 10) + 'px';
            tooltip.classList.add('visible');
        }

        function hideTimelineTooltip() {
            const tooltip = document.getElementById('timelineTooltip');
            if (tooltip) {
                tooltip.classList.remove('visible');
            }
        }

        // Render timeline visualization
        function renderTimeline() {
            const hoursEl = document.getElementById('timelineHours');
            const gridEl = document.getElementById('timelineGrid');
            const rowsEl = document.getElementById('timelineRows');
            const bodyEl = document.getElementById('timelineBody');
            const scrollContainer = document.getElementById('timelineScrollContainer');

            if (!hoursEl || !gridEl || !rowsEl || !bodyEl) {
                console.warn('Timeline elements not found');
                return;
            }

            // Get processed timeline data
            const timelineData = getTimelineData(state.orchestratorData);

            if (!timelineData || timelineData.length === 0) {
                hoursEl.innerHTML = '';
                gridEl.innerHTML = '';
                rowsEl.innerHTML = '<div class="timeline-empty">No timeline data available</div>';
                return;
            }

            // Separate visible and hidden stories, maintaining original chronological order
            const visibleActivities = timelineData.filter(
                a => !timelineState.hiddenStories.has(a.storyId)
            );
            const hiddenActivities = timelineData.filter(
                a => timelineState.hiddenStories.has(a.storyId)
            );

            // Sorted display order: visible stories first (chronological), then hidden stories at bottom
            const sortedActivities = [...visibleActivities, ...hiddenActivities];

            // Calculate timeline bounds from timestamps (fallback for missing timestamps)
            const allStartTs = visibleActivities.map(a => a.startTs).filter(ts => ts);

            if (allStartTs.length === 0 && visibleActivities.length > 0) {
                // Fallback: use sequential positioning with realistic base timestamp
                let offset = Math.floor(Date.now() / 1000) - (timelineData.length * 3600);
                timelineData.forEach(a => {
                    a.startTs = offset;
                    const dur = a.totalDurationSecs || 3600;
                    a.endTs = offset + dur;
                    offset = a.endTs + 300;
                });
            }

            // Calculate bounds from visible stories only
            const startTimestamps = visibleActivities.map(a => a.startTs).filter(ts => ts != null);
            const endTimestamps = visibleActivities.map(a => a.endTs || a.startTs + 3600).filter(ts => ts != null);

            timelineState.timelineStartTs = startTimestamps.length > 0 ? Math.min(...startTimestamps) : 0;
            timelineState.timelineEndTs = endTimestamps.length > 0 ? Math.max(...endTimestamps) : 3600;

            // Generate time blocks and compact empty ones
            const blockWidthPx = COLUMN_WIDTH_PX * (timelineState.zoomLevel / 100);
            let blocks = [];

            if (visibleActivities.length > 0) {
                const rawBlocks = generateTimeBlocks();
                blocks = compactEmptyBlocks(rawBlocks, visibleActivities, timelineState.blockSizeMinutes, blockWidthPx);
            }
            timelineState.processedBlocks = blocks;

            console.log('Timeline blocks:', blocks.length, 'compact:', blocks.filter(b => b.isCompact).length);

            // Render time header - compact blocks get small width
            hoursEl.innerHTML = '';
            blocks.forEach(block => {
                const hourDiv = document.createElement('div');
                hourDiv.className = 'timeline-hour' + (block.isCompact ? ' compact' : '');
                hourDiv.style.minWidth = block.widthPx + 'px';
                hourDiv.style.width = block.widthPx + 'px';
                hourDiv.textContent = block.isCompact ? '' : block.label;
                hoursEl.appendChild(hourDiv);
            });

            // Render grid lines - compact blocks get small width
            gridEl.innerHTML = '';
            blocks.forEach(block => {
                const gridLine = document.createElement('div');
                gridLine.className = 'timeline-grid-line' + (block.isCompact ? ' compact' : '');
                gridLine.style.minWidth = block.widthPx + 'px';
                gridLine.style.width = block.widthPx + 'px';
                gridEl.appendChild(gridLine);
            });

            // Render story rows (visible first, then hidden at bottom)
            rowsEl.innerHTML = '';
            sortedActivities.forEach(activity => {
                const isHidden = timelineState.hiddenStories.has(activity.storyId);
                const isCompleted = activity.completed && activity.completed !== '';

                const safeStoryId = escapeHtml(activity.storyId);
                const safeDuration = escapeHtml(activity.duration || '');
                const safeStepCount = activity.steps ? activity.steps.length : 0;
                const safeStarted = escapeHtml(activity.started || '');

                // Create row container - hidden stories get 'hidden-story' class for muted styling
                const row = document.createElement('div');
                row.className = 'timeline-row' + (isHidden ? ' hidden-story' : '');
                row.setAttribute('data-story-id', safeStoryId);

                // Create row main area (label + content)
                const rowMain = document.createElement('div');
                rowMain.className = 'timeline-row-main';

                // Create row label with checkbox
                const label = document.createElement('div');
                label.className = 'timeline-row-label';
                label.title = safeStoryId;

                // Add visibility checkbox
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'story-visibility-checkbox';
                checkbox.dataset.storyId = safeStoryId;
                checkbox.checked = !isHidden;
                checkbox.addEventListener('change', (e) => {
                    e.stopPropagation();
                    toggleStoryVisibility(activity.storyId, e.target.checked);
                });
                checkbox.addEventListener('click', (e) => e.stopPropagation());

                // Only show expand icon for visible stories (hidden ones have no content to expand)
                if (!isHidden) {
                    const expandIcon = document.createElement('span');
                    expandIcon.className = 'label-expand-icon';
                    expandIcon.innerHTML = '&#9654;';
                    label.appendChild(checkbox);
                    label.appendChild(expandIcon);
                } else {
                    label.appendChild(checkbox);
                }

                const titleSpan = document.createElement('span');
                titleSpan.className = 'label-title';
                titleSpan.textContent = activity.storyId;

                const durationSpan = document.createElement('span');
                durationSpan.className = 'label-duration';
                durationSpan.textContent = activity.duration || '';

                label.appendChild(titleSpan);
                label.appendChild(durationSpan);

                // Only add click handler for expand on visible stories
                if (!isHidden) {
                    label.addEventListener('click', () => toggleStoryRow(safeStoryId));
                }

                // Create row content - set explicit width to match grid
                const content = document.createElement('div');
                content.className = 'timeline-row-content';
                content.style.width = timelineState.totalTimelineWidth + 'px';
                content.style.minWidth = timelineState.totalTimelineWidth + 'px';

                // Only render timeline bar for visible stories
                // Use block-based timestampToX() - bars scale with block size
                if (!isHidden && blocks.length > 0) {
                    const barLeft = timestampToX(activity.startTs);
                    // For in-progress stories without endTs, use current time capped at 30 min
                    const MAX_IN_PROGRESS_SECS = 30 * 60;
                    const now = Math.floor(Date.now() / 1000);
                    const fallbackEnd = activity.startTs + Math.min(now - activity.startTs, MAX_IN_PROGRESS_SECS);
                    const barRight = timestampToX(activity.endTs || fallbackEnd);
                    const barWidth = Math.max(barRight - barLeft, 20); // Minimum width for visibility

                    const bar = document.createElement('div');
                    bar.className = `timeline-bar story-bar ${isCompleted ? '' : 'in-progress'}`;
                    bar.style.left = barLeft + 'px';
                    bar.style.width = barWidth + 'px';
                    // Hide text if bar is too narrow
                    const showStoryLabel = barWidth >= 50;
                    bar.innerHTML = showStoryLabel ? `<span class="bar-label">${safeDuration || '...'}</span>` : '';
                    bar.addEventListener('mouseenter', (e) => showTimelineTooltip(e, safeStoryId, safeDuration, safeStepCount, safeStarted));
                    bar.addEventListener('mouseleave', () => hideTimelineTooltip());
                    content.appendChild(bar);
                }

                rowMain.appendChild(label);
                rowMain.appendChild(content);
                row.appendChild(rowMain);

                // Only create command rows for visible stories
                if (!isHidden) {
                    const commandRows = document.createElement('div');
                    commandRows.className = 'timeline-command-rows';

                    // Generate command rows - use continuous positioning
                    const MAX_IN_PROGRESS_SECS = 30 * 60;
                    const now = Math.floor(Date.now() / 1000);

                    (activity.steps || []).forEach((step, stepIndex) => {
                        const cmdLeft = timestampToX(step.startTs);
                        // For in-progress commands without endTs, use current time capped at 30 min
                        const cmdFallbackEnd = step.startTs + Math.min(now - step.startTs, MAX_IN_PROGRESS_SECS);
                        const cmdRight = timestampToX(step.endTs || cmdFallbackEnd);
                        const cmdWidth = Math.max(cmdRight - cmdLeft, 20); // Minimum width for visibility
                        const cmdClass = getCommandClass(step.command);
                        const safeCmdDuration = escapeHtml(step.duration || '');
                        const hasInProgressTasks = step.tasks && step.tasks.some(t => t.status === 'in-progress');
                        const hasTasks = step.tasks && step.tasks.length > 1;

                        // Create command group container for expand/collapse
                        const cmdGroupKey = `${activity.storyId}|${step.command}|${stepIndex}`;
                        const isExpanded = timelineState.expandedCommands ?
                            (timelineState.expandedCommands.get(cmdGroupKey) !== false) : true; // Default expanded

                        const cmdGroup = document.createElement('div');
                        cmdGroup.className = 'timeline-command-group' + (isExpanded ? '' : ' collapsed');
                        cmdGroup.dataset.cmdKey = cmdGroupKey;

                        const cmdRow = document.createElement('div');
                        cmdRow.className = 'timeline-command-row';

                        const cmdRowLabel = document.createElement('div');
                        cmdRowLabel.className = 'timeline-command-row-label';

                        // Add expand/collapse toggle if there are tasks
                        if (hasTasks) {
                            const toggleIcon = document.createElement('span');
                            toggleIcon.className = 'cmd-expand-icon';
                            toggleIcon.innerHTML = '&#9654;';
                            toggleIcon.addEventListener('click', (e) => {
                                e.stopPropagation();
                                toggleTimelineCommand(cmdGroupKey);
                            });
                            cmdRowLabel.appendChild(toggleIcon);
                        }

                        const cmdLabelText = document.createElement('span');
                        cmdLabelText.textContent = step.command;
                        cmdRowLabel.appendChild(cmdLabelText);
                        cmdRowLabel.title = step.command;

                        // Make label clickable to toggle
                        if (hasTasks) {
                            cmdRowLabel.style.cursor = 'pointer';
                            cmdRowLabel.addEventListener('click', () => toggleTimelineCommand(cmdGroupKey));
                        }

                        const cmdRowContent = document.createElement('div');
                        cmdRowContent.className = 'timeline-command-row-content';
                        cmdRowContent.style.width = timelineState.totalTimelineWidth + 'px';
                        cmdRowContent.style.minWidth = timelineState.totalTimelineWidth + 'px';

                        const cmdBar = document.createElement('div');
                        cmdBar.className = `command-bar ${cmdClass}${hasInProgressTasks ? ' in-progress-stripe' : ''}`;
                        cmdBar.style.left = cmdLeft + 'px';
                        cmdBar.style.width = cmdWidth + 'px';
                        // Hide text if bar is too narrow
                        const showCmdLabel = cmdWidth >= 40;
                        cmdBar.innerHTML = showCmdLabel ? `<span class="command-label">${safeCmdDuration}</span>` : '';
                        cmdBar.title = `${step.command}: ${step.duration || ''}`;

                        cmdRowContent.appendChild(cmdBar);
                        cmdRow.appendChild(cmdRowLabel);
                        cmdRow.appendChild(cmdRowContent);
                        cmdGroup.appendChild(cmdRow);

                        // Container for tasks (can be collapsed)
                        const tasksContainer = document.createElement('div');
                        tasksContainer.className = 'timeline-tasks-container';

                        // Add task-level rows within command only if multiple tasks exist
                        // Single task = no granularity to show, just the command is enough
                        if (step.tasks && step.tasks.length > 1) {
                            step.tasks.forEach(task => {
                                const taskLeft = timestampToX(task.startTs);
                                // For in-progress tasks without endTs, use current time capped at 30 min
                                const taskFallbackEnd = task.startTs + Math.min(now - task.startTs, MAX_IN_PROGRESS_SECS);
                                const taskRight = timestampToX(task.endTs || taskFallbackEnd);
                                const taskWidth = Math.max(taskRight - taskLeft, 15);
                                const isTaskInProgress = task.status === 'in-progress';
                                const safeTaskMessage = escapeHtml(task.message || '');

                                const taskRow = document.createElement('div');
                                taskRow.className = 'timeline-task-row';

                                const taskRowLabel = document.createElement('div');
                                taskRowLabel.className = 'timeline-task-row-label';
                                taskRowLabel.textContent = task.taskId;
                                taskRowLabel.title = task.taskId;

                                const taskRowContent = document.createElement('div');
                                taskRowContent.className = 'timeline-task-row-content';
                                taskRowContent.style.width = timelineState.totalTimelineWidth + 'px';
                                taskRowContent.style.minWidth = timelineState.totalTimelineWidth + 'px';

                                const taskBar = document.createElement('div');
                                taskBar.className = `task-bar ${isTaskInProgress ? 'in-progress' : 'completed'}`;
                                taskBar.style.left = taskLeft + 'px';
                                taskBar.style.width = taskWidth + 'px';
                                const showTaskLabel = taskWidth >= 30;
                                taskBar.innerHTML = showTaskLabel ? `<span class="task-label">${escapeHtml(task.duration || '')}</span>` : '';
                                taskBar.title = safeTaskMessage || `${task.taskId}: ${task.duration || (isTaskInProgress ? 'running...' : '')}`;

                                taskRowContent.appendChild(taskBar);
                                taskRow.appendChild(taskRowLabel);
                                taskRow.appendChild(taskRowContent);
                                tasksContainer.appendChild(taskRow);

                                // Add message row below task if message exists
                                if (safeTaskMessage) {
                                    const msgRow = document.createElement('div');
                                    msgRow.className = 'timeline-message-row';

                                    const msgLabel = document.createElement('div');
                                    msgLabel.className = 'timeline-message-label';

                                    const msgContent = document.createElement('div');
                                    msgContent.className = 'timeline-message-content';
                                    msgContent.style.width = timelineState.totalTimelineWidth + 'px';
                                    msgContent.style.minWidth = timelineState.totalTimelineWidth + 'px';

                                    const msgText = document.createElement('span');
                                    msgText.className = 'timeline-message-text';
                                    msgText.textContent = safeTaskMessage;
                                    msgText.style.marginLeft = taskLeft + 'px';

                                    msgContent.appendChild(msgText);
                                    msgRow.appendChild(msgLabel);
                                    msgRow.appendChild(msgContent);
                                    tasksContainer.appendChild(msgRow);
                                }
                            });
                        }

                        cmdGroup.appendChild(tasksContainer);
                        commandRows.appendChild(cmdGroup);
                    });

                    row.appendChild(commandRows);
                }

                rowsEl.appendChild(row);
            });

            // Auto-scroll to end on initial render
            if (scrollContainer && timelineData.length > 0) {
                if (!timelineCache.hasScrolled) {
                    setTimeout(() => {
                        scrollContainer.scrollLeft = scrollContainer.scrollWidth;
                        timelineCache.hasScrolled = true;
                    }, 100);
                }
            }
        }

        // ============================================================
        // Tab Switching and Updates
        // ============================================================

        function switchTab(tabName) {
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.tab === tabName);
            });
            document.querySelectorAll('.tab-panel').forEach(panel => {
                panel.classList.toggle('active', panel.id === `tab-${tabName}`);
            });
            if (tabName === 'timeline') {
                timelineCache.hasScrolled = false;
                renderTimeline();
            }
            // Persist active tab
            localStorage.setItem('dashboard-active-tab', tabName);
        }

        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.addEventListener('click', () => switchTab(btn.dataset.tab));
        });

        // Restore active tab from localStorage
        function restoreActiveTab() {
            const savedTab = localStorage.getItem('dashboard-active-tab');
            if (savedTab) {
                switchTab(savedTab);
            }
        }

        function updateTabCounts(sprintData, orchestratorData) {
            if (sprintData) {
                const epics = Object.values(sprintData.epics).filter(e => !e.id.includes('retrospective'));
                const stories = sprintData.stories.filter(s => !s.id.includes('retrospective'));
                document.getElementById('epicsCount').textContent = epics.length;
                document.getElementById('storiesCount').textContent = stories.length;
            }
            if (orchestratorData) {
                document.getElementById('activityCount').textContent = orchestratorData.length;
            }
        }

        function updateLastUpdatedTime() {
            if (!state.lastUpdateTime) return;

            const now = Date.now();
            const secondsAgo = Math.floor((now - state.lastUpdateTime) / 1000);

            let timeText = 'just now';
            if (secondsAgo > 0 && secondsAgo < 60) {
                timeText = `${secondsAgo}s ago`;
            } else if (secondsAgo >= 60 && secondsAgo < 3600) {
                const mins = Math.floor(secondsAgo / 60);
                timeText = `${mins}m ago`;
            } else if (secondsAgo >= 3600) {
                const hours = Math.floor(secondsAgo / 3600);
                timeText = `${hours}h ago`;
            }

            document.getElementById('lastUpdated').textContent = `Last updated: ${timeText}`;
        }

        // ============================================================
        // Data Loading and Auto-refresh
        // ============================================================

        async function refreshViaFetch() {
            try {
                let sprintText = null;
                let orchText = null;

                const sprintResponse = await fetch('./sprint-status.yaml');
                if (sprintResponse.ok) {
                    sprintText = await sprintResponse.text();
                }

                const csvResponse = await fetch('./sprint-runner.csv?t=' + Date.now());
                if (csvResponse.ok) {
                    orchText = await csvResponse.text();
                    console.log('Loading sprint-runner.csv, length:', orchText.length, 'lines:', orchText.split('\n').length);
                }

                const combinedData = (sprintText || '') + '|' + (orchText || '');
                const newHash = hashString(combinedData);

                if (newHash === state.lastDataHash) {
                    return;
                }

                state.lastDataHash = newHash;
                state.lastUpdateTime = Date.now();

                if (sprintText) {
                    state.sprintData = parseSprintStatus(sprintText);
                    renderSummaryCards(state.sprintData);
                    renderEpicBoard(state.sprintData);
                    renderStoryTable(state.sprintData,
                        document.getElementById('epicFilter').value,
                        document.getElementById('statusFilter').value);
                }

                if (orchText) {
                    state.orchestratorData = parseOrchestrator(orchText);
                    renderActivityLog(state.orchestratorData);
                }

                updateTabCounts(state.sprintData, state.orchestratorData);
            } catch (e) {
                console.log('Fetch refresh failed:', e);
            }
        }

        async function tryAutoLoad() {
            try {
                await loadStoryDescriptions();

                const sprintResponse = await fetch('./sprint-status.yaml');
                if (sprintResponse.ok) {
                    const sprintText = await sprintResponse.text();
                    state.sprintData = parseSprintStatus(sprintText);
                    state.lastUpdateTime = Date.now();
                    renderSummaryCards(state.sprintData);
                    updateEpicFilter(state.sprintData);

                    // Restore filter values before rendering table (Story 5-SR-7)
                    try {
                        const filtersJson = localStorage.getItem(UI_STATE_KEYS.FILTERS);
                        if (filtersJson) {
                            const filters = JSON.parse(filtersJson);
                            const epicFilter = document.getElementById('epicFilter');
                            const statusFilter = document.getElementById('statusFilter');
                            // Only set if option exists in filter
                            if (epicFilter && filters.epic && Array.from(epicFilter.options).some(o => o.value === filters.epic)) {
                                epicFilter.value = filters.epic;
                            }
                            if (statusFilter && filters.status) {
                                statusFilter.value = filters.status;
                            }
                        }
                    } catch (e) {
                        console.warn('Failed to restore filters:', e);
                    }

                    renderEpicBoard(state.sprintData);

                    // Render story table with restored filters
                    const epicFilter = document.getElementById('epicFilter').value;
                    const statusFilter = document.getElementById('statusFilter').value;
                    renderStoryTable(state.sprintData, epicFilter, statusFilter);

                    // Restore expanded epics after render (Story 5-SR-7)
                    restoreExpandedEpics();
                }

                let orchText = null;
                const csvResponse = await fetch('./sprint-runner.csv?t=' + Date.now());
                if (csvResponse.ok) {
                    orchText = await csvResponse.text();
                    console.log('Loading sprint-runner.csv, length:', orchText.length, 'lines:', orchText.split('\n').length);
                }

                if (orchText) {
                    state.orchestratorData = parseOrchestrator(orchText);
                    console.log('Parsed activities:', state.orchestratorData.length, 'stories:', state.orchestratorData.map(a => a.storyId));
                    state.lastUpdateTime = Date.now();
                    renderActivityLog(state.orchestratorData);

                    // Restore expanded activities after render (Story 5-SR-7)
                    restoreExpandedActivities();
                }

                if (state.sprintData || state.orchestratorData) {
                    document.getElementById('dashboardContent').classList.add('visible');
                    document.getElementById('updateDot').classList.remove('inactive');
                    state.autoLoadWorks = true;
                    updateTabCounts(state.sprintData, state.orchestratorData);

                    // Restore scroll positions after initial render (Story 5-SR-7)
                    setTimeout(restoreScrollPositions, 100);

                    if (!state.watchInterval) {
                        state.isWatching = true;
                        state.watchInterval = setInterval(async () => {
                            await refreshViaFetch();
                        }, 5000);
                        console.log('Auto-refresh enabled (5s interval)');
                    }
                }
            } catch (e) {
                console.log('Auto-load failed:', e);
                state.autoLoadWorks = false;
                document.getElementById('lastUpdated').textContent = 'Failed to load - serve via HTTP';
            }
        }

        // Filter event listeners
        document.getElementById('epicFilter').addEventListener('change', (e) => {
            if (state.sprintData) {
                const statusFilter = document.getElementById('statusFilter').value;
                renderStoryTable(state.sprintData, e.target.value, statusFilter);
                // Save UI state when filter changes (Story 5-SR-7)
                saveUIState();
            }
        });

        document.getElementById('statusFilter').addEventListener('change', (e) => {
            if (state.sprintData) {
                const epicFilter = document.getElementById('epicFilter').value;
                renderStoryTable(state.sprintData, epicFilter, e.target.value);
                // Save UI state when filter changes (Story 5-SR-7)
                saveUIState();
            }
        });

        // Initialize (Story 5-SR-7: Restore UI state before initial render)
        restoreUIState();
        restoreColumnWidth();
        initColumnResize();
        initTimelineCursorLine();
        restoreActiveTab();
        tryAutoLoad();

        // Update time display
        setInterval(updateLastUpdatedTime, 1000);

        // Save scroll positions periodically to localStorage (Story 5-SR-7)
        setInterval(saveUIState, 5000);

        // ============================================================
        // SPRINT RUN TAB FUNCTIONALITY (Story 5-SR-6)
        // ============================================================

        // Sprint Run State
        const sprintRunState = {
            ws: null,
            wsReconnectTimer: null,
            wsReconnectAttempts: 0,
            isRunning: false,
            isStopping: false,
            currentBatchId: null,
            maxCycles: 0,
            currentCycle: 0,
            activeStories: [],
            currentOperation: null,
            autoScroll: true,
            userScrolled: false
        };

        // Toast Notifications (AC: #6)
        function showToast(message, type = 'info', title = null, duration = 5000) {
            const container = document.getElementById('toastContainer');
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;

            const icons = {
                error: '&#10060;',
                success: '&#10004;',
                warning: '&#9888;',
                info: '&#8505;'
            };

            toast.innerHTML = `
                <span class="toast-icon">${icons[type] || icons.info}</span>
                <div class="toast-content">
                    ${title ? `<div class="toast-title">${title}</div>` : ''}
                    <div class="toast-message">${message}</div>
                </div>
                <button class="toast-close" onclick="this.parentElement.remove()">&times;</button>
            `;

            container.appendChild(toast);

            // Auto-dismiss (errors stay longer or persist)
            if (type !== 'error' || duration > 0) {
                setTimeout(() => {
                    if (toast.parentElement) {
                        toast.style.animation = 'slideIn 0.3s ease reverse';
                        setTimeout(() => toast.remove(), 300);
                    }
                }, type === 'error' ? 10000 : duration);
            }
        }

        // WebSocket Connection (AC: #5)
        function connectSprintWebSocket() {
            const wsUrl = `ws://${window.location.host}/ws`;
            updateWsConnectionStatus('connecting');

            try {
                sprintRunState.ws = new WebSocket(wsUrl);

                sprintRunState.ws.onopen = () => {
                    console.log('WebSocket connected');
                    updateWsConnectionStatus('connected');
                    sprintRunState.wsReconnectAttempts = 0;
                    addLogEntry({ type: 'system', message: 'Connected to server' }, 'system');
                };

                sprintRunState.ws.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        handleWebSocketEvent(data);
                    } catch (e) {
                        console.error('Failed to parse WebSocket message:', e);
                    }
                };

                sprintRunState.ws.onclose = () => {
                    console.log('WebSocket disconnected');
                    updateWsConnectionStatus('disconnected');
                    scheduleWsReconnect();
                };

                sprintRunState.ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    updateWsConnectionStatus('disconnected');
                };
            } catch (e) {
                console.error('Failed to create WebSocket:', e);
                updateWsConnectionStatus('disconnected');
                scheduleWsReconnect();
            }
        }

        function scheduleWsReconnect() {
            if (sprintRunState.wsReconnectTimer) return;

            const delay = Math.min(3000 * Math.pow(2, sprintRunState.wsReconnectAttempts), 30000);
            sprintRunState.wsReconnectAttempts++;

            sprintRunState.wsReconnectTimer = setTimeout(() => {
                sprintRunState.wsReconnectTimer = null;
                connectSprintWebSocket();
            }, delay);
        }

        function updateWsConnectionStatus(status) {
            const dot = document.getElementById('wsConnectionDot');
            const text = document.getElementById('wsConnectionText');

            dot.className = 'ws-connection-dot ' + status;
            text.textContent = status.charAt(0).toUpperCase() + status.slice(1);
        }

        // WebSocket Event Handling (AC: #5)
        function handleWebSocketEvent(event) {
            const { type, payload, timestamp } = event;

            switch (type) {
                case 'init':
                    // Initial state from server
                    if (payload.batch) {
                        handleBatchState(payload.batch);
                    }
                    if (payload.events) {
                        payload.events.forEach(e => addLogEntry(e, getEventStatus(e)));
                    }
                    break;

                case 'batch:start':
                    sprintRunState.isRunning = true;
                    sprintRunState.isStopping = false;
                    sprintRunState.currentBatchId = payload.batch_id;
                    sprintRunState.maxCycles = payload.max_cycles || 0;
                    sprintRunState.currentCycle = 0;
                    updateSprintUI();
                    showProgressSection(true);
                    addLogEntry({ type, payload, timestamp }, 'start');
                    updateTabIndicator(true);
                    break;

                case 'batch:end':
                    sprintRunState.isRunning = false;
                    sprintRunState.isStopping = false;
                    sprintRunState.currentOperation = null;
                    updateSprintUI();
                    addLogEntry({ type, payload, timestamp }, payload.status === 'completed' ? 'end' : 'system');
                    updateTabIndicator(false);
                    if (payload.status === 'completed') {
                        showToast(`Batch completed: ${payload.cycles_completed} cycles`, 'success', 'Sprint Complete');
                    }
                    break;

                case 'cycle:start':
                    sprintRunState.currentCycle = payload.cycle_number;
                    sprintRunState.activeStories = payload.story_keys || [];
                    updateProgress();
                    updateActiveStories();
                    addLogEntry({ type, payload, timestamp }, 'start');
                    break;

                case 'cycle:end':
                    updateProgress();
                    addLogEntry({ type, payload, timestamp }, 'end');
                    break;

                case 'command:start':
                    sprintRunState.currentOperation = `${payload.story_key} ${payload.command} (${payload.task_id})`;
                    updateCurrentOperation();
                    addLogEntry({ type, payload, timestamp }, 'start');
                    break;

                case 'command:progress':
                    addLogEntry({ type, payload, timestamp }, 'progress');
                    break;

                case 'command:end':
                    if (sprintRunState.currentOperation &&
                        sprintRunState.currentOperation.includes(payload.story_key)) {
                        sprintRunState.currentOperation = null;
                        updateCurrentOperation();
                    }
                    addLogEntry({ type, payload, timestamp }, payload.status === 'error' ? 'error' : 'end');
                    break;

                case 'story:status':
                    updateStoryBadge(payload.story_key, payload.new_status);
                    addLogEntry({ type, payload, timestamp }, 'system');
                    break;

                case 'error':
                    addLogEntry({ type, payload, timestamp }, 'error');
                    showToast(payload.message, 'error', 'Error');
                    break;

                case 'context:create':
                case 'context:refresh':
                case 'context:complete':
                    addLogEntry({ type, payload, timestamp }, 'system');
                    break;

                default:
                    console.log('Unknown WebSocket event:', type, payload);
            }
        }

        function getEventStatus(event) {
            // Handle database event format (has 'status' field)
            if (event.status) {
                const s = event.status.toLowerCase();
                if (s === 'start') return 'start';
                if (s === 'end' || s === 'complete' || s === 'completed') return 'end';
                if (s === 'progress') return 'progress';
                if (s === 'error' || s === 'failed') return 'error';
                return 'system';
            }
            // Handle WebSocket event format (has 'type' field)
            if (event.type?.includes('start')) return 'start';
            if (event.type?.includes('end') || event.type?.includes('complete')) return 'end';
            if (event.type?.includes('progress')) return 'progress';
            if (event.type?.includes('error')) return 'error';
            return 'system';
        }

        function handleBatchState(batch) {
            if (batch && batch.status === 'running') {
                sprintRunState.isRunning = true;
                sprintRunState.currentBatchId = batch.id;
                sprintRunState.maxCycles = batch.max_cycles;
                sprintRunState.currentCycle = batch.cycles_completed || 0;
                updateSprintUI();
                showProgressSection(true);
                updateTabIndicator(true);
            }
        }

        // Event Log (AC: #5)
        function addLogEntry(event, status) {
            const entries = document.getElementById('sprintLogEntries');

            // Remove empty state message if present
            const emptyMsg = entries.querySelector('.log-empty');
            if (emptyMsg) emptyMsg.remove();

            const entry = document.createElement('div');
            entry.className = `log-entry ${status}`;

            // Handle timestamp - database events use seconds, WebSocket uses milliseconds
            let timestamp;
            if (event.timestamp) {
                // Database timestamps are in seconds, WebSocket in milliseconds
                const ts = event.timestamp < 10000000000 ? event.timestamp * 1000 : event.timestamp;
                timestamp = formatLogTime(ts);
            } else {
                timestamp = formatLogTime(Date.now());
            }

            // Handle both WebSocket format (payload object) and database format (flat fields)
            // Database events have: story_key, command, task_id, status, message directly on event
            // WebSocket events have: type, payload: { story_key, command, task_id, message }
            const payload = event.payload || {};
            const storyKey = payload.story_key || event.story_key || '-';
            const command = payload.command || event.command || event.type?.split(':')[0] || '-';
            const taskId = payload.task_id || event.task_id || '-';
            const message = payload.message || event.message || '';

            if (event.type === 'system' || status === 'system') {
                entry.innerHTML = `
                    <span class="log-timestamp">${timestamp}</span>
                    <span class="log-message">${message || event.type || 'System event'}</span>
                `;
            } else {
                entry.innerHTML = `
                    <span class="log-timestamp">${timestamp}</span>
                    <span class="log-story-key">${storyKey}</span>
                    <span class="log-command">${command}</span>
                    <span class="log-task-id">${taskId}</span>
                    <span class="log-status ${status}">${status}</span>
                    <span class="log-message">${message}</span>
                `;
            }

            // Insert at top (newest first)
            entries.insertBefore(entry, entries.firstChild);

            // Auto-scroll handling
            if (sprintRunState.autoScroll && !sprintRunState.userScrolled) {
                const logContainer = document.getElementById('sprintLog');
                logContainer.scrollTop = 0;
            }

            // Limit entries to prevent memory issues
            while (entries.children.length > 500) {
                entries.removeChild(entries.lastChild);
            }
        }

        function formatLogTime(timestamp) {
            const date = new Date(timestamp);
            return date.toLocaleTimeString('en-US', { hour12: false });
        }

        function clearSprintLog() {
            const entries = document.getElementById('sprintLogEntries');
            entries.innerHTML = '<div class="log-empty">Log cleared. Events will appear here.</div>';
        }

        function toggleAutoScroll() {
            sprintRunState.autoScroll = !sprintRunState.autoScroll;
            document.getElementById('autoScrollState').textContent = sprintRunState.autoScroll ? 'ON' : 'OFF';
        }

        // Auto-scroll detection
        document.getElementById('sprintLog')?.addEventListener('scroll', function() {
            const isAtTop = this.scrollTop < 50;
            sprintRunState.userScrolled = !isAtTop;
        });

        // Control Panel (AC: #2, #3, #4)
        function updateSprintUI() {
            const startBtn = document.getElementById('sprintStartBtn');
            const stopBtn = document.getElementById('sprintStopBtn');
            const batchInput = document.getElementById('batchSizeInput');
            const runAllCheckbox = document.getElementById('runAllCheckbox');
            const statusValue = document.getElementById('sprintStatusValue');

            if (sprintRunState.isRunning) {
                startBtn.disabled = true;
                stopBtn.disabled = sprintRunState.isStopping;
                batchInput.disabled = true;
                runAllCheckbox.disabled = true;

                if (sprintRunState.isStopping) {
                    statusValue.textContent = 'Stopping...';
                    statusValue.className = 'sprint-status-value stopping';
                } else {
                    const cycleText = sprintRunState.maxCycles > 0
                        ? `Running cycle ${sprintRunState.currentCycle}/${sprintRunState.maxCycles}`
                        : `Running cycle ${sprintRunState.currentCycle}`;
                    statusValue.textContent = cycleText;
                    statusValue.className = 'sprint-status-value running';
                }
            } else {
                startBtn.disabled = false;
                stopBtn.disabled = true;
                batchInput.disabled = runAllCheckbox.checked;
                runAllCheckbox.disabled = false;
                statusValue.textContent = 'Idle';
                statusValue.className = 'sprint-status-value idle';
            }
        }

        function updateCurrentOperation() {
            const opDisplay = document.getElementById('sprintCurrentOp');
            opDisplay.textContent = sprintRunState.currentOperation || '-';
        }

        function showProgressSection(show) {
            const section = document.getElementById('sprintProgressSection');
            section.style.display = show ? 'block' : 'none';
        }

        function updateProgress() {
            const fill = document.getElementById('sprintProgressFill');
            const stats = document.getElementById('sprintProgressStats');

            const progress = sprintRunState.maxCycles > 0
                ? (sprintRunState.currentCycle / sprintRunState.maxCycles) * 100
                : 0;

            fill.style.width = `${Math.min(progress, 100)}%`;
            stats.textContent = sprintRunState.maxCycles > 0
                ? `${sprintRunState.currentCycle}/${sprintRunState.maxCycles} cycles`
                : `${sprintRunState.currentCycle} cycles`;
        }

        function updateActiveStories() {
            const container = document.getElementById('sprintActiveStories');
            container.innerHTML = sprintRunState.activeStories.map(key =>
                `<span class="sprint-story-badge in-progress" data-story="${key}">${key}</span>`
            ).join('');
        }

        function updateStoryBadge(storyKey, status) {
            const badge = document.querySelector(`.sprint-story-badge[data-story="${storyKey}"]`);
            if (badge) {
                badge.className = `sprint-story-badge ${status === 'done' ? 'done' : 'in-progress'}`;
            }
        }

        function updateTabIndicator(isActive) {
            const countSpan = document.getElementById('sprintrunCount');
            if (isActive) {
                countSpan.textContent = '';
                countSpan.classList.add('active');
            } else {
                countSpan.textContent = '';
                countSpan.classList.remove('active');
            }
        }

        // Start/Stop Actions (AC: #3, #4)
        async function startSprint() {
            const batchInput = document.getElementById('batchSizeInput');
            const runAllCheckbox = document.getElementById('runAllCheckbox');

            const batchSize = runAllCheckbox.checked ? 'all' : parseInt(batchInput.value, 10);

            if (!runAllCheckbox.checked && (isNaN(batchSize) || batchSize < 1)) {
                showToast('Please enter a valid batch size (positive number)', 'warning');
                return;
            }

            try {
                const response = await fetch('/api/orchestrator/start', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ batch_size: batchSize })
                });

                if (!response.ok) {
                    const error = await response.text();
                    throw new Error(error || 'Failed to start sprint');
                }

                // UI updates will come via WebSocket
                showToast('Sprint started', 'success');

            } catch (error) {
                console.error('Failed to start sprint:', error);
                showToast(error.message || 'Failed to start sprint', 'error');
            }
        }

        async function stopSprint() {
            sprintRunState.isStopping = true;
            updateSprintUI();

            try {
                const response = await fetch('/api/orchestrator/stop', {
                    method: 'POST'
                });

                if (!response.ok) {
                    throw new Error('Failed to stop sprint');
                }

                showToast('Stop signal sent. Waiting for current operation to complete...', 'warning');

            } catch (error) {
                console.error('Failed to stop sprint:', error);
                showToast(error.message || 'Failed to stop sprint', 'error');
                sprintRunState.isStopping = false;
                updateSprintUI();
            }
        }

        // Event Listeners
        document.getElementById('sprintStartBtn')?.addEventListener('click', startSprint);
        document.getElementById('sprintStopBtn')?.addEventListener('click', stopSprint);

        document.getElementById('runAllCheckbox')?.addEventListener('change', function() {
            const batchInput = document.getElementById('batchSizeInput');
            batchInput.disabled = this.checked;
            if (this.checked) {
                batchInput.value = '';
            } else {
                batchInput.value = localStorage.getItem('dashboard-sprintrun-batchsize') || '2';
            }
            saveSprintRunPrefs();
        });

        document.getElementById('batchSizeInput')?.addEventListener('change', saveSprintRunPrefs);

        // Persistence (Story 5-SR-7 pattern)
        function saveSprintRunPrefs() {
            const batchInput = document.getElementById('batchSizeInput');
            const runAllCheckbox = document.getElementById('runAllCheckbox');

            if (batchInput.value && !runAllCheckbox.checked) {
                localStorage.setItem('dashboard-sprintrun-batchsize', batchInput.value);
            }
            localStorage.setItem('dashboard-sprintrun-runall', runAllCheckbox.checked);
        }

        function restoreSprintRunPrefs() {
            const savedBatchSize = localStorage.getItem('dashboard-sprintrun-batchsize');
            const savedRunAll = localStorage.getItem('dashboard-sprintrun-runall') === 'true';

            if (savedBatchSize) {
                document.getElementById('batchSizeInput').value = savedBatchSize;
            }
            document.getElementById('runAllCheckbox').checked = savedRunAll;
            document.getElementById('batchSizeInput').disabled = savedRunAll;
        }

        // Initialize Sprint Run Tab
        function initSprintRunTab() {
            restoreSprintRunPrefs();
            connectSprintWebSocket();
            updateSprintUI();
        }

        // Initialize when DOM is ready
        initSprintRunTab();
    </script>
</body>
</html>
