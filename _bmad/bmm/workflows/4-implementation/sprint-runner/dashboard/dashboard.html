<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grimoire - Project Dashboard</title>
    <style>
        /* Reset & Base */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            /* ==============================================
               CSS Custom Properties from UI/UX Specification
               Appendix A - Complete CSS Variables
               ============================================== */

            /* Colors - Base */
            --color-bg: #f7f6f3;
            --color-surface: #ffffff;
            --color-text: #37352f;
            --color-text-secondary: #787774;
            --color-text-muted: #9ca3af;
            --color-border: #e8e7e5;
            --color-border-hover: #d1d0cd;

            /* Colors - Status */
            --color-running: #3b82f6;
            --color-success: #10b981;
            --color-error: #ef4444;
            --color-warning: #f59e0b;
            --color-pending: #9ca3af;
            --color-in-progress: #60a5fa;

            /* Colors - Commands */
            --color-cmd-create-story: #3b82f6;
            --color-cmd-create-story-bg: #dbeafe;
            --color-cmd-story-review: #f59e0b;
            --color-cmd-story-review-bg: #fef3c7;
            --color-cmd-create-tech-spec: #6366f1;
            --color-cmd-create-tech-spec-bg: #e0e7ff;
            --color-cmd-tech-spec-review: #8b5cf6;
            --color-cmd-tech-spec-review-bg: #ede9fe;
            --color-cmd-dev-story: #22c55e;
            --color-cmd-dev-story-bg: #dcfce7;
            --color-cmd-code-review: #a855f7;
            --color-cmd-code-review-bg: #f3e8ff;
            --color-cmd-commit: #14b8a6;
            --color-cmd-commit-bg: #ccfbf1;

            /* Colors - Interactive States */
            --color-hover-bg: #f7f6f3;
            --color-active-bg: #e8e7e5;
            --color-selected-bg: #dbeafe;
            --color-selected-border: #3b82f6;
            --color-selected-text: #1e40af;
            --color-disabled-bg: #f7f6f3;
            --color-disabled-text: #9ca3af;

            /* Typography - Font Stacks */
            --font-sans: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            --font-mono: 'SF Mono', Monaco, 'Cascadia Code', 'Fira Code', 'Courier New', monospace;

            /* Typography - Font Sizes */
            --text-xs: 11px;
            --text-sm: 13px;
            --text-base: 14px;
            --text-lg: 16px;
            --text-xl: 20px;
            --text-2xl: 24px;

            /* Typography - Line Heights */
            --leading-xs: 16px;
            --leading-sm: 18px;
            --leading-base: 20px;
            --leading-lg: 24px;
            --leading-xl: 28px;
            --leading-2xl: 32px;

            /* Spacing Scale */
            --space-1: 4px;
            --space-2: 8px;
            --space-3: 12px;
            --space-4: 16px;
            --space-5: 20px;
            --space-6: 24px;
            --space-8: 32px;
            --space-10: 40px;
            --space-12: 48px;

            /* Shadows */
            --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.04);
            --shadow-md: 0 4px 8px rgba(0, 0, 0, 0.06);
            --shadow-lg: 0 8px 24px rgba(0, 0, 0, 0.08);
            --shadow-xl: 0 16px 48px rgba(0, 0, 0, 0.12);

            /* Border Radius */
            --radius-sm: 4px;
            --radius-md: 6px;
            --radius-lg: 8px;
            --radius-xl: 12px;
            --radius-full: 9999px;

            /* Animation - Durations */
            --duration-fast: 150ms;
            --duration-normal: 300ms;
            --duration-slow: 500ms;
            --duration-pulse: 2s;
            --duration-shimmer: 2s;
            --duration-flash: 600ms;
            --duration-shake: 500ms;

            /* Animation - Easing */
            --easing-default: ease-out;
            --easing-smooth: ease-in-out;
            --easing-linear: linear;

            /* Layout */
            --sidebar-width: 240px;
            --sidebar-collapsed: 48px;
            --sidebar-mobile: 200px;
            --header-height: 56px;

            /* Z-Index Hierarchy */
            --z-base: 0;
            --z-elevated: 10;
            --z-overlay: 100;
            --z-modal: 1000;
            --z-toast: 2000;

            /* Legacy Timeline Variables (kept for compatibility) */
            --timeline-label-width: 200px;
            --timeline-block-width: 120px;
            --timeline-row-height: 48px;
            --timeline-command-row-height: 28px;
            --timeline-story-color: var(--color-success);
            --timeline-story-in-progress-color: var(--color-warning);

            /* Footer height for split panel layout */
            --footer-height: 32px;
        }

        body {
            font-family: var(--font-sans);
            background: var(--color-bg);
            color: var(--color-text);
            line-height: 1.5;
            margin: 0;
            padding: 0;
            min-height: 100vh;
        }

        /* ==========================================================
           Split Panel Layout (E2-S2)
           Section 1.2 from UI/UX Specification
           ========================================================== */

        .app-layout {
            display: grid;
            grid-template-rows: var(--header-height) 1fr var(--footer-height);
            grid-template-columns: var(--sidebar-width) 1fr;
            grid-template-areas:
                "header header"
                "sidebar main"
                "footer footer";
            min-height: 100vh;
            transition: grid-template-columns var(--duration-normal) var(--easing-default);
        }

        .app-layout.sidebar-collapsed {
            grid-template-columns: var(--sidebar-collapsed) 1fr;
        }

        .app-header {
            grid-area: header;
            background: var(--color-surface);
            border-bottom: 1px solid var(--color-border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 var(--space-6);
            height: var(--header-height);
            z-index: var(--z-elevated);
        }

        .app-header__left {
            display: flex;
            align-items: center;
            gap: var(--space-4);
        }

        .app-header__title {
            font-size: var(--text-xl);
            font-weight: 600;
            color: var(--color-text);
            margin: 0;
        }

        .app-header__controls {
            display: flex;
            align-items: center;
            gap: var(--space-3);
        }

        .app-header__right {
            display: flex;
            align-items: center;
            gap: var(--space-4);
        }

        .header-btn {
            padding: var(--space-2) var(--space-3);
            border: 1px solid var(--color-border);
            background: var(--color-surface);
            border-radius: var(--radius-md);
            font-size: var(--text-sm);
            font-weight: 500;
            color: var(--color-text);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: var(--space-2);
            transition: all var(--duration-fast);
        }

        .header-btn:hover {
            background: var(--color-hover-bg);
            border-color: var(--color-border-hover);
        }

        .header-btn--primary {
            background: var(--color-success);
            border-color: var(--color-success);
            color: white;
        }

        .header-btn--danger {
            background: var(--color-error);
            border-color: var(--color-error);
            color: white;
        }

        .header-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .batch-mode-controls {
            display: flex;
            align-items: center;
            gap: var(--space-2);
            padding: var(--space-1) var(--space-2);
            background: var(--color-bg);
            border-radius: var(--radius-md);
        }

        .batch-mode-controls__label {
            font-size: var(--text-sm);
            color: var(--color-text-secondary);
        }

        .batch-mode-controls__input {
            width: 60px;
            padding: var(--space-1) var(--space-2);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-sm);
            font-size: var(--text-sm);
            font-family: var(--font-mono);
        }

        .connection-indicator {
            display: flex;
            align-items: center;
            gap: var(--space-2);
            cursor: pointer;
            padding: var(--space-1) var(--space-2);
            border-radius: var(--radius-md);
        }

        .connection-indicator:hover {
            background: var(--color-hover-bg);
        }

        .connection-indicator__dot {
            width: 10px;
            height: 10px;
            border-radius: var(--radius-full);
            background: var(--color-pending);
        }

        .connection-indicator__dot--connected {
            background: var(--color-success);
            animation: connection-pulse var(--duration-pulse) var(--easing-smooth) infinite;
        }

        .connection-indicator__dot--disconnected {
            background: var(--color-error);
        }

        .connection-indicator__text {
            font-size: var(--text-xs);
            color: var(--color-text-secondary);
        }

        @keyframes connection-pulse {
            0%, 100% { opacity: 1; box-shadow: 0 0 0 0 rgba(16, 185, 129, 0.4); }
            50% { opacity: 0.8; box-shadow: 0 0 8px 2px rgba(16, 185, 129, 0.2); }
        }

        .batch-sidebar {
            grid-area: sidebar;
            background: var(--color-surface);
            border-right: 1px solid var(--color-border);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            z-index: var(--z-elevated);
        }

        .batch-sidebar__header {
            padding: var(--space-4);
            border-bottom: 1px solid var(--color-border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            min-height: 56px;
        }

        .batch-sidebar__title {
            font-size: var(--text-xs);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--color-text-secondary);
        }

        .batch-sidebar__toggle {
            width: 28px;
            height: 28px;
            border: 1px solid var(--color-border);
            background: var(--color-surface);
            border-radius: var(--radius-sm);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--color-text-secondary);
            transition: all var(--duration-fast);
            flex-shrink: 0;
        }

        .batch-sidebar__toggle:hover {
            background: var(--color-hover-bg);
            border-color: var(--color-border-hover);
        }

        .batch-sidebar__toggle-icon {
            transition: transform var(--duration-normal);
            font-size: var(--text-sm);
        }

        .app-layout.sidebar-collapsed .batch-sidebar__toggle-icon {
            transform: rotate(180deg);
        }

        .batch-sidebar__content {
            flex: 1;
            overflow-y: auto;
            padding: var(--space-2);
        }

        .batch-sidebar__footer {
            padding: var(--space-3);
            border-top: 1px solid var(--color-border);
        }

        .batch-sidebar__load-more {
            width: 100%;
            padding: var(--space-2) var(--space-3);
            background: var(--color-bg);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-md);
            font-size: var(--text-sm);
            color: var(--color-text-secondary);
            cursor: pointer;
        }

        .batch-sidebar__load-more:hover {
            background: var(--color-hover-bg);
        }

        .app-layout.sidebar-collapsed .batch-sidebar__title,
        .app-layout.sidebar-collapsed .batch-sidebar__footer {
            display: none;
        }

        .app-layout.sidebar-collapsed .batch-sidebar__header {
            justify-content: center;
            padding: var(--space-2);
        }

        .batch-item {
            padding: var(--space-3);
            border-radius: var(--radius-md);
            margin-bottom: var(--space-2);
            cursor: pointer;
            border: 1px solid transparent;
            transition: all var(--duration-fast);
            position: relative;
        }

        .batch-item:hover {
            background: var(--color-hover-bg);
        }

        .batch-item--selected {
            background: var(--color-selected-bg);
            border-left: 3px solid var(--color-selected-border);
        }

        .batch-item--running {
            border-color: var(--color-warning);
        }

        .batch-item__header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-1);
        }

        .batch-item__id {
            font-family: var(--font-mono);
            font-size: var(--text-sm);
            font-weight: 600;
            color: var(--color-text);
        }

        .batch-item__status {
            font-size: var(--text-xs);
            color: var(--color-text-secondary);
        }

        .batch-item__stats {
            font-size: var(--text-xs);
            color: var(--color-text-muted);
        }

        .app-layout.sidebar-collapsed .batch-item {
            padding: var(--space-2);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .app-layout.sidebar-collapsed .batch-item__header,
        .app-layout.sidebar-collapsed .batch-item__stats {
            display: none;
        }

        .batch-item__status-icon {
            width: 24px;
            height: 24px;
            border-radius: var(--radius-full);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: var(--text-xs);
        }

        .batch-item__status-icon--running {
            background: rgba(245, 158, 11, 0.2);
            color: var(--color-warning);
        }

        .batch-item__status-icon--completed {
            background: rgba(16, 185, 129, 0.2);
            color: var(--color-success);
        }

        .batch-item__status-icon--failed {
            background: rgba(239, 68, 68, 0.2);
            color: var(--color-error);
        }

        .main-content {
            grid-area: main;
            overflow-y: auto;
            padding: var(--space-5);
            background: var(--color-bg);
        }

        .app-footer {
            grid-area: footer;
            background: var(--color-surface);
            border-top: 1px solid var(--color-border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 var(--space-6);
            height: var(--footer-height);
            font-size: var(--text-xs);
            color: var(--color-text-secondary);
        }

        .app-footer__left {
            display: flex;
            align-items: center;
            gap: var(--space-4);
        }

        .app-footer__right {
            display: flex;
            align-items: center;
            gap: var(--space-4);
        }

        .app-footer__status {
            display: flex;
            align-items: center;
            gap: var(--space-2);
        }

        .app-footer__timestamp {
            font-family: var(--font-mono);
        }

        .mobile-sidebar-toggle {
            display: none;
            padding: var(--space-2);
            background: none;
            border: none;
            cursor: pointer;
            color: var(--color-text-secondary);
        }

        @media (max-width: 1199px) and (min-width: 900px) {
            .app-layout {
                grid-template-columns: var(--sidebar-mobile) 1fr;
            }
            .app-layout.sidebar-collapsed {
                grid-template-columns: var(--sidebar-collapsed) 1fr;
            }
        }

        @media (max-width: 899px) {
            .app-layout {
                grid-template-columns: 1fr;
                grid-template-areas:
                    "header"
                    "main"
                    "footer";
            }

            .mobile-sidebar-toggle {
                display: flex;
            }

            .batch-sidebar {
                position: fixed;
                left: 0;
                top: var(--header-height);
                bottom: var(--footer-height);
                width: var(--sidebar-width);
                transform: translateX(-100%);
                z-index: var(--z-overlay);
                box-shadow: var(--shadow-lg);
                transition: transform var(--duration-normal) var(--easing-default);
            }

            .app-layout.sidebar-open .batch-sidebar {
                transform: translateX(0);
            }

            .sidebar-overlay {
                display: none;
                position: fixed;
                inset: 0;
                background: rgba(0, 0, 0, 0.5);
                z-index: calc(var(--z-overlay) - 1);
            }

            .app-layout.sidebar-open .sidebar-overlay {
                display: block;
            }
        }

        /* Container - Full width layout (Story 5-SR-7) */
        .container {
            margin: 0 auto;
        }

        /* Header - Task 1: Modernized compact header */
        header {
            background: var(--color-surface);
            border-radius: var(--radius-lg);
            padding: var(--space-4) var(--space-6);
            margin-bottom: var(--space-6);
            box-shadow: var(--shadow-sm);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        h1 {
            font-size: 22px;
            font-weight: 600;
            color: var(--color-text);
            margin-bottom: 0;
        }

        .last-updated {
            font-size: var(--text-base);
            color: var(--color-text-secondary);
            display: flex;
            align-items: center;
            gap: var(--space-2);
        }

        .update-dot {
            width: var(--space-2);
            height: var(--space-2);
            border-radius: var(--radius-full);
            background: var(--color-success);
            animation: pulse var(--duration-pulse) infinite;
        }

        .update-dot.inactive {
            background: var(--color-pending);
            animation: none;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Summary Cards */
        .summary-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
            gap: var(--space-4);
            margin-bottom: var(--space-6);
        }

        .card {
            background: var(--color-surface);
            border-radius: var(--radius-lg);
            padding: var(--space-6);
            box-shadow: var(--shadow-sm);
            border: 1px solid var(--color-border);
        }

        .card-label {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--color-text-secondary);
            margin-bottom: var(--space-2);
            font-weight: 600;
        }

        .card-value {
            font-size: 32px;
            font-weight: 700;
            color: var(--color-text);
        }

        .card-subtitle {
            font-size: var(--text-base);
            color: var(--color-text-secondary);
            margin-top: var(--space-1);
        }

        /* Section Headers */
        .section {
            margin-bottom: var(--space-6);
        }

        .section-title {
            font-size: var(--text-xl);
            font-weight: 600;
            color: var(--color-text);
            margin-bottom: var(--space-4);
            padding-left: var(--space-1);
        }

        /* Epic Board (Kanban) */
        .epic-board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: var(--space-4);
            margin-bottom: var(--space-6);
        }

        .epic-column {
            background: var(--color-surface);
            border-radius: var(--radius-lg);
            padding: var(--space-4);
            border: 1px solid var(--color-border);
            min-height: 200px;
        }

        .epic-column-header {
            font-size: var(--text-base);
            font-weight: 600;
            color: var(--color-text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: var(--space-3);
            padding-bottom: var(--space-2);
            border-bottom: 2px solid var(--color-border);
        }

        .epic-card {
            background: var(--color-bg);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-md);
            padding: var(--space-3);
            margin-bottom: var(--space-2);
            cursor: pointer;
            transition: all var(--duration-fast) var(--easing-default);
        }

        .epic-card:hover {
            box-shadow: var(--shadow-md);
            transform: translateY(-1px);
        }

        /* Task 2: Expandable Epic Cards */
        .epic-card-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        .epic-card-title {
            font-size: var(--text-base);
            font-weight: 600;
            color: var(--color-text);
            margin-bottom: var(--space-1);
        }

        .epic-expand-icon {
            font-size: 10px;
            color: var(--color-text-secondary);
            transition: transform var(--duration-fast) var(--easing-default);
            cursor: pointer;
        }

        .epic-card.expanded .epic-expand-icon {
            transform: rotate(90deg);
        }

        .epic-card-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-1);
        }

        .epic-card-progress {
            font-size: 12px;
            color: var(--color-text-secondary);
        }

        .epic-card-duration {
            font-size: var(--text-xs);
            font-weight: 500;
            color: #065f46;
            background: var(--color-cmd-dev-story-bg);
            padding: 2px 6px;
            border-radius: var(--radius-sm);
        }

        .epic-card-progress-bar {
            width: 100%;
            height: var(--space-1);
            background: var(--color-border);
            border-radius: 2px;
            margin-top: var(--space-1);
            overflow: hidden;
        }

        .epic-card-progress-fill {
            height: 100%;
            background: var(--color-success);
            border-radius: 2px;
            transition: width var(--duration-normal) var(--easing-default);
        }

        .epic-stories-list {
            margin-top: var(--space-3);
            padding-top: var(--space-3);
            border-top: 1px solid var(--color-border);
        }

        .epic-story-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--space-1) 0;
            font-size: var(--text-sm);
            color: var(--color-text);
            cursor: pointer;
        }

        .epic-story-item:hover {
            background: var(--color-hover-bg);
            margin: 0 calc(-1 * var(--space-2));
            padding: var(--space-1) var(--space-2);
            border-radius: var(--radius-sm);
        }

        .epic-story-item .story-name {
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .epic-story-item .badge {
            flex-shrink: 0;
            margin-left: var(--space-2);
            font-size: 10px;
            padding: 2px 6px;
        }

        /* Story Tooltip */
        .story-tooltip {
            position: fixed;
            background: var(--color-text);
            color: var(--color-surface);
            padding: var(--space-2) var(--space-3);
            border-radius: var(--radius-md);
            font-size: 12px;
            max-width: 300px;
            z-index: var(--z-modal);
            pointer-events: none;
            box-shadow: var(--shadow-lg);
            opacity: 0;
            transition: opacity var(--duration-fast) var(--easing-default);
        }

        .story-tooltip.visible {
            opacity: 1;
        }

        /* Story Table */
        .table-container {
            background: var(--color-surface);
            border-radius: var(--radius-lg);
            border: 1px solid var(--color-border);
            overflow: hidden;
            margin-bottom: var(--space-6);
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        thead {
            background: var(--color-bg);
            border-bottom: 1px solid var(--color-border);
        }

        th {
            text-align: left;
            padding: var(--space-3) var(--space-4);
            font-size: 12px;
            font-weight: 600;
            color: var(--color-text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        td {
            padding: var(--space-3) var(--space-4);
            border-top: 1px solid var(--color-border);
            font-size: var(--text-base);
        }

        tr:hover {
            background: var(--color-bg);
        }

        .story-id {
            font-family: var(--font-mono);
            font-size: var(--text-sm);
            color: var(--color-text-secondary);
        }

        .story-duration {
            font-family: var(--font-mono);
            font-size: 12px;
            color: var(--color-text-secondary);
        }

        /* Status Badges */
        .badge {
            display: inline-block;
            padding: var(--space-1) 10px;
            border-radius: var(--radius-xl);
            font-size: 12px;
            font-weight: 500;
            text-transform: capitalize;
        }

        .badge-backlog {
            background: var(--color-border);
            color: var(--color-text-secondary);
        }

        .badge-ready-for-dev {
            background: var(--color-cmd-create-story-bg);
            color: var(--color-selected-text);
        }

        .badge-in-progress {
            background: var(--color-cmd-story-review-bg);
            color: #92400e;
        }

        .badge-review {
            background: var(--color-cmd-code-review-bg);
            color: #6b21a8;
        }

        .badge-done {
            background: var(--color-cmd-dev-story-bg);
            color: #065f46;
        }

        .badge-optional {
            background: #f3f4f6;
            color: var(--color-text-muted);
            font-style: italic;
        }

        /* Activity Log */
        .activity-log {
            background: var(--color-surface);
            border-radius: var(--radius-lg);
            border: 1px solid var(--color-border);
            padding: var(--space-6);
        }

        .activity-item {
            border-left: 3px solid var(--color-border);
            padding-left: var(--space-4);
            margin-bottom: var(--space-6);
            padding-bottom: var(--space-4);
        }

        .activity-item:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
        }

        .activity-item.completed {
            border-left-color: var(--color-success);
        }

        .activity-item.in-progress {
            border-left-color: var(--color-warning);
        }

        .activity-item.collapsed .activity-body {
            display: none;
        }

        .activity-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-2);
            cursor: pointer;
            user-select: none;
        }

        .activity-header:hover {
            opacity: 0.8;
        }

        .activity-title-row {
            display: flex;
            align-items: center;
            gap: var(--space-2);
        }

        .activity-toggle {
            width: var(--space-5);
            height: var(--space-5);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--color-text-secondary);
            transition: transform var(--duration-fast);
        }

        .activity-item.collapsed .activity-toggle {
            transform: rotate(-90deg);
        }

        .activity-story {
            font-size: var(--text-lg);
            font-weight: 600;
            color: var(--color-text);
        }

        .activity-badge {
            font-size: var(--text-xs);
            padding: 2px var(--space-2);
            border-radius: 10px;
            background: var(--color-cmd-dev-story-bg);
            color: #065f46;
        }

        .activity-item.in-progress .activity-badge {
            background: var(--color-cmd-story-review-bg);
            color: #92400e;
        }

        .activity-meta-right {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 2px;
        }

        .activity-duration {
            font-size: 12px;
            font-weight: 600;
            color: var(--color-text);
            background: var(--color-border);
            padding: 2px var(--space-2);
            border-radius: var(--radius-sm);
        }

        .activity-date {
            font-size: 12px;
            color: var(--color-text-secondary);
        }

        .activity-body {
            padding-top: var(--space-1);
        }

        .activity-meta {
            font-size: var(--text-sm);
            color: var(--color-text-secondary);
            margin-bottom: var(--space-3);
        }

        .activity-description {
            font-size: var(--text-sm);
            color: #5a5a58;
            margin-bottom: var(--space-3);
            line-height: 1.5;
            font-style: italic;
        }

        .activity-steps {
            background: var(--color-bg);
            border-radius: var(--radius-md);
            padding: var(--space-3);
            overflow-x: auto;
        }

        .activity-steps table {
            min-width: 600px;
        }

        .activity-steps th,
        .activity-steps td {
            padding: var(--space-2) var(--space-3);
            font-size: var(--text-sm);
        }

        .activity-steps thead {
            background: transparent;
        }

        .step-result {
            font-size: 12px;
        }

        .step-duration {
            font-family: var(--font-mono);
            font-size: var(--text-xs);
            color: var(--color-text-secondary);
        }

        /* Command/Task Hierarchy Styles */
        .command-group {
            border: 1px solid var(--color-border);
            border-radius: var(--radius-md);
            margin-bottom: var(--space-2);
            background: var(--color-bg);
            overflow: hidden;
        }

        .command-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px var(--space-3);
            cursor: pointer;
            user-select: none;
            transition: background var(--duration-fast) var(--easing-default);
        }

        .command-header:hover {
            background: var(--color-hover-bg);
        }

        .command-header-left {
            display: flex;
            align-items: center;
            gap: var(--space-2);
        }

        .command-toggle {
            width: var(--space-4);
            height: var(--space-4);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--color-text-secondary);
            transition: transform var(--duration-fast) var(--easing-default);
        }

        .command-group.collapsed .command-toggle {
            transform: rotate(-90deg);
        }

        .command-name {
            font-size: var(--text-sm);
            font-weight: 600;
            color: var(--color-text);
        }

        .command-duration {
            font-size: 12px;
            font-weight: 500;
            color: #065f46;
            background: var(--color-cmd-dev-story-bg);
            padding: 2px var(--space-2);
            border-radius: var(--radius-sm);
            font-family: var(--font-mono);
        }

        /* Simplified command row for single-task commands (no expand toggle) */
        .command-header-simple {
            display: flex;
            align-items: center;
            gap: var(--space-3);
            padding: 10px var(--space-3);
        }

        .command-header-simple .command-name {
            flex: 1;
        }

        .command-header-simple .task-status {
            font-size: var(--text-base);
        }

        .command-group.single-task {
            background: transparent;
        }

        .command-tasks {
            border-top: 1px solid var(--color-border);
            padding: var(--space-2) 0;
        }

        .command-group.collapsed .command-tasks {
            display: none;
        }

        .task-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--space-1) var(--space-3) var(--space-1) var(--space-8);
            font-size: var(--text-sm);
        }

        .task-item:hover {
            background: var(--color-hover-bg);
        }

        .task-item-left {
            display: flex;
            align-items: center;
            gap: var(--space-2);
        }

        .task-prefix {
            color: #a8a8a8;
            font-size: var(--text-xs);
        }

        .task-name {
            color: var(--color-text);
        }

        .task-item-right {
            display: flex;
            align-items: center;
            gap: var(--space-2);
        }

        .task-duration {
            font-size: 12px;
            color: var(--color-text-secondary);
            font-family: var(--font-mono);
        }

        .task-status {
            font-size: var(--text-xs);
        }

        .task-status.completed {
            color: var(--color-success);
        }

        .task-status.in-progress {
            color: var(--color-warning);
        }

        .task-in-progress {
            background: linear-gradient(
                90deg,
                var(--color-cmd-story-review-bg) 0%,
                #fde68a 50%,
                var(--color-cmd-story-review-bg) 100%
            );
            background-size: 200% 100%;
            animation: shimmer var(--duration-shimmer) infinite var(--easing-linear);
        }

        @keyframes shimmer {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }

        /* In-progress stripe pattern for timeline bars */
        .timeline-bar.in-progress-stripe,
        .command-bar.in-progress-stripe,
        .task-bar.in-progress {
            background: repeating-linear-gradient(
                45deg,
                var(--color-warning),
                var(--color-warning) 10px,
                #f59e0b 10px,
                #f59e0b 20px
            );
            animation: stripe-scroll 1s var(--easing-linear) infinite;
        }

        @keyframes stripe-scroll {
            0% { background-position: 0 0; }
            100% { background-position: 28px 0; }
        }

        /* Task bar in timeline */
        .task-bar {
            position: absolute;
            height: 14px;
            top: 7px;
            border-radius: 2px;
            display: flex;
            align-items: center;
            padding: 0 var(--space-1);
            font-size: 9px;
            font-weight: 500;
            color: var(--color-surface);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            min-width: var(--space-5);
            background: #6b7280;
        }

        .task-bar.completed {
            background: var(--color-success);
        }

        /* Timeline task rows */
        .timeline-task-row {
            display: flex;
            height: var(--space-6);
            border-top: 1px dotted var(--color-border);
        }

        .timeline-task-row-label {
            width: var(--timeline-label-width);
            min-width: var(--timeline-label-width);
            padding: 0 var(--space-3) 0 36px;
            font-size: var(--text-xs);
            color: var(--color-text-muted);
            display: flex;
            align-items: center;
            background: var(--color-bg);
            border-right: 1px solid var(--color-border);
            position: sticky;
            left: 0;
            z-index: var(--z-elevated);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .timeline-task-row-content {
            flex-shrink: 0;
            position: relative;
            height: var(--space-6);
        }

        /* Timeline command group (for expand/collapse) */
        .timeline-command-group {
            /* Default expanded */
        }

        .timeline-command-group.collapsed .timeline-tasks-container {
            display: none;
        }

        .timeline-command-group .cmd-expand-icon {
            display: inline-block;
            width: var(--space-3);
            font-size: 8px;
            color: var(--color-text-muted);
            transition: transform var(--duration-fast) var(--easing-default);
            margin-right: var(--space-1);
            cursor: pointer;
        }

        .timeline-command-group.collapsed .cmd-expand-icon {
            transform: rotate(-90deg);
        }

        .timeline-command-group:not(.collapsed) .cmd-expand-icon {
            transform: rotate(90deg);
        }

        /* Timeline message row */
        .timeline-message-row {
            display: flex;
            height: var(--space-5);
        }

        .timeline-message-label {
            width: var(--timeline-label-width);
            min-width: var(--timeline-label-width);
            background: var(--color-bg);
            border-right: 1px solid var(--color-border);
            position: sticky;
            left: 0;
            z-index: var(--z-elevated);
        }

        .timeline-message-content {
            flex-shrink: 0;
            position: relative;
            height: var(--space-5);
            display: flex;
            align-items: center;
        }

        .timeline-message-text {
            font-size: 10px;
            color: var(--color-text-secondary);
            font-style: italic;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 300px;
            padding-left: var(--space-1);
        }

        /* Task message in activity log */
        .task-message {
            font-size: var(--text-xs);
            color: var(--color-text-secondary);
            font-style: italic;
            padding: 2px var(--space-3) var(--space-1) 44px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Filters */
        .filters {
            display: flex;
            gap: var(--space-3);
            margin-bottom: var(--space-4);
            padding: var(--space-4);
            background: var(--color-surface);
            border-radius: var(--radius-lg);
            border: 1px solid var(--color-border);
        }

        .filter-group {
            display: flex;
            align-items: center;
            gap: var(--space-2);
        }

        .filter-label {
            font-size: var(--text-sm);
            font-weight: 500;
            color: var(--color-text-secondary);
        }

        select {
            padding: var(--space-1) var(--space-3);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-md);
            font-size: var(--text-sm);
            background: var(--color-surface);
            color: var(--color-text);
            font-family: inherit;
            cursor: pointer;
        }

        select:focus {
            outline: none;
            border-color: var(--color-running);
        }

        /* Empty State */
        .empty-state {
            text-align: center;
            padding: var(--space-10);
            color: var(--color-text-secondary);
            font-size: var(--text-base);
        }

        .dashboard-content {
            display: none;
        }

        .dashboard-content.visible {
            display: block;
        }

        /* Tab Navigation */
        .tab-nav {
            display: flex;
            gap: var(--space-1);
            background: var(--color-surface);
            padding: var(--space-1);
            border-radius: 10px;
            margin-bottom: var(--space-6);
            border: 1px solid var(--color-border);
        }

        .tab-btn {
            flex: 1;
            padding: var(--space-3) var(--space-6);
            border: none;
            background: transparent;
            font-size: var(--text-base);
            font-weight: 500;
            color: var(--color-text-secondary);
            cursor: pointer;
            border-radius: var(--radius-md);
            transition: all var(--duration-fast);
        }

        .tab-btn:hover {
            background: var(--color-bg);
            color: var(--color-text);
        }

        .tab-btn.active {
            background: var(--color-text);
            color: var(--color-surface);
        }

        .tab-btn .tab-count {
            display: inline-block;
            margin-left: var(--space-1);
            padding: 2px var(--space-2);
            background: rgba(0,0,0,0.1);
            border-radius: 10px;
            font-size: 12px;
        }

        .tab-btn.active .tab-count {
            background: rgba(255,255,255,0.2);
        }

        /* Tab Panels */
        .tab-panel {
            display: none;
        }

        .tab-panel.active {
            display: block;
        }

        /* ============================================================
           TIMELINE STYLES - REDESIGNED
           ============================================================ */
        .timeline-panel {
            position: relative;
        }

        .timeline-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: white;
            border: 1px solid #e8e7e5;
            border-radius: 8px 8px 0 0;
            border-bottom: none;
            height: 48px;
            gap: 16px;
        }

        .timeline-zoom {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .zoom-btn {
            width: 28px;
            height: 28px;
            border: 1px solid #e8e7e5;
            background: white;
            border-radius: 4px;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.15s ease;
        }

        .zoom-btn:hover {
            background: #f7f6f3;
        }

        .zoom-btn:focus {
            outline: 2px solid #3b82f6;
            outline-offset: 1px;
        }

        .zoom-level {
            font-size: 13px;
            font-weight: 500;
            color: #787774;
            min-width: 50px;
            text-align: center;
        }

        /* Visibility button group */
        .timeline-visibility-btns {
            display: flex;
            gap: 6px;
        }

        .visibility-btn {
            padding: 4px 10px;
            font-size: 12px;
            font-weight: 500;
            border: 1px solid #e8e7e5;
            border-radius: 4px;
            background: white;
            color: #787774;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .visibility-btn:hover {
            background: #f7f6f3;
            color: #37352f;
            border-color: #d1d0ce;
        }

        .visibility-btn:focus {
            outline: 2px solid #3b82f6;
            outline-offset: 1px;
        }

        /* Block size input group */
        .timeline-block-size {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .timeline-block-size label {
            font-size: 13px;
            color: #787774;
        }

        .timeline-block-size input {
            width: 60px;
            padding: 4px 8px;
            border: 1px solid #e8e7e5;
            border-radius: 4px;
            font-size: 13px;
            text-align: center;
        }

        .timeline-block-size input:focus {
            outline: none;
            border-color: #3b82f6;
        }

        .timeline-block-size span {
            font-size: 13px;
            color: #787774;
        }

        /* Scrollable Timeline Container */
        .timeline-scroll-container {
            background: white;
            border: 1px solid #e8e7e5;
            border-radius: 0 0 8px 8px;
            overflow-x: auto;
            overflow-y: visible;
            position: relative;
        }

        /* Vertical cursor line for alignment visualization */
        .timeline-cursor-line {
            position: absolute;
            top: 0;
            width: 1px;
            height: 10000px;
            background: rgba(239, 68, 68, 0.5);
            pointer-events: none;
            z-index: 100;
            display: none;
        }

        /* Time Header (sticky top) */
        .timeline-header {
            display: flex;
            border-bottom: 1px solid #e8e7e5;
            background: #fafaf9;
            position: sticky;
            top: 0;
            z-index: 20;
            height: 32px;
        }

        /* Resizable label column header */
        .timeline-label-spacer {
            width: var(--timeline-label-width);
            min-width: var(--timeline-label-width);
            flex-shrink: 0;
            background: #fafaf9;
            border-right: 1px solid #e8e7e5;
            position: sticky;
            left: 0;
            z-index: 25;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 12px;
            font-size: 12px;
            font-weight: 600;
            color: #787774;
        }

        /* Drag handle for resizing */
        .timeline-resize-handle {
            position: absolute;
            top: 0;
            right: 0;
            width: 6px;
            height: 100%;
            cursor: col-resize;
            background: transparent;
            transition: background 0.15s ease;
            z-index: 30;
        }

        .timeline-resize-handle:hover,
        .timeline-resize-handle.active {
            background: #3b82f6;
        }

        .timeline-hours {
            display: flex;
            flex: 1;
        }

        .timeline-hour {
            min-width: 60px;
            padding: 8px 4px;
            text-align: right;
            padding-right: 8px;
            font-size: 11px;
            font-weight: 600;
            color: #787774;
            border-right: 1px solid #e8e7e5;
            flex-shrink: 0;
            line-height: 16px;
        }

        /* Timeline Body */
        .timeline-body {
            position: relative;
            min-height: 200px;
        }

        /* Grid Lines */
        .timeline-grid {
            position: absolute;
            top: 0;
            left: var(--timeline-label-width);
            right: 0;
            bottom: 0;
            display: flex;
            pointer-events: none;
            z-index: 1;
        }

        .timeline-grid-line {
            min-width: 60px;
            border-right: 1px solid #e8e7e5;
            flex-shrink: 0;
            opacity: 0.5;
        }

        .timeline-grid-line.quarter {
            border-right: 1px dashed #e8e7e5;
        }

        /* Compact gap indicator - small width, subtle pattern */
        .timeline-hour.compact {
            min-width: 20px;
            width: 20px;
            padding: 8px 2px;
            background: repeating-linear-gradient(
                45deg,
                transparent,
                transparent 3px,
                #f0efed 3px,
                #f0efed 6px
            );
            color: transparent;
            overflow: hidden;
        }

        .timeline-grid-line.compact {
            min-width: 20px;
            width: 20px;
            background: #f7f6f3;
            border-right: 1px dashed #d1d0ce;
        }

        /* Story Rows Container */
        .timeline-rows {
            position: relative;
            z-index: 5;
        }

        /* Story Row */
        .timeline-row {
            display: flex;
            flex-direction: column;
            min-height: var(--timeline-row-height);
            position: relative;
            border-bottom: 1px solid #f0efed;
        }

        .timeline-row.expanded {
            min-height: auto;
        }

        /* Hidden story row styling - shown at bottom with muted appearance */
        .timeline-row.hidden-story {
            opacity: 0.5;
            background: #f7f6f3;
        }

        .timeline-row.hidden-story .timeline-row-label {
            background: #f7f6f3;
        }

        .timeline-row.hidden-story .timeline-row-label:hover {
            background: #efeeec;
        }

        /* Row main content (label + bar area) */
        .timeline-row-main {
            display: flex;
            height: var(--timeline-row-height);
            min-height: var(--timeline-row-height);
        }

        /* Row Label (Sticky Left) - CLICKABLE for expand */
        .timeline-row-label {
            width: var(--timeline-label-width);
            min-width: var(--timeline-label-width);
            padding: 0 12px;
            flex-shrink: 0;
            position: sticky;
            left: 0;
            background: white;
            z-index: 10;
            border-right: 1px solid #e8e7e5;
            display: flex;
            flex-direction: row;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            user-select: none;
            transition: background 0.15s ease;
        }

        .timeline-row-label:hover {
            background: #f7f6f3;
        }

        .label-title {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            font-size: 13px;
            font-weight: 500;
            color: #37352f;
        }

        .label-duration {
            flex-shrink: 0;
            margin-left: 8px;
            font-size: 11px;
            font-weight: 400;
            color: #787774;
            font-family: 'SF Mono', Monaco, monospace;
        }

        /* Story visibility checkbox */
        .story-visibility-checkbox {
            width: 14px;
            height: 14px;
            margin-right: 6px;
            cursor: pointer;
            accent-color: #10b981;
            flex-shrink: 0;
        }

        /* Expand indicator in label */
        .label-expand-icon {
            flex-shrink: 0;
            margin-right: 8px;
            font-size: 10px;
            color: #787774;
            transition: transform 0.2s ease;
        }

        .timeline-row.expanded .label-expand-icon {
            transform: rotate(90deg);
        }

        /* Row Content Area */
        .timeline-row-content {
            flex-shrink: 0;
            position: relative;
            height: var(--timeline-row-height);
            min-height: var(--timeline-row-height);
        }

        /* Story Bar - NOT clickable for expand anymore */
        .timeline-bar {
            position: absolute;
            height: 24px;
            top: 12px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            padding: 0 8px;
            font-size: 11px;
            font-weight: 500;
            color: white;
            white-space: nowrap;
            overflow: hidden;
            min-width: 40px;
            z-index: 5;
        }

        /* Story bars - ONE consistent color */
        .timeline-bar.story-bar {
            background: var(--timeline-story-color);
        }

        .timeline-bar.story-bar.in-progress {
            background: var(--timeline-story-in-progress-color);
            color: #37352f;
        }

        .bar-label {
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Command Rows Container (shown when expanded) */
        .timeline-command-rows {
            display: none;
            flex-direction: column;
            width: 100%;
        }

        .timeline-row.expanded .timeline-command-rows {
            display: flex;
        }

        /* Individual command row */
        .timeline-command-row {
            display: flex;
            height: var(--timeline-command-row-height);
            border-top: 1px dashed #e8e7e5;
        }

        .timeline-command-row-label {
            width: var(--timeline-label-width);
            min-width: var(--timeline-label-width);
            padding: 0 12px 0 24px;
            font-size: 12px;
            color: #787774;
            display: flex;
            align-items: center;
            background: #fafaf9;
            border-right: 1px solid #e8e7e5;
            position: sticky;
            left: 0;
            z-index: 10;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .timeline-command-row-content {
            flex-shrink: 0;
            position: relative;
            height: var(--timeline-command-row-height);
        }

        /* Command Bar - Different colors per type */
        .command-bar {
            position: absolute;
            height: 18px;
            top: 5px;
            border-radius: 3px;
            display: flex;
            align-items: center;
            padding: 0 6px;
            font-size: 10px;
            font-weight: 500;
            color: white;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            min-width: 30px;
        }

        /* Command Type Colors */
        .command-bar.create-story { background: #3b82f6; }
        .command-bar.story-review { background: #f59e0b; color: #37352f; }
        .command-bar.create-tech-spec { background: #6366f1; }
        .command-bar.tech-spec-review { background: #8b5cf6; }
        .command-bar.dev-story { background: #22c55e; }
        .command-bar.code-review { background: #a855f7; }
        .command-bar.default { background: #6b7280; }

        .command-label {
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Timeline Tooltip */
        .timeline-tooltip {
            position: fixed;
            background: #37352f;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            max-width: 280px;
            z-index: 1000;
            pointer-events: none;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            opacity: 0;
            transition: opacity 0.15s ease;
            line-height: 1.4;
        }

        .timeline-tooltip.visible {
            opacity: 1;
        }

        .timeline-tooltip-title {
            font-weight: 600;
            margin-bottom: 4px;
            word-break: break-word;
        }

        .timeline-tooltip-meta {
            color: #a8a8a8;
        }

        /* Empty State */
        .timeline-empty {
            text-align: center;
            padding: 60px 20px;
            color: #787774;
            font-size: 14px;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .epic-board {
                grid-template-columns: 1fr;
            }

            .summary-cards {
                grid-template-columns: 1fr;
            }

            .table-container {
                overflow-x: auto;
            }

            table {
                min-width: 600px;
            }
        }

        /* Milestone display styles */
        .step-milestones {
            margin-top: 6px;
            font-size: 0.75rem;
            line-height: 1.4;
        }

        .milestone {
            display: inline-block;
            background: #e8e8e5;
            color: #555;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
            margin: 2px 0;
        }

        .milestone-arrow {
            color: #999;
            margin: 0 4px;
            font-size: 10px;
        }

        .step-name {
            font-size: 0.85rem;
            color: #555;
            max-width: 150px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* Dark mode support */
        @media (prefers-color-scheme: dark) {
            .milestone {
                background: #3a3a3a;
                color: #ccc;
            }
            .milestone-arrow {
                color: #666;
            }
        }

        /* ============================================================
           SPRINT RUN TAB STYLES (Story 5-SR-6)
           ============================================================ */

        /* Control Panel */
        .sprint-controls {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 16px;
            background: white;
            border-radius: 8px;
            margin-bottom: 16px;
            border: 1px solid #e8e7e5;
            flex-wrap: wrap;
        }

        .sprint-controls-row {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .sprint-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .sprint-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .sprint-btn.start {
            background: #10b981;
            color: white;
        }

        .sprint-btn.start:hover:not(:disabled) {
            background: #059669;
        }

        .sprint-btn.stop {
            background: #ef4444;
            color: white;
        }

        .sprint-btn.stop:hover:not(:disabled) {
            background: #dc2626;
        }

        .batch-size-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .batch-size-group label {
            font-size: 13px;
            color: #787774;
            font-weight: 500;
        }

        .batch-size-input {
            width: 60px;
            padding: 8px 10px;
            border: 1px solid #e8e7e5;
            border-radius: 6px;
            font-size: 14px;
            text-align: center;
        }

        .batch-size-input:focus {
            outline: none;
            border-color: #3b82f6;
        }

        .batch-size-input:disabled {
            background: #f7f6f3;
            color: #9ca3af;
        }

        .run-all-group {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .run-all-group input[type="checkbox"] {
            width: 16px;
            height: 16px;
            accent-color: #10b981;
            cursor: pointer;
        }

        .run-all-group label {
            font-size: 13px;
            color: #787774;
            cursor: pointer;
        }

        /* Status Display */
        .sprint-status {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 4px;
            min-width: 200px;
        }

        .sprint-status-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .sprint-status-label {
            font-size: 12px;
            color: #787774;
            min-width: 60px;
        }

        .sprint-status-value {
            font-size: 14px;
            font-weight: 500;
            color: #37352f;
        }

        .sprint-status-value.idle {
            color: #9ca3af;
        }

        .sprint-status-value.running {
            color: #10b981;
        }

        .sprint-status-value.stopping {
            color: #f59e0b;
        }

        .sprint-status-value.error {
            color: #ef4444;
        }

        /* Progress Section */
        .sprint-progress {
            background: white;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
            border: 1px solid #e8e7e5;
        }

        .sprint-progress-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .sprint-progress-title {
            font-size: 14px;
            font-weight: 600;
            color: #37352f;
        }

        .sprint-progress-stats {
            font-size: 13px;
            color: #787774;
        }

        .sprint-progress-bar {
            width: 100%;
            height: 8px;
            background: #e8e7e5;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 12px;
        }

        .sprint-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #10b981 0%, #34d399 100%);
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        .sprint-active-stories {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .sprint-story-badge {
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 500;
            background: #e8e7e5;
            color: #787774;
        }

        .sprint-story-badge.in-progress {
            background: #fef3c7;
            color: #92400e;
        }

        .sprint-story-badge.done {
            background: #d1fae5;
            color: #065f46;
        }

        /* Event Log */
        .sprint-log {
            background: #1a1a2e;
            color: #e0e0e0;
            font-family: 'SF Mono', Monaco, 'Courier New', monospace;
            font-size: 12px;
            padding: 16px;
            border-radius: 8px;
            max-height: 500px;
            overflow-y: auto;
            border: 1px solid #2a2a4e;
        }

        .sprint-log-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 12px;
            border-bottom: 1px solid #2a2a4e;
            margin-bottom: 12px;
        }

        .sprint-log-title {
            font-size: 14px;
            font-weight: 600;
            color: white;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        .sprint-log-actions {
            display: flex;
            gap: 8px;
        }

        .sprint-log-btn {
            padding: 4px 8px;
            font-size: 11px;
            background: rgba(255,255,255,0.1);
            border: none;
            border-radius: 4px;
            color: #a0a0a0;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .sprint-log-btn:hover {
            background: rgba(255,255,255,0.2);
            color: white;
        }

        .sprint-log-entries {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .log-entry {
            padding: 6px 10px;
            border-radius: 4px;
            display: flex;
            gap: 12px;
            line-height: 1.4;
        }

        .log-entry.start {
            background: rgba(59, 130, 246, 0.15);
            border-left: 3px solid #3b82f6;
        }

        .log-entry.progress {
            background: rgba(251, 191, 36, 0.1);
            border-left: 3px solid #fbbf24;
        }

        .log-entry.end {
            background: rgba(16, 185, 129, 0.15);
            border-left: 3px solid #10b981;
        }

        .log-entry.error {
            background: rgba(239, 68, 68, 0.2);
            border-left: 3px solid #ef4444;
        }

        .log-entry.system {
            background: rgba(139, 92, 246, 0.15);
            border-left: 3px solid #8b5cf6;
        }

        .log-timestamp {
            color: #6b7280;
            flex-shrink: 0;
            width: 70px;
        }

        .log-story-key {
            color: #60a5fa;
            flex-shrink: 0;
            min-width: 80px;
        }

        .log-command {
            color: #c084fc;
            flex-shrink: 0;
            min-width: 100px;
        }

        .log-task-id {
            color: #9ca3af;
            flex-shrink: 0;
            min-width: 80px;
        }

        .log-status {
            font-weight: 600;
            flex-shrink: 0;
            min-width: 60px;
        }

        .log-status.start { color: #3b82f6; }
        .log-status.progress { color: #fbbf24; }
        .log-status.end { color: #10b981; }
        .log-status.error { color: #ef4444; }

        .log-message {
            color: #d1d5db;
            flex: 1;
            word-break: break-word;
        }

        .log-empty {
            color: #6b7280;
            text-align: center;
            padding: 40px;
            font-style: italic;
        }

        /* Connection Status */
        .ws-connection-status {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            color: #787774;
        }

        .ws-connection-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #9ca3af;
        }

        .ws-connection-dot.connected {
            background: #10b981;
            animation: pulse 2s infinite;
        }

        .ws-connection-dot.disconnected {
            background: #ef4444;
        }

        .ws-connection-dot.connecting {
            background: #9ca3af;
            animation: spin 1s linear infinite;
        }

        .ws-connection-dot.reconnecting {
            background: #f59e0b;
            animation: blink 1s step-end infinite;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }

        .ws-connection-status {
            cursor: pointer;
        }

        .ws-connection-status:hover {
            opacity: 0.8;
        }

        .ws-connection-status[title] {
            position: relative;
        }

        /* ============================================================
           Real-time Update Animations (Epic 6 - UI/UX Spec Section 3)
           ============================================================ */

        /* Running Operation: Pulse Glow (Section 3.2) */
        .operation-running {
            animation: pulse-glow 2s ease-in-out infinite;
        }

        @keyframes pulse-glow {
            0%, 100% {
                box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.4);
                border-color: rgba(59, 130, 246, 0.5);
            }
            50% {
                box-shadow: 0 0 16px 4px rgba(59, 130, 246, 0.15);
                border-color: rgba(59, 130, 246, 0.8);
            }
        }

        /* Progress Bar: Shimmer Effect (Section 3.3) */
        .progress-active {
            background: linear-gradient(
                90deg,
                #3b82f6 0%,
                #60a5fa 50%,
                #3b82f6 100%
            );
            background-size: 200% 100%;
            animation: progress-shimmer 2s linear infinite;
        }

        @keyframes progress-shimmer {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }

        /* Completion: Success Flash (Section 3.4) */
        .just-completed {
            animation: complete-flash 600ms ease-out forwards;
        }

        @keyframes complete-flash {
            0% {
                background-color: transparent;
                transform: scale(1);
            }
            30% {
                background-color: rgba(16, 185, 129, 0.2);
                transform: scale(1.01);
            }
            100% {
                background-color: transparent;
                transform: scale(1);
            }
        }

        /* Error: Shake Effect (Section 3.5) */
        .error-shake {
            animation: shake 500ms ease-out;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            20%, 60% { transform: translateX(-3px); }
            40%, 80% { transform: translateX(3px); }
        }

        /* New Item: Slide In (Section 3.1) */
        .new-item-slide {
            animation: new-item-slide 300ms ease-out;
        }

        @keyframes new-item-slide {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* ---------------------------------------------------------
           E4-S3: Expand/Collapse Transitions (Section 3.6)
           --------------------------------------------------------- */

        /* Expandable content container */
        .expandable-content {
            overflow: hidden;
            transition: max-height var(--duration-normal) var(--easing-default),
                        opacity var(--duration-normal) var(--easing-default),
                        padding var(--duration-normal) var(--easing-default);
        }

        .expandable-content.collapsed {
            max-height: 0;
            opacity: 0;
            padding-top: 0;
            padding-bottom: 0;
        }

        .expandable-content.expanded {
            max-height: 2000px; /* Large enough for content */
            opacity: 1;
        }

        /* Chevron rotation for expand/collapse indicators */
        .expand-chevron {
            transition: transform var(--duration-normal) var(--easing-default);
            display: inline-block;
        }

        .expand-chevron.rotated,
        .expanded .expand-chevron {
            transform: rotate(90deg);
        }

        /* Story card expand/collapse animation */
        .story-card {
            transition: background-color var(--duration-fast) var(--easing-default);
        }

        .story-card-content {
            overflow: hidden;
            transition: max-height var(--duration-normal) var(--easing-default),
                        opacity var(--duration-normal) var(--easing-default);
        }

        .story-card.collapsed .story-card-content {
            max-height: 0;
            opacity: 0;
        }

        .story-card.expanded .story-card-content {
            max-height: 2000px;
            opacity: 1;
        }

        /* Command group expand/collapse (enhanced existing) */
        .command-group .command-tasks {
            transition: max-height var(--duration-normal) var(--easing-default),
                        opacity var(--duration-fast) var(--easing-default);
        }

        /* ---------------------------------------------------------
           Status Change Transitions
           --------------------------------------------------------- */

        /* Status badge transition */
        .badge,
        .status-badge {
            transition: background-color var(--duration-normal) var(--easing-default),
                        color var(--duration-normal) var(--easing-default),
                        border-color var(--duration-normal) var(--easing-default);
        }

        /* Status change highlight animation */
        .status-changed {
            animation: status-highlight var(--duration-flash) var(--easing-default);
        }

        @keyframes status-highlight {
            0% {
                background-color: inherit;
            }
            30% {
                background-color: rgba(59, 130, 246, 0.15);
            }
            100% {
                background-color: inherit;
            }
        }

        /* Story row status transition */
        .story-row,
        .epic-story-item {
            transition: background-color var(--duration-fast) var(--easing-default),
                        border-color var(--duration-fast) var(--easing-default);
        }

        /* Command row status transition */
        .command-row,
        .task-item {
            transition: background-color var(--duration-fast) var(--easing-default);
        }

        /* ---------------------------------------------------------
           Running Indicator Animation (Enhanced)
           --------------------------------------------------------- */

        .running-indicator {
            animation: running-pulse 1.5s var(--easing-smooth) infinite;
        }

        @keyframes running-pulse {
            0%, 100% {
                transform: scale(1);
                opacity: 1;
            }
            50% {
                transform: scale(1.2);
                opacity: 0.7;
            }
        }

        /* Running dot in sidebar batch items */
        .running-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--color-warning);
            animation: running-pulse 1.5s var(--easing-smooth) infinite;
        }

        /* ---------------------------------------------------------
           Log Entry Animation
           --------------------------------------------------------- */

        .log-entry {
            transition: background-color var(--duration-fast) var(--easing-default);
        }

        .log-entry.new-entry {
            animation: log-entry-appear var(--duration-normal) var(--easing-default);
        }

        @keyframes log-entry-appear {
            from {
                opacity: 0;
                transform: translateX(-10px);
                background-color: rgba(59, 130, 246, 0.1);
            }
            to {
                opacity: 1;
                transform: translateX(0);
                background-color: transparent;
            }
        }

        /* Error log entry animation */
        .log-entry.error.new-entry {
            animation: log-entry-error var(--duration-normal) var(--easing-default);
        }

        @keyframes log-entry-error {
            from {
                opacity: 0;
                transform: translateX(-10px);
                background-color: rgba(239, 68, 68, 0.15);
            }
            to {
                opacity: 1;
                transform: translateX(0);
                background-color: transparent;
            }
        }

        /* ---------------------------------------------------------
           Progress Bar Animations (Enhanced)
           --------------------------------------------------------- */

        /* Determinate progress bar with smooth transition */
        .progress-bar-fill,
        .epic-card-progress-fill {
            transition: width var(--duration-normal) var(--easing-default);
        }

        /* Indeterminate progress bar for unlimited mode */
        .progress-indeterminate {
            background: linear-gradient(
                90deg,
                transparent 0%,
                var(--color-running) 50%,
                transparent 100%
            );
            background-size: 200% 100%;
            animation: indeterminate-progress 1.5s var(--easing-linear) infinite;
        }

        @keyframes indeterminate-progress {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }

        /* ---------------------------------------------------------
           Card and Panel Transitions
           --------------------------------------------------------- */

        .card,
        .epic-card,
        .activity-item {
            transition: box-shadow var(--duration-fast) var(--easing-default),
                        transform var(--duration-fast) var(--easing-default);
        }

        /* ---------------------------------------------------------
           Sidebar Transitions
           --------------------------------------------------------- */

        .batch-sidebar {
            transition: width var(--duration-normal) var(--easing-default);
        }

        .batch-sidebar.collapsed {
            width: var(--sidebar-collapsed);
        }

        .batch-sidebar-item {
            transition: background-color var(--duration-fast) var(--easing-default),
                        border-color var(--duration-fast) var(--easing-default);
        }

        .batch-sidebar-item:hover {
            background-color: var(--color-hover-bg);
        }

        .batch-sidebar-item.selected {
            border-left: 3px solid var(--color-selected-border);
            background-color: var(--color-selected-bg);
        }

        /* ---------------------------------------------------------
           E4-S4: Reduced Motion Support (Section 3.7) - Enhanced
           --------------------------------------------------------- */

        @media (prefers-reduced-motion: reduce) {
            *,
            *::before,
            *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
                scroll-behavior: auto !important;
            }

            /* Ensure static states for all animated elements */
            .operation-running,
            .progress-active,
            .just-completed,
            .error-shake,
            .running-indicator,
            .running-dot,
            .ws-connection-dot.connected,
            .ws-connection-dot.connecting,
            .ws-connection-dot.reconnecting,
            .progress-indeterminate,
            .new-item-slide,
            .log-entry.new-entry,
            .status-changed,
            .task-in-progress {
                animation: none !important;
            }

            /* Disable transitions for expandable content */
            .expandable-content,
            .story-card-content,
            .command-tasks,
            .expand-chevron,
            .badge,
            .status-badge,
            .progress-bar-fill,
            .epic-card-progress-fill,
            .card,
            .epic-card,
            .activity-item,
            .batch-sidebar,
            .batch-sidebar-item,
            .story-row,
            .epic-story-item,
            .command-row,
            .task-item,
            .log-entry {
                transition: none !important;
            }
        }

        /* Active Operation Card Styles */
        .active-operation-card {
            background: var(--color-surface);
            border: 2px solid var(--color-running);
            border-radius: var(--radius-lg);
            padding: var(--space-4);
            margin-bottom: var(--space-3);
        }

        .active-operation-card.operation-running {
            border-color: var(--color-running);
        }

        .active-operation-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-2);
        }

        .active-operation-story {
            font-family: var(--font-mono);
            font-weight: 600;
            font-size: var(--text-base);
            color: var(--color-text);
        }

        .active-operation-timer {
            font-family: var(--font-mono);
            font-size: var(--text-base);
            font-weight: 500;
            color: var(--color-running);
        }

        .active-operation-command {
            display: inline-block;
            padding: 2px 8px;
            border-radius: var(--radius-sm);
            font-size: var(--text-sm);
            font-weight: 500;
            margin-bottom: var(--space-2);
        }

        .active-operation-progress {
            height: 4px;
            background: var(--color-border);
            border-radius: 2px;
            overflow: hidden;
            margin-bottom: var(--space-2);
        }

        .active-operation-progress-fill {
            height: 100%;
            width: 100%;
        }

        .active-operation-message {
            font-size: var(--text-sm);
            color: var(--color-text-secondary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Toast Notifications */
        .toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .toast {
            background: white;
            padding: 12px 16px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            display: flex;
            align-items: center;
            gap: 10px;
            max-width: 400px;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .toast.error {
            border-left: 4px solid #ef4444;
        }

        .toast.success {
            border-left: 4px solid #10b981;
        }

        .toast.warning {
            border-left: 4px solid #f59e0b;
        }

        .toast-icon {
            font-size: 18px;
            flex-shrink: 0;
        }

        .toast-content {
            flex: 1;
        }

        .toast-title {
            font-size: 14px;
            font-weight: 600;
            color: #37352f;
            margin-bottom: 2px;
        }

        .toast-message {
            font-size: 13px;
            color: #787774;
        }

        .toast-close {
            background: none;
            border: none;
            font-size: 18px;
            color: #9ca3af;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }

        .toast-close:hover {
            color: #37352f;
        }

        /* Sprint Run Tab Active Indicator */
        .tab-btn[data-tab="sprintrun"] .tab-count.active {
            background: #10b981;
            color: white;
        }

        /* BATCH HISTORY SIDEBAR (Epic 5) */
        .dashboard-layout { display: flex; gap: var(--space-4); }
        .batch-sidebar { width: var(--sidebar-width); min-width: var(--sidebar-width); background: var(--color-surface); border-radius: var(--radius-lg); border: 1px solid var(--color-border); display: flex; flex-direction: column; max-height: calc(100vh - var(--header-height) - 200px); }
        .batch-sidebar.collapsed { width: var(--sidebar-collapsed); min-width: var(--sidebar-collapsed); }
        .batch-sidebar__header { padding: var(--space-3) var(--space-4); border-bottom: 1px solid var(--color-border); display: flex; justify-content: space-between; align-items: center; }
        .batch-sidebar__title { font-size: var(--text-xs); font-weight: 600; text-transform: uppercase; color: var(--color-text-secondary); }
        .batch-sidebar.collapsed .batch-sidebar__title { display: none; }
        .batch-sidebar__toggle { width: 24px; height: 24px; border: none; background: transparent; cursor: pointer; display: flex; align-items: center; justify-content: center; color: var(--color-text-secondary); border-radius: var(--radius-sm); }
        .batch-sidebar__toggle:hover { background: var(--color-hover-bg); }
        .batch-sidebar.collapsed .batch-sidebar__toggle-icon { transform: rotate(180deg); }
        .batch-sidebar__list { flex: 1; overflow-y: auto; padding: var(--space-2); }
        .batch-sidebar__item { padding: var(--space-3); border-radius: var(--radius-md); cursor: pointer; margin-bottom: var(--space-1); border-left: 3px solid transparent; position: relative; }
        .batch-sidebar__item:hover { background: var(--color-hover-bg); }
        .batch-sidebar__item--selected { background: var(--color-selected-bg); border-left-color: var(--color-selected-border); }
        .batch-sidebar__item--current { position: sticky; top: 0; background: var(--color-surface); z-index: 1; border-bottom: 1px solid var(--color-border); margin-bottom: var(--space-2); }
        .batch-sidebar__item--current::after { content: 'CURRENT'; position: absolute; top: var(--space-1); right: var(--space-2); font-size: 9px; font-weight: 600; color: var(--color-running); background: var(--color-cmd-create-story-bg); padding: 1px 4px; border-radius: var(--radius-sm); }
        .batch-sidebar__item-header { display: flex; align-items: center; gap: var(--space-2); margin-bottom: var(--space-1); }
        .batch-sidebar__status-dot { width: 8px; height: 8px; border-radius: var(--radius-full); }
        .batch-sidebar__status-dot--running { background: var(--color-warning); animation: pulse var(--duration-pulse) infinite; }
        .batch-sidebar__status-dot--completed { background: var(--color-success); }
        .batch-sidebar__status-dot--stopped, .batch-sidebar__status-dot--failed { background: var(--color-error); }
        .batch-sidebar__batch-id { font-family: var(--font-mono); font-size: var(--text-sm); font-weight: 600; }
        .batch-sidebar__status-label { font-size: var(--text-xs); color: var(--color-text-secondary); text-transform: capitalize; }
        .batch-sidebar__stats { font-size: var(--text-xs); color: var(--color-text-muted); margin-bottom: var(--space-1); }
        .batch-sidebar__duration { font-size: var(--text-xs); font-family: var(--font-mono); color: var(--color-text-secondary); }
        .batch-sidebar.collapsed .batch-sidebar__item { padding: var(--space-2); display: flex; align-items: center; justify-content: center; }
        .batch-sidebar.collapsed .batch-sidebar__item-header, .batch-sidebar.collapsed .batch-sidebar__stats, .batch-sidebar.collapsed .batch-sidebar__duration, .batch-sidebar.collapsed .batch-sidebar__item--current::after { display: none; }
        .batch-sidebar.collapsed .batch-sidebar__status-dot { width: 12px; height: 12px; }
        .batch-sidebar__footer { padding: var(--space-3); border-top: 1px solid var(--color-border); display: flex; justify-content: center; }
        .batch-sidebar.collapsed .batch-sidebar__footer { display: none; }
        .batch-sidebar__load-more { width: 100%; padding: var(--space-2) var(--space-3); border: 1px solid var(--color-border); border-radius: var(--radius-md); background: transparent; color: var(--color-text-secondary); font-size: var(--text-sm); cursor: pointer; }
        .batch-sidebar__load-more:hover { background: var(--color-hover-bg); }
        .batch-sidebar__load-more:disabled { opacity: 0.5; cursor: not-allowed; }
        .batch-sidebar__loading, .batch-sidebar__empty { text-align: center; padding: var(--space-4); color: var(--color-text-muted); font-size: var(--text-sm); }
        .dashboard-main { flex: 1; min-width: 0; }
        .past-batch-header { background: var(--color-surface); border-radius: var(--radius-lg); padding: var(--space-4) var(--space-6); margin-bottom: var(--space-4); border: 1px solid var(--color-border); display: flex; align-items: center; gap: var(--space-4); }
        .past-batch-header__back { display: flex; align-items: center; gap: var(--space-2); padding: var(--space-2) var(--space-3); border: 1px solid var(--color-border); border-radius: var(--radius-md); background: transparent; color: var(--color-text); font-size: var(--text-sm); cursor: pointer; }
        .past-batch-header__back:hover { background: var(--color-hover-bg); }
        .past-batch-header__info { flex: 1; }
        .past-batch-header__title { font-size: var(--text-xl); font-weight: 600; font-family: var(--font-mono); margin-bottom: var(--space-1); }
        .past-batch-header__meta { font-size: var(--text-sm); color: var(--color-text-secondary); }
        .past-batch-header__status { display: inline-block; padding: var(--space-1) var(--space-3); border-radius: var(--radius-xl); font-size: var(--text-sm); font-weight: 500; text-transform: capitalize; }
        .past-batch-header__status--completed { background: var(--color-cmd-dev-story-bg); color: #065f46; }
        .past-batch-header__status--stopped, .past-batch-header__status--failed { background: #fee2e2; color: #991b1b; }
        .batch-summary-stats { display: grid; grid-template-columns: repeat(4, 1fr); gap: var(--space-3); margin-bottom: var(--space-4); }
        .batch-summary-stat { background: var(--color-surface); border-radius: var(--radius-md); padding: var(--space-3) var(--space-4); border: 1px solid var(--color-border); text-align: center; }
        .batch-summary-stat__value { font-size: var(--text-xl); font-weight: 600; }
        .batch-summary-stat__label { font-size: var(--text-xs); color: var(--color-text-secondary); text-transform: uppercase; margin-top: var(--space-1); }
        .past-batch-stories { background: var(--color-surface); border-radius: var(--radius-lg); border: 1px solid var(--color-border); overflow: hidden; }
        .past-batch-stories__header { padding: var(--space-3) var(--space-4); border-bottom: 1px solid var(--color-border); font-size: var(--text-sm); font-weight: 600; color: var(--color-text-secondary); text-transform: uppercase; background: var(--color-bg); }
        .past-batch-story { padding: var(--space-3) var(--space-4); border-bottom: 1px solid var(--color-border); display: flex; align-items: center; gap: var(--space-3); }
        .past-batch-story:last-child { border-bottom: none; }
        .past-batch-story__key { font-family: var(--font-mono); font-size: var(--text-sm); font-weight: 500; min-width: 80px; }
        .past-batch-story__epic { font-size: var(--text-xs); color: var(--color-text-muted); min-width: 50px; }
        .past-batch-story__status { flex: 1; }
        .past-batch-story__duration { font-family: var(--font-mono); font-size: var(--text-xs); color: var(--color-text-secondary); }
        .past-batch-story__commands { font-size: var(--text-xs); color: var(--color-text-muted); }
        @media (max-width: 900px) { .batch-sidebar { position: fixed; left: 0; top: var(--header-height); height: calc(100vh - var(--header-height)); max-height: none; border-radius: 0; transform: translateX(-100%); z-index: var(--z-overlay); } .batch-sidebar.open { transform: translateX(0); } .batch-summary-stats { grid-template-columns: repeat(2, 1fr); } }

        /* COMPONENT SYSTEM (Epic 3) - Reusable Components */
        /* Batch Card Component */
        .batch-card { padding: var(--space-3) var(--space-4); cursor: pointer; border-left: 3px solid transparent; transition: all var(--duration-fast) var(--easing-default); }
        .batch-card:hover { background: var(--color-hover-bg); }
        .batch-card--selected { background: var(--color-selected-bg); border-left-color: var(--color-selected-border); }
        .batch-card--current { border-top: 1px solid var(--color-border); border-bottom: 1px solid var(--color-border); margin-bottom: var(--space-2); }
        .batch-card__header { display: flex; align-items: center; gap: var(--space-2); margin-bottom: var(--space-1); }
        .batch-card__status-icon { width: 10px; height: 10px; border-radius: var(--radius-full); flex-shrink: 0; }
        .batch-card__status-icon--running { background: var(--color-warning); animation: pulse var(--duration-pulse) var(--easing-smooth) infinite; }
        .batch-card__status-icon--completed { background: var(--color-success); }
        .batch-card__status-icon--failed { background: var(--color-error); }
        .batch-card__status-icon--stopped { background: var(--color-pending); }
        .batch-card__id { font-family: var(--font-mono); font-size: var(--text-base); font-weight: 600; color: var(--color-text); }
        .batch-card__label { font-size: var(--text-sm); color: var(--color-text-secondary); margin-bottom: var(--space-1); }
        .batch-card__stats { font-size: var(--text-xs); color: var(--color-text-muted); }
        .batch-card__duration { font-family: var(--font-mono); font-size: var(--text-xs); color: var(--color-text-secondary); margin-top: var(--space-1); }

        /* Story Card Component (expandable) */
        .story-card { border-bottom: 1px solid var(--color-border); }
        .story-card:last-child { border-bottom: none; }
        .story-card__header { display: flex; align-items: center; padding: var(--space-3) var(--space-4); cursor: pointer; transition: background var(--duration-fast) var(--easing-default); user-select: none; }
        .story-card__header:hover { background: var(--color-hover-bg); }
        .story-card__chevron { width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; color: var(--color-text-secondary); font-size: 10px; transition: transform var(--duration-fast) var(--easing-default); flex-shrink: 0; }
        .story-card--expanded .story-card__chevron { transform: rotate(90deg); }
        .story-card__key { font-family: var(--font-mono); font-size: var(--text-base); font-weight: 500; color: var(--color-text); margin-right: var(--space-3); flex-shrink: 0; }
        .story-card__title { flex: 1; font-size: var(--text-base); color: var(--color-text); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; margin-right: var(--space-3); }
        .story-card__duration { font-family: var(--font-mono); font-size: var(--text-sm); color: var(--color-text-secondary); flex-shrink: 0; margin-left: auto; padding-left: var(--space-3); }
        .story-card__content { overflow: hidden; transition: max-height var(--duration-normal) var(--easing-default), opacity var(--duration-normal) var(--easing-default); max-height: 0; opacity: 0; }
        .story-card--expanded .story-card__content { max-height: 2000px; opacity: 1; }
        .story-card__commands { padding: 0 var(--space-4) var(--space-3); padding-left: calc(var(--space-4) + 20px); }

        /* Command Group Component (expandable) */
        .command-group-v2 { border: 1px solid var(--color-border); border-radius: var(--radius-md); margin-bottom: var(--space-2); background: var(--color-bg); overflow: hidden; }
        .command-group-v2:last-child { margin-bottom: 0; }
        .command-group-v2__header { display: flex; align-items: center; padding: var(--space-2) var(--space-3); cursor: pointer; transition: background var(--duration-fast) var(--easing-default); user-select: none; }
        .command-group-v2__header:hover { background: var(--color-hover-bg); }
        .command-group-v2__chevron { width: 16px; height: 16px; display: flex; align-items: center; justify-content: center; color: var(--color-text-secondary); font-size: 8px; transition: transform var(--duration-fast) var(--easing-default); flex-shrink: 0; margin-right: var(--space-2); }
        .command-group-v2--expanded .command-group-v2__chevron { transform: rotate(90deg); }
        .command-group-v2__duration { font-family: var(--font-mono); font-size: var(--text-sm); color: var(--color-text-secondary); margin-left: auto; padding-left: var(--space-3); }
        .command-group-v2__tasks { border-top: 1px solid var(--color-border); overflow: hidden; transition: max-height var(--duration-normal) var(--easing-default), opacity var(--duration-normal) var(--easing-default); max-height: 0; opacity: 0; }
        .command-group-v2--expanded .command-group-v2__tasks { max-height: 1000px; opacity: 1; }

        /* Task Row Component */
        .task-row-v2 { display: flex; align-items: center; padding: var(--space-2) var(--space-3); padding-left: calc(var(--space-3) + 16px); font-size: var(--text-sm); border-bottom: 1px solid var(--color-border); }
        .task-row-v2:last-child { border-bottom: none; }
        .task-row-v2:hover { background: var(--color-hover-bg); }
        .task-row-v2__name { flex: 1; color: var(--color-text); }
        .task-row-v2__duration { font-family: var(--font-mono); font-size: var(--text-xs); color: var(--color-text-secondary); margin-right: var(--space-3); }
        .task-row-v2__message { font-size: var(--text-xs); color: var(--color-text-muted); font-style: italic; max-width: 200px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

        /* Status Badge Component */
        .status-badge-v2 { display: inline-flex; align-items: center; padding: var(--space-1) var(--space-2); border-radius: var(--radius-full); font-size: var(--text-xs); font-weight: 500; gap: var(--space-1); }
        .status-badge-v2__icon { width: 8px; height: 8px; border-radius: var(--radius-full); flex-shrink: 0; }
        .status-badge-v2--running { background: rgba(59, 130, 246, 0.15); color: var(--color-running); }
        .status-badge-v2--running .status-badge-v2__icon { background: var(--color-running); animation: pulse var(--duration-pulse) var(--easing-smooth) infinite; }
        .status-badge-v2--success, .status-badge-v2--done, .status-badge-v2--completed { background: rgba(16, 185, 129, 0.15); color: var(--color-success); }
        .status-badge-v2--success .status-badge-v2__icon, .status-badge-v2--done .status-badge-v2__icon, .status-badge-v2--completed .status-badge-v2__icon { background: var(--color-success); }
        .status-badge-v2--error, .status-badge-v2--failed { background: rgba(239, 68, 68, 0.15); color: var(--color-error); }
        .status-badge-v2--error .status-badge-v2__icon, .status-badge-v2--failed .status-badge-v2__icon { background: var(--color-error); }
        .status-badge-v2--warning, .status-badge-v2--in-progress { background: rgba(245, 158, 11, 0.15); color: #b45309; }
        .status-badge-v2--warning .status-badge-v2__icon, .status-badge-v2--in-progress .status-badge-v2__icon { background: var(--color-warning); animation: pulse var(--duration-pulse) var(--easing-smooth) infinite; }
        .status-badge-v2--pending, .status-badge-v2--stopped { background: rgba(156, 163, 175, 0.15); color: var(--color-pending); }
        .status-badge-v2--pending .status-badge-v2__icon, .status-badge-v2--stopped .status-badge-v2__icon { background: var(--color-pending); }

        /* Command Badge Component */
        .command-badge { display: inline-flex; align-items: center; padding: 2px var(--space-2); border-radius: var(--radius-sm); font-size: var(--text-xs); font-weight: 500; text-transform: uppercase; letter-spacing: 0.25px; white-space: nowrap; }
        .command-badge--create-story { background: var(--color-cmd-create-story-bg); color: var(--color-cmd-create-story); }
        .command-badge--story-review { background: var(--color-cmd-story-review-bg); color: #92400e; }
        .command-badge--create-tech-spec { background: var(--color-cmd-create-tech-spec-bg); color: var(--color-cmd-create-tech-spec); }
        .command-badge--tech-spec-review { background: var(--color-cmd-tech-spec-review-bg); color: var(--color-cmd-tech-spec-review); }
        .command-badge--dev-story { background: var(--color-cmd-dev-story-bg); color: #065f46; }
        .command-badge--code-review { background: var(--color-cmd-code-review-bg); color: var(--color-cmd-code-review); }
        .command-badge--commit { background: var(--color-cmd-commit-bg); color: #0f766e; }
        .command-badge--default { background: var(--color-border); color: var(--color-text-secondary); }
        .command-badge--solid { color: white; }
        .command-badge--solid.command-badge--create-story { background: var(--color-cmd-create-story); }
        .command-badge--solid.command-badge--story-review { background: var(--color-cmd-story-review); color: var(--color-text); }
        .command-badge--solid.command-badge--create-tech-spec { background: var(--color-cmd-create-tech-spec); }
        .command-badge--solid.command-badge--tech-spec-review { background: var(--color-cmd-tech-spec-review); }
        .command-badge--solid.command-badge--dev-story { background: var(--color-cmd-dev-story); }
        .command-badge--solid.command-badge--code-review { background: var(--color-cmd-code-review); }
        .command-badge--solid.command-badge--commit { background: var(--color-cmd-commit); }

        /* Progress Bar Component */
        .progress-bar-v2 { width: 100%; height: 8px; background: var(--color-border); border-radius: var(--radius-full); overflow: hidden; position: relative; }
        .progress-bar-v2--thin { height: 4px; }
        .progress-bar-v2--thick { height: 12px; }
        .progress-bar-v2__fill { height: 100%; border-radius: var(--radius-full); transition: width var(--duration-normal) var(--easing-default); }
        .progress-bar-v2__fill--success { background: linear-gradient(90deg, var(--color-success) 0%, #34d399 100%); }
        .progress-bar-v2__fill--running { background: var(--color-running); }
        .progress-bar-v2__fill--warning { background: var(--color-warning); }
        .progress-bar-v2__fill--error { background: var(--color-error); }
        .progress-bar-v2--active .progress-bar-v2__fill { background: linear-gradient(90deg, var(--color-running) 0%, var(--color-in-progress) 50%, var(--color-running) 100%); background-size: 200% 100%; animation: shimmer var(--duration-shimmer) var(--easing-linear) infinite; }
        .progress-bar-v2--unlimited .progress-bar-v2__fill { width: 30%; animation: progress-pulse 2s var(--easing-smooth) infinite; }
        @keyframes progress-pulse { 0%, 100% { transform: translateX(0); opacity: 1; } 50% { transform: translateX(230%); opacity: 0.7; } }

        /* Control Button Components */
        .control-btn { display: inline-flex; align-items: center; justify-content: center; gap: var(--space-2); padding: var(--space-2) var(--space-4); border: none; border-radius: var(--radius-md); font-size: var(--text-base); font-weight: 600; cursor: pointer; transition: all var(--duration-fast) var(--easing-default); }
        .control-btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .control-btn--start { background: var(--color-success); color: white; }
        .control-btn--start:hover:not(:disabled) { background: #059669; }
        .control-btn--start:active:not(:disabled) { background: #047857; }
        .control-btn--stop { background: var(--color-error); color: white; }
        .control-btn--stop:hover:not(:disabled) { background: #dc2626; }
        .control-btn--stop:active:not(:disabled) { background: #b91c1c; }
        .control-btn--secondary { background: var(--color-border); color: var(--color-text); }
        .control-btn--secondary:hover:not(:disabled) { background: var(--color-border-hover); }
        .control-btn__icon { font-size: 14px; line-height: 1; }

        /* Operation Card Component */
        .operation-card { background: var(--color-bg); border: 1px solid var(--color-border); border-radius: var(--radius-md); padding: var(--space-3); transition: all var(--duration-fast) var(--easing-default); }
        .operation-card--running { border-color: rgba(59, 130, 246, 0.5); animation: pulse-glow var(--duration-pulse) var(--easing-smooth) infinite; }
        .operation-card__header { display: flex; justify-content: space-between; align-items: center; margin-bottom: var(--space-2); }
        .operation-card__story-key { font-family: var(--font-mono); font-size: var(--text-base); font-weight: 500; color: var(--color-running); cursor: pointer; }
        .operation-card__story-key:hover { text-decoration: underline; }
        .operation-card__timer { font-family: var(--font-mono); font-size: var(--text-base); font-weight: 500; color: var(--color-running); }
        .operation-card__progress { margin-bottom: var(--space-2); }
        .operation-card__progress-bar { width: 100%; height: 6px; background: var(--color-border); border-radius: var(--radius-full); overflow: hidden; }
        .operation-card__progress-fill { height: 100%; background: linear-gradient(90deg, var(--color-running) 0%, var(--color-in-progress) 50%, var(--color-running) 100%); background-size: 200% 100%; animation: shimmer var(--duration-shimmer) var(--easing-linear) infinite; }
        .operation-card__message { font-size: var(--text-sm); color: var(--color-text-secondary); font-style: italic; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

        /* Connection Indicator Component */
        .connection-indicator { display: flex; align-items: center; gap: var(--space-2); padding: var(--space-1) var(--space-2); border-radius: var(--radius-sm); cursor: pointer; transition: background var(--duration-fast) var(--easing-default); }
        .connection-indicator:hover { background: var(--color-hover-bg); }
        .connection-indicator__icon { width: 10px; height: 10px; border-radius: var(--radius-full); flex-shrink: 0; }
        .connection-indicator--connected .connection-indicator__icon { background: var(--color-success); animation: pulse var(--duration-pulse) var(--easing-smooth) infinite; }
        .connection-indicator--connecting .connection-indicator__icon { background: var(--color-pending); animation: spin 1s var(--easing-linear) infinite; border: 2px solid var(--color-pending); border-top-color: transparent; background: transparent; }
        .connection-indicator--reconnecting .connection-indicator__icon { background: var(--color-warning); animation: blink 1s step-end infinite; }
        .connection-indicator--disconnected .connection-indicator__icon { background: var(--color-error); }
        .connection-indicator__text { font-size: var(--text-xs); color: var(--color-text-secondary); }
        @keyframes spin { to { transform: rotate(360deg); } }
        @keyframes blink { 50% { opacity: 0; } }

        /* Animation Classes */
        .new-item-slide { animation: slide-in var(--duration-normal) var(--easing-default); }
        @keyframes slide-in { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }

    </style>
</head>
<body>
    <!-- Toast Container (fixed position) -->
    <div class="toast-container" id="toastContainer"></div>

    <!-- Story Tooltip (global) -->
    <div class="story-tooltip" id="storyTooltip"></div>

    <!-- Split Panel Layout (E2-S2) -->
    <div class="app-layout" id="appLayout">
        <!-- Mobile Sidebar Overlay -->
        <div class="sidebar-overlay" id="sidebarOverlay" onclick="closeMobileSidebar()"></div>

        <!-- App Header - 56px height -->
        <header class="app-header">
            <div class="app-header__left">
                <!-- Mobile sidebar toggle (visible on mobile) -->
                <button class="mobile-sidebar-toggle" onclick="toggleMobileSidebar()" aria-label="Toggle sidebar">
                    <svg width="20" height="20" viewBox="0 0 20 20" fill="currentColor">
                        <path d="M3 5h14M3 10h14M3 15h14" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                    </svg>
                </button>
                <h1 class="app-header__title">Grimoire</h1>
            </div>

            <div class="app-header__controls">
                <button class="header-btn header-btn--primary" id="headerStartBtn">
                    <span>&#9654;</span> Start
                </button>
                <button class="header-btn header-btn--danger" id="headerStopBtn" disabled>
                    <span>&#9632;</span> Stop
                </button>

                <div class="batch-mode-controls">
                    <span class="batch-mode-controls__label">Batch:</span>
                    <input type="number" class="batch-mode-controls__input" id="headerBatchSize" value="2" min="1" max="100">
                    <label class="batch-mode-controls__checkbox">
                        <input type="checkbox" id="headerRunAll">
                        All
                    </label>
                </div>
            </div>

            <div class="app-header__right">
                <div class="connection-indicator" id="connectionIndicator" title="Connection Status">
                    <span class="connection-indicator__dot" id="headerConnectionDot"></span>
                    <span class="connection-indicator__text" id="headerConnectionText">Disconnected</span>
                </div>
            </div>
        </header>

        <!-- Batch History Sidebar - 240px, collapsible to 48px -->
        <aside class="batch-sidebar" id="batchSidebar">
            <div class="batch-sidebar__header">
                <span class="batch-sidebar__title">Batch Runs</span>
                <button class="batch-sidebar__toggle" id="batchSidebarToggle" aria-label="Toggle sidebar">
                    <span class="batch-sidebar__toggle-icon">&laquo;</span>
                </button>
            </div>

            <div class="batch-sidebar__list" id="batchSidebarContent">
                <!-- Batch items will be dynamically populated via JavaScript -->
                <div class="batch-sidebar__loading">Loading batches...</div>
            </div>

            <div class="batch-sidebar__footer">
                <button class="batch-sidebar__load-more" id="loadMoreBatches">Load More...</button>
            </div>
        </aside>

        <!-- Main Content Area -->
        <main class="main-content" id="mainContent">
            <!-- Legacy container wrapper for existing content -->
            <div class="container">
                <!-- Dashboard Content -->
                <div class="dashboard-content" id="dashboardContent">
                    <!-- Last Updated indicator (moved from old header) -->
                    <div class="last-updated" style="margin-bottom: var(--space-4); justify-content: flex-end;">
                        <span class="update-dot" id="updateDot"></span>
                        <span id="lastUpdated">Loading...</span>
                    </div>
            <!-- Summary Cards -->
            <div class="summary-cards">
                <div class="card">
                    <div class="card-label">Total Epics</div>
                    <div class="card-value" id="totalEpics">0</div>
                    <div class="card-subtitle">In-progress: <span id="epicsInProgress">0</span></div>
                </div>
                <div class="card">
                    <div class="card-label">Stories</div>
                    <div class="card-value" id="storiesProgress">0/0</div>
                    <div class="card-subtitle">Completion: <span id="storiesPercent">0%</span></div>
                </div>
                <div class="card">
                    <div class="card-label">Current Story</div>
                    <div class="card-value" style="font-size: 16px; line-height: 1.4;" id="currentStory">-</div>
                    <div class="card-subtitle" id="currentStoryStatus">-</div>
                </div>
            </div>

            <!-- Tab Navigation -->
            <div class="tab-nav">
                <button class="tab-btn active" data-tab="epics">Epics <span class="tab-count" id="epicsCount">0</span></button>
                <button class="tab-btn" data-tab="stories">Stories <span class="tab-count" id="storiesCount">0</span></button>
                <button class="tab-btn" data-tab="activity">Activity <span class="tab-count" id="activityCount">0</span></button>
                <button class="tab-btn" data-tab="timeline">Timeline</button>
                <button class="tab-btn" data-tab="sprintrun">Sprint Run <span class="tab-count" id="sprintrunCount"></span></button>
            </div>

            <!-- Epic Board Tab -->
            <div class="tab-panel active" id="tab-epics">
                <div class="epic-board">
                    <div class="epic-column">
                        <div class="epic-column-header">Backlog</div>
                        <div id="epicsBacklog"></div>
                    </div>
                    <div class="epic-column">
                        <div class="epic-column-header">In Progress</div>
                        <div id="epicsInProgressCol"></div>
                    </div>
                    <div class="epic-column">
                        <div class="epic-column-header">Done</div>
                        <div id="epicsDone"></div>
                    </div>
                </div>
            </div>

            <!-- Stories Tab -->
            <div class="tab-panel" id="tab-stories">
                <div class="filters">
                    <div class="filter-group">
                        <label class="filter-label">Epic:</label>
                        <select id="epicFilter">
                            <option value="all">All Epics</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label class="filter-label">Status:</label>
                        <select id="statusFilter">
                            <option value="all">All Statuses</option>
                            <option value="backlog">Backlog</option>
                            <option value="ready-for-dev">Ready for Dev</option>
                            <option value="in-progress">In Progress</option>
                            <option value="review">Review</option>
                            <option value="done">Done</option>
                        </select>
                    </div>
                </div>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr>
                                <th>Story ID</th>
                                <th>Name</th>
                                <th>Epic</th>
                                <th>Duration</th>
                                <th>Status</th>
                            </tr>
                        </thead>
                        <tbody id="storyTableBody">
                            <tr><td colspan="5" class="empty-state">No stories loaded</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Activity Tab -->
            <div class="tab-panel" id="tab-activity">
                <div class="activity-log" id="activityLog">
                    <div class="empty-state">No activity loaded</div>
                </div>
            </div>

            <!-- Timeline Tab - REDESIGNED -->
            <div class="tab-panel timeline-panel" id="tab-timeline" role="region" aria-label="Project Timeline">
                <!-- Controls Bar -->
                <div class="timeline-controls">
                    <div class="timeline-zoom">
                        <button class="zoom-btn" data-action="out" onclick="zoomTimeline('out')" aria-label="Zoom out">-</button>
                        <span class="zoom-level" id="zoomLevel">100%</span>
                        <button class="zoom-btn" data-action="in" onclick="zoomTimeline('in')" aria-label="Zoom in">+</button>
                    </div>

                    <!-- Visibility buttons -->
                    <div class="timeline-visibility-btns">
                        <button class="visibility-btn" onclick="showAllStories()">Show All</button>
                        <button class="visibility-btn" onclick="hideAllStories()">Hide All</button>
                    </div>

                    <!-- Block size input (minutes) -->
                    <div class="timeline-block-size">
                        <label for="blockSizeInput">Block (min):</label>
                        <input type="number"
                               id="blockSizeInput"
                               min="1"
                               max="480"
                               step="1"
                               value="10"
                               onkeydown="if(event.key==='Enter'){this.blur();}"
                               onblur="setBlockSizeMinutes(this.value)">
                    </div>
                </div>

                <!-- Scrollable Container -->
                <div class="timeline-scroll-container" id="timelineScrollContainer">
                    <!-- Vertical cursor line for alignment -->
                    <div class="timeline-cursor-line" id="timelineCursorLine"></div>

                    <!-- Time Header (sticky top) with resize handle -->
                    <div class="timeline-header" id="timelineHeader">
                        <div class="timeline-label-spacer">
                            <span>Story</span>
                            <div class="timeline-resize-handle" id="resizeHandle"></div>
                        </div>
                        <div class="timeline-hours" id="timelineHours">
                            <!-- Generated time blocks -->
                        </div>
                    </div>

                    <!-- Timeline Body -->
                    <div class="timeline-body" id="timelineBody">
                        <!-- Grid Lines (absolute positioned) -->
                        <div class="timeline-grid" id="timelineGrid"></div>

                        <!-- Story Rows -->
                        <div class="timeline-rows" id="timelineRows">
                            <!-- Generated story rows -->
                        </div>
                    </div>
                </div>

                <!-- Tooltip (positioned absolutely) -->
                <div class="timeline-tooltip" id="timelineTooltip"></div>
            </div>

            <!-- Sprint Run Tab (Story 5-SR-6) -->
            <div class="tab-panel" id="tab-sprintrun">
                <!-- Control Panel -->
                <div class="sprint-controls">
                    <div class="sprint-controls-row">
                        <button class="sprint-btn start" id="sprintStartBtn">
                            <span>&#9654;</span> Start
                        </button>
                        <button class="sprint-btn stop" id="sprintStopBtn" disabled>
                            <span>&#9632;</span> Stop
                        </button>
                    </div>

                    <div class="batch-size-group">
                        <label for="batchSizeInput">Batch Size:</label>
                        <input type="number" id="batchSizeInput" class="batch-size-input" value="2" min="1" max="100">
                    </div>

                    <div class="run-all-group">
                        <input type="checkbox" id="runAllCheckbox">
                        <label for="runAllCheckbox">Run All</label>
                    </div>

                    <div class="sprint-status">
                        <div class="sprint-status-row">
                            <span class="sprint-status-label">Status:</span>
                            <span class="sprint-status-value idle" id="sprintStatusValue">Idle</span>
                        </div>
                        <div class="sprint-status-row">
                            <span class="sprint-status-label">Current:</span>
                            <span class="sprint-status-value" id="sprintCurrentOp">-</span>
                        </div>
                    </div>

                    <div class="ws-connection-status">
                        <span class="ws-connection-dot" id="wsConnectionDot"></span>
                        <span id="wsConnectionText">Disconnected</span>
                    </div>
                </div>

                <!-- Progress Section (Creative Enhancement) -->
                <div class="sprint-progress" id="sprintProgressSection" style="display: none;">
                    <div class="sprint-progress-header">
                        <span class="sprint-progress-title">Cycle Progress</span>
                        <span class="sprint-progress-stats" id="sprintProgressStats">0/0 cycles</span>
                    </div>
                    <div class="sprint-progress-bar">
                        <div class="sprint-progress-fill" id="sprintProgressFill" style="width: 0%;"></div>
                    </div>
                    <div class="sprint-active-stories" id="sprintActiveStories">
                        <!-- Active story badges will be rendered here -->
                    </div>
                </div>

                <!-- Event Log -->
                <div class="sprint-log" id="sprintLog">
                    <div class="sprint-log-header">
                        <span class="sprint-log-title">Event Log</span>
                        <div class="sprint-log-actions">
                            <button class="sprint-log-btn" onclick="clearSprintLog()">Clear</button>
                            <button class="sprint-log-btn" onclick="toggleAutoScroll()">Auto-scroll: <span id="autoScrollState">ON</span></button>
                        </div>
                    </div>
                    <div class="sprint-log-entries" id="sprintLogEntries">
                        <div class="log-empty">No events yet. Start a sprint run to see live events.</div>
                    </div>
                </div>
            </div>
                </div><!-- /.dashboard-content -->
            </div><!-- /.container -->
        </main><!-- /.main-content -->

        <!-- Footer Status Bar - 32px height -->
        <footer class="app-footer">
            <div class="app-footer__left">
                <div class="app-footer__status">
                    <span>Sprint Runner Dashboard</span>
                </div>
            </div>
            <div class="app-footer__right">
                <span class="app-footer__timestamp" id="footerTimestamp">--</span>
            </div>
        </footer>
    </div><!-- /.app-layout -->

    <script>
        // State management
        let state = {
            sprintData: null,
            orchestratorData: null,
            lastUpdateTime: null,
            watchInterval: null,
            isWatching: false,
            autoLoadWorks: false,
            lastDataHash: null
        };

        // ============================================================
        // Split Panel Layout - Sidebar Toggle (E2-S2)
        // ============================================================

        // Sidebar state
        let sidebarState = {
            collapsed: false,
            mobileOpen: false
        };

        // Toggle sidebar collapsed state (desktop)
        function toggleSidebar() {
            const appLayout = document.getElementById('appLayout');
            sidebarState.collapsed = !sidebarState.collapsed;

            if (sidebarState.collapsed) {
                appLayout.classList.add('sidebar-collapsed');
            } else {
                appLayout.classList.remove('sidebar-collapsed');
            }

            // Save to localStorage
            localStorage.setItem('dashboard-sidebar-collapsed', sidebarState.collapsed);
        }

        // Toggle mobile sidebar (overlay mode)
        function toggleMobileSidebar() {
            const appLayout = document.getElementById('appLayout');
            sidebarState.mobileOpen = !sidebarState.mobileOpen;

            if (sidebarState.mobileOpen) {
                appLayout.classList.add('sidebar-open');
            } else {
                appLayout.classList.remove('sidebar-open');
            }
        }

        // Close mobile sidebar
        function closeMobileSidebar() {
            const appLayout = document.getElementById('appLayout');
            sidebarState.mobileOpen = false;
            appLayout.classList.remove('sidebar-open');
        }

        // Restore sidebar state on page load
        function restoreSidebarState() {
            const savedCollapsed = localStorage.getItem('dashboard-sidebar-collapsed');
            if (savedCollapsed === 'true') {
                sidebarState.collapsed = true;
                const appLayout = document.getElementById('appLayout');
                if (appLayout) {
                    appLayout.classList.add('sidebar-collapsed');
                }
            }
        }

        // Initialize sidebar state on DOMContentLoaded
        document.addEventListener('DOMContentLoaded', function() {
            restoreSidebarState();

            // Update footer timestamp
            function updateFooterTimestamp() {
                const footerTimestamp = document.getElementById('footerTimestamp');
                if (footerTimestamp) {
                    footerTimestamp.textContent = new Date().toLocaleTimeString();
                }
            }
            updateFooterTimestamp();
            setInterval(updateFooterTimestamp, 1000);

            // Sync header controls with sprint run tab controls
            const headerStartBtn = document.getElementById('headerStartBtn');
            const headerStopBtn = document.getElementById('headerStopBtn');
            const headerBatchSize = document.getElementById('headerBatchSize');
            const headerRunAll = document.getElementById('headerRunAll');

            // Connect header buttons to existing sprint controls
            if (headerStartBtn) {
                headerStartBtn.addEventListener('click', function() {
                    const sprintStartBtn = document.getElementById('sprintStartBtn');
                    if (sprintStartBtn) sprintStartBtn.click();
                });
            }

            if (headerStopBtn) {
                headerStopBtn.addEventListener('click', function() {
                    const sprintStopBtn = document.getElementById('sprintStopBtn');
                    if (sprintStopBtn) sprintStopBtn.click();
                });
            }

            // Sync batch size input
            if (headerBatchSize) {
                const sprintBatchSize = document.getElementById('batchSizeInput');
                if (sprintBatchSize) {
                    // Sync initial value
                    headerBatchSize.value = sprintBatchSize.value;

                    headerBatchSize.addEventListener('change', function() {
                        sprintBatchSize.value = this.value;
                    });

                    sprintBatchSize.addEventListener('change', function() {
                        headerBatchSize.value = this.value;
                    });
                }
            }

            // Sync run all checkbox
            if (headerRunAll) {
                const sprintRunAll = document.getElementById('runAllCheckbox');
                if (sprintRunAll) {
                    headerRunAll.checked = sprintRunAll.checked;

                    headerRunAll.addEventListener('change', function() {
                        sprintRunAll.checked = this.checked;
                    });

                    sprintRunAll.addEventListener('change', function() {
                        headerRunAll.checked = this.checked;
                    });
                }
            }
        });

        // ============================================================
        // UI State Persistence (Story 5-SR-7)
        // ============================================================
        const UI_STATE_KEYS = {
            ACTIVE_TAB: 'dashboard-active-tab',           // existing
            TIMELINE_WIDTH: 'timeline-label-width',       // existing
            EXPANDED_EPICS: 'dashboard-expanded-epics',   // new: ['epic-1', 'epic-2']
            FILTERS: 'dashboard-filters',                 // new: {epic: 'all', status: 'all'}
            CHECKBOXES: 'dashboard-checkboxes',           // new: (reserved for future checkboxes)
            BATCH_SIZE: 'dashboard-batch-size',           // new: number or 'all'
            SORT_PREFS: 'dashboard-sort-prefs',           // new: {column: 'story', dir: 'asc'}
            SCROLL_POSITIONS: 'dashboard-scroll-positions', // new: {tableContainer: 0, activityLog: 0}
            EXPANDED_ACTIVITIES: 'dashboard-expanded-activities', // new: activity indices to keep expanded
            TIMELINE_EXPANDED_STORIES: 'dashboard-timeline-expanded-stories', // new: timeline story rows
            TIMELINE_HIDDEN_STORIES: 'dashboard-timeline-hidden-stories' // new: hidden stories
        };

        // Save all UI state to localStorage
        function saveUIState() {
            try {
                // Get expanded epic IDs
                const expandedEpics = Array.from(document.querySelectorAll('.epic-card.expanded'))
                    .map(el => el.dataset.epicId)
                    .filter(Boolean);
                localStorage.setItem(UI_STATE_KEYS.EXPANDED_EPICS, JSON.stringify(expandedEpics));

                // Get filter values
                const epicFilter = document.getElementById('epicFilter')?.value || 'all';
                const statusFilter = document.getElementById('statusFilter')?.value || 'all';
                localStorage.setItem(UI_STATE_KEYS.FILTERS, JSON.stringify({ epic: epicFilter, status: statusFilter }));

                // Get batch size (if exists)
                const batchSizeEl = document.getElementById('batchSize');
                if (batchSizeEl) {
                    localStorage.setItem(UI_STATE_KEYS.BATCH_SIZE, batchSizeEl.value);
                }

                // Get scroll positions
                const scrollPositions = {};
                const tableContainer = document.querySelector('.table-container');
                if (tableContainer) scrollPositions.tableContainer = tableContainer.scrollTop;
                const activityLog = document.getElementById('activityLog');
                if (activityLog) scrollPositions.activityLog = activityLog.scrollTop;
                const timelineScroll = document.getElementById('timelineScrollContainer');
                if (timelineScroll) scrollPositions.timelineScroll = timelineScroll.scrollLeft;
                localStorage.setItem(UI_STATE_KEYS.SCROLL_POSITIONS, JSON.stringify(scrollPositions));

                // Get expanded activity items (collapsed is default, track non-collapsed)
                const expandedActivities = Array.from(document.querySelectorAll('.activity-item:not(.collapsed)'))
                    .map((el, idx) => idx)
                    .filter(idx => idx > 0); // First item is expanded by default
                localStorage.setItem(UI_STATE_KEYS.EXPANDED_ACTIVITIES, JSON.stringify(expandedActivities));

                // Save timeline expanded stories
                localStorage.setItem(UI_STATE_KEYS.TIMELINE_EXPANDED_STORIES,
                    JSON.stringify(Array.from(timelineState.expandedStoryIds)));

                // Save timeline hidden stories
                localStorage.setItem(UI_STATE_KEYS.TIMELINE_HIDDEN_STORIES,
                    JSON.stringify(Array.from(timelineState.hiddenStories)));
            } catch (e) {
                console.warn('Failed to save UI state:', e);
            }
        }

        // Restore UI state from localStorage (call before initial render)
        function restoreUIState() {
            try {
                // Restore filters
                const filtersJson = localStorage.getItem(UI_STATE_KEYS.FILTERS);
                if (filtersJson) {
                    const filters = JSON.parse(filtersJson);
                    const epicFilter = document.getElementById('epicFilter');
                    const statusFilter = document.getElementById('statusFilter');
                    if (epicFilter && filters.epic) epicFilter.value = filters.epic;
                    if (statusFilter && filters.status) statusFilter.value = filters.status;
                }

                // Restore batch size
                const batchSize = localStorage.getItem(UI_STATE_KEYS.BATCH_SIZE);
                if (batchSize) {
                    const batchSizeEl = document.getElementById('batchSize');
                    if (batchSizeEl) batchSizeEl.value = batchSize;
                }

                // Restore timeline expanded stories
                const timelineExpandedJson = localStorage.getItem(UI_STATE_KEYS.TIMELINE_EXPANDED_STORIES);
                if (timelineExpandedJson) {
                    const expanded = JSON.parse(timelineExpandedJson);
                    timelineState.expandedStoryIds = new Set(expanded);
                }

                // Restore timeline hidden stories
                const timelineHiddenJson = localStorage.getItem(UI_STATE_KEYS.TIMELINE_HIDDEN_STORIES);
                if (timelineHiddenJson) {
                    const hidden = JSON.parse(timelineHiddenJson);
                    timelineState.hiddenStories = new Set(hidden);
                }
            } catch (e) {
                console.warn('Failed to restore UI state:', e);
            }
        }

        // Restore scroll positions (call after render)
        function restoreScrollPositions() {
            try {
                const scrollJson = localStorage.getItem(UI_STATE_KEYS.SCROLL_POSITIONS);
                if (scrollJson) {
                    const positions = JSON.parse(scrollJson);
                    const tableContainer = document.querySelector('.table-container');
                    if (tableContainer && positions.tableContainer) tableContainer.scrollTop = positions.tableContainer;
                    const activityLog = document.getElementById('activityLog');
                    if (activityLog && positions.activityLog) activityLog.scrollTop = positions.activityLog;
                    const timelineScroll = document.getElementById('timelineScrollContainer');
                    if (timelineScroll && positions.timelineScroll) timelineScroll.scrollLeft = positions.timelineScroll;
                }
            } catch (e) {
                console.warn('Failed to restore scroll positions:', e);
            }
        }

        // Restore expanded epics (call after renderEpicBoard)
        function restoreExpandedEpics() {
            try {
                const expandedJson = localStorage.getItem(UI_STATE_KEYS.EXPANDED_EPICS);
                if (expandedJson) {
                    const expandedIds = JSON.parse(expandedJson);
                    expandedIds.forEach(epicId => {
                        const card = document.querySelector(`.epic-card[data-epic-id="${CSS.escape(epicId)}"]`);
                        if (card && !card.classList.contains('expanded')) {
                            toggleEpicCard(epicId);
                        }
                    });
                }
            } catch (e) {
                console.warn('Failed to restore expanded epics:', e);
            }
        }

        // Restore expanded activities (call after renderActivityLog)
        function restoreExpandedActivities() {
            try {
                const expandedJson = localStorage.getItem(UI_STATE_KEYS.EXPANDED_ACTIVITIES);
                if (expandedJson) {
                    const expandedIndices = JSON.parse(expandedJson);
                    const items = document.querySelectorAll('.activity-item');
                    items.forEach((item, idx) => {
                        if (idx === 0) {
                            // First item should be expanded by default
                            item.classList.remove('collapsed');
                        } else if (expandedIndices.includes(idx)) {
                            item.classList.remove('collapsed');
                        }
                    });
                }
            } catch (e) {
                console.warn('Failed to restore expanded activities:', e);
            }
        }

        // Simple string hash function for change detection
        function hashString(str) {
            let hash = 0;
            if (!str || str.length === 0) return hash;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }
            return hash;
        }

        // Story descriptions cache
        let storyDescriptions = {};

        // ============================================================
        // Security: HTML Escaping Utility
        // ============================================================
        function escapeHtml(text) {
            if (text === null || text === undefined) return '';
            const str = String(text);
            const div = document.createElement('div');
            div.textContent = str;
            return div.innerHTML;
        }

        // Escape for use in JavaScript string literals (prevents XSS in inline handlers)
        function escapeJsString(text) {
            if (text === null || text === undefined) return '';
            return String(text)
                .replace(/\\/g, '\\\\')
                .replace(/'/g, "\\'")
                .replace(/"/g, '\\"')
                .replace(/\n/g, '\\n')
                .replace(/\r/g, '\\r');
        }

        // Normalize status string for CSS class usage
        function normalizeStatusForClass(status) {
            if (!status) return 'backlog';
            return String(status).toLowerCase().trim().replace(/_/g, '-');
        }

        // ============================================================
        // Incremental DOM Update Helpers (Story 5-SR-7)
        // ============================================================

        // Update element content only if changed (prevents flicker)
        function updateElement(selector, newContent) {
            const el = typeof selector === 'string' ? document.querySelector(selector) : selector;
            if (!el) return false;
            if (el.innerHTML !== newContent) {
                el.innerHTML = newContent;
                return true;
            }
            return false;
        }

        // Update text content only if changed
        function updateTextContent(selector, newText) {
            const el = typeof selector === 'string' ? document.querySelector(selector) : selector;
            if (!el) return false;
            if (el.textContent !== newText) {
                el.textContent = newText;
                return true;
            }
            return false;
        }

        // Save scroll position before updates
        function saveScrollPosition(el) {
            if (!el) return { top: 0, left: 0 };
            return { top: el.scrollTop, left: el.scrollLeft };
        }

        // Restore scroll position after updates
        function restoreScrollPosition(el, pos) {
            if (!el || !pos) return;
            el.scrollTop = pos.top;
            el.scrollLeft = pos.left;
        }

        // ============================================================
        // TIMELINE STATE - REDESIGNED
        // ============================================================
        // Fixed column width constant
        const COLUMN_WIDTH_PX = 60;  // Fixed pixel width for all columns (uniform grid)

        let timelineState = {
            zoomLevel: 100,
            labelColumnWidth: 200,
            minLabelWidth: 120,
            maxLabelWidth: 400,
            blockSizeMinutes: 10,
            expandedStoryIds: new Set(),  // Multiple stories can be expanded
            expandedCommands: new Map(),  // Track command expand/collapse state (key -> boolean, default true)
            timelineStartTs: null,
            timelineEndTs: null,
            totalTimelineWidth: 0,  // Continuous timeline width in pixels
            hiddenStories: new Set(),
            processedBlocks: []
        };

        // Column resize state
        let resizeState = {
            isResizing: false,
            startX: 0,
            startWidth: 0
        };

        // Timeline cache
        let timelineCache = {
            data: null,
            dataHash: null,
            hasScrolled: false
        };

        // Command type color mapping
        const COMMAND_COLORS = {
            'create-story': '#3b82f6',
            'story-review': '#f59e0b',
            'create-tech-spec': '#6366f1',
            'tech-spec-review': '#8b5cf6',
            'dev-story': '#22c55e',
            'code-review': '#a855f7'
        };

        // ============================================================
        // Utility Functions
        // ============================================================

        // Format unix timestamp to readable date
        function formatTimestamp(ts) {
            const date = new Date(ts * 1000);
            return date.toLocaleString('en-US', {
                month: 'short',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });
        }

        // Format ISO date string to readable date
        function formatISODate(isoString) {
            if (!isoString) return '';
            try {
                const date = new Date(isoString);
                if (isNaN(date.getTime())) return isoString;
                return date.toLocaleString('en-US', {
                    month: 'short',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });
            } catch (e) {
                return isoString;
            }
        }

        // Format duration in seconds to human readable
        function formatDuration(seconds) {
            if (!seconds || seconds <= 0) return '';
            if (seconds < 60) {
                return `${Math.round(seconds)}s`;
            } else if (seconds < 3600) {
                const mins = Math.floor(seconds / 60);
                const secs = Math.round(seconds % 60);
                return secs > 0 ? `${mins}m ${secs}s` : `${mins}m`;
            } else {
                const hours = Math.floor(seconds / 3600);
                const mins = Math.floor((seconds % 3600) / 60);
                return mins > 0 ? `${hours}h ${mins}m` : `${hours}h`;
            }
        }

        // Parse duration from ~Xm format to minutes
        function parseDurationToMinutes(durationStr) {
            if (!durationStr) return 0;
            const cleaned = String(durationStr).replace(/^~/, '').trim();
            const hourMatch = cleaned.match(/(\d+)h/);
            const minMatch = cleaned.match(/(\d+)m/);
            const secMatch = cleaned.match(/(\d+)s/);

            let minutes = 0;
            if (hourMatch) minutes += parseInt(hourMatch[1], 10) * 60;
            if (minMatch) minutes += parseInt(minMatch[1], 10);
            if (secMatch) minutes += parseInt(secMatch[1], 10) / 60;

            if (!hourMatch && !minMatch && !secMatch) {
                const numMatch = cleaned.match(/(\d+)/);
                if (numMatch) minutes = parseInt(numMatch[1], 10);
            }

            return minutes;
        }

        // Get command CSS class
        function getCommandClass(command) {
            if (!command) return 'default';
            const baseCommand = command.split(' ')[0].split('#')[0].trim();
            return COMMAND_COLORS[baseCommand] ? baseCommand : 'default';
        }

        // ============================================================
        // ORCHESTRATOR PARSERS - 7-COLUMN FORMAT (backward compatible with 6)
        // ============================================================

        // RFC 4180 compliant CSV line parser
        // Handles quoted fields with escaped quotes ("")
        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;

            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                const nextChar = line[i + 1];

                if (inQuotes) {
                    if (char === '"' && nextChar === '"') {
                        current += '"';
                        i++; // Skip escaped quote
                    } else if (char === '"') {
                        inQuotes = false;
                    } else {
                        current += char;
                    }
                } else {
                    if (char === '"') {
                        inQuotes = true;
                    } else if (char === ',') {
                        result.push(current);
                        current = '';
                    } else {
                        current += char;
                    }
                }
            }
            result.push(current);
            return result;
        }

        // Parse orchestrator CSV log
        // Format (7-column): timestamp,epicID,storyID,command,task-id,status,"message"
        // Format (6-column legacy): timestamp,epicID,storyID,command,task-id,status
        // - status = "start" or "end"
        // - Duration calculated by matching start/end pairs
        // - Orphan handling: < 30 min = in-progress, >= 30 min = ignore
        function parseOrchestratorCSV(text) {
            const THIRTY_MINUTES = 30 * 60; // 1800 seconds
            const currentTime = Math.floor(Date.now() / 1000);

            const lines = text.trim().split('\n');
            const startIndex = lines[0].includes('timestamp') || lines[0].includes('unix_timestamp') ? 1 : 0;

            // First pass: collect all entries and match start/end pairs
            // Key format: epicId|storyId|command|taskId
            const pairMap = new Map(); // key -> { start: entry, end: entry, startMessage, endMessage }
            const allEntries = [];

            for (let i = startIndex; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;

                // Use RFC 4180 parser for proper quote handling
                const parts = parseCSVLine(line);
                if (parts.length < 6) continue;

                // 6-column: timestamp,epic,story,cmd,task,status
                // 7-column: timestamp,epic,story,cmd,task,status,message
                const [timestamp, epicId, storyId, command, taskId, status, message = ''] = parts;
                const ts = parseInt(timestamp, 10);
                if (isNaN(ts)) continue;

                const entry = {
                    timestamp: ts,
                    epicId: epicId.startsWith('epic-') ? epicId : `epic-${epicId}`,
                    storyId,
                    command,
                    taskId,
                    status: status.trim().toLowerCase(),
                    message: message.trim()
                };

                allEntries.push(entry);

                // Build pairing key
                const pairKey = `${entry.epicId}|${storyId}|${command}|${taskId}`;

                if (!pairMap.has(pairKey)) {
                    pairMap.set(pairKey, { start: null, end: null, startMessage: '', endMessage: '' });
                }

                const pair = pairMap.get(pairKey);
                if (entry.status === 'start') {
                    pair.start = entry;
                    pair.startMessage = entry.message;
                } else if (entry.status === 'end') {
                    pair.end = entry;
                    pair.endMessage = entry.message;
                }
            }

            // Second pass: build hierarchical structure
            // story -> commands -> tasks
            const storyMap = new Map();

            pairMap.forEach((pair, pairKey) => {
                const startEntry = pair.start;
                const endEntry = pair.end;

                // Must have at least a start entry
                if (!startEntry) return;

                const { epicId, storyId, command, taskId } = startEntry;

                // Handle orphans (start without end)
                if (!endEntry) {
                    const age = currentTime - startEntry.timestamp;
                    const ageMinutes = Math.floor(age / 60);
                    if (age >= THIRTY_MINUTES) {
                        // Stale: ignore this command but continue processing story
                        console.log(`Orphan filtered (stale): ${storyId}/${command} - age ${ageMinutes}m`);
                        return;
                    }
                    console.log(`Orphan kept (fresh): ${storyId}/${command} - age ${ageMinutes}m`);
                    // Fresh: will be shown as in-progress
                }

                // Initialize story if needed
                if (!storyMap.has(storyId)) {
                    storyMap.set(storyId, {
                        storyId,
                        epic: epicId,
                        started: null,
                        completed: null,
                        duration: '',
                        totalDurationSecs: 0,
                        startTs: null,
                        endTs: null,
                        commands: new Map(), // command -> { tasks: [], totalDurationSecs, ... }
                        steps: [] // For timeline compatibility
                    });
                }

                const story = storyMap.get(storyId);

                // Track story timing
                if (!story.startTs || startEntry.timestamp < story.startTs) {
                    story.startTs = startEntry.timestamp;
                    story.started = formatTimestamp(startEntry.timestamp);
                }
                if (endEntry) {
                    if (!story.endTs || endEntry.timestamp > story.endTs) {
                        story.endTs = endEntry.timestamp;
                    }
                }

                // Initialize command group if needed
                if (!story.commands.has(command)) {
                    story.commands.set(command, {
                        command,
                        tasks: [],
                        totalDurationSecs: 0,
                        totalDuration: '',
                        startTs: startEntry.timestamp,
                        endTs: null
                    });
                }

                const cmdGroup = story.commands.get(command);

                // Calculate task duration and status
                let taskDurationSecs = 0;
                let taskStatus = 'in-progress';
                let taskEndTs = null;
                const MAX_IN_PROGRESS_SECS = 30 * 60; // 30 minutes cap

                if (endEntry) {
                    taskDurationSecs = endEntry.timestamp - startEntry.timestamp;
                    taskStatus = 'completed';
                    taskEndTs = endEntry.timestamp;

                    // Update command group end timestamp
                    if (!cmdGroup.endTs || endEntry.timestamp > cmdGroup.endTs) {
                        cmdGroup.endTs = endEntry.timestamp;
                    }
                } else {
                    // In-progress: use current time, capped at 30 minutes
                    const elapsedSecs = currentTime - startEntry.timestamp;
                    taskDurationSecs = Math.min(elapsedSecs, MAX_IN_PROGRESS_SECS);
                    taskEndTs = startEntry.timestamp + taskDurationSecs;

                    // Update command group end timestamp for in-progress
                    if (!cmdGroup.endTs || taskEndTs > cmdGroup.endTs) {
                        cmdGroup.endTs = taskEndTs;
                    }

                    // Also update story end timestamp for in-progress commands
                    // This ensures story bar extends to cover all commands including in-progress ones
                    if (!story.endTs || taskEndTs > story.endTs) {
                        story.endTs = taskEndTs;
                    }
                }

                // Add task to command group (include messages)
                const startMessage = pair.startMessage || '';
                const endMessage = pair.endMessage || '';
                cmdGroup.tasks.push({
                    taskId,
                    startTs: startEntry.timestamp,
                    endTs: taskEndTs,
                    durationSecs: taskDurationSecs,
                    duration: taskDurationSecs > 0 ? formatDuration(taskDurationSecs) : '',
                    status: taskStatus,
                    startMessage,
                    endMessage,
                    // Display message: end message if completed, start message if in-progress
                    message: taskStatus === 'completed' ? endMessage : startMessage
                });

                cmdGroup.totalDurationSecs += taskDurationSecs;
            });

            // Third pass: finalize story data
            const resultArr = Array.from(storyMap.values()).map(story => {
                // Convert commands Map to array and calculate totals
                const commandsArray = [];
                let storyTotalDuration = 0;
                let allTasksCompleted = true;
                let stepNumber = 0;

                story.commands.forEach((cmdGroup, cmdName) => {
                    stepNumber++;

                    // Sort tasks by start time
                    cmdGroup.tasks.sort((a, b) => a.startTs - b.startTs);

                    cmdGroup.totalDuration = formatDuration(cmdGroup.totalDurationSecs);
                    storyTotalDuration += cmdGroup.totalDurationSecs;

                    // Check if any task is in-progress
                    const hasInProgress = cmdGroup.tasks.some(t => t.status === 'in-progress');
                    if (hasInProgress) {
                        allTasksCompleted = false;
                    }

                    commandsArray.push({
                        command: cmdName,
                        tasks: cmdGroup.tasks,
                        totalDurationSecs: cmdGroup.totalDurationSecs,
                        totalDuration: cmdGroup.totalDuration,
                        startTs: cmdGroup.startTs,
                        endTs: cmdGroup.endTs
                    });

                    // Add to steps array for timeline compatibility
                    story.steps.push({
                        stepNumber,
                        stepName: cmdGroup.tasks[0]?.taskId || '',
                        command: cmdName,
                        result: hasInProgress ? 'in-progress' : 'completed',
                        duration: cmdGroup.totalDuration,
                        durationSecs: cmdGroup.totalDurationSecs,
                        startTs: cmdGroup.startTs,
                        endTs: cmdGroup.endTs,
                        tasks: cmdGroup.tasks // Include tasks for timeline task-level bars
                    });
                });

                // Sort commands by start time
                commandsArray.sort((a, b) => a.startTs - b.startTs);
                story.steps.sort((a, b) => a.startTs - b.startTs);

                story.commands = commandsArray;

                // Calculate total duration as last end - first start (wall clock time)
                const MAX_IN_PROGRESS_SECS = 30 * 60; // 30 minutes cap
                if (story.startTs && story.endTs) {
                    story.totalDurationSecs = story.endTs - story.startTs;
                    story.duration = formatDuration(story.totalDurationSecs);
                } else if (story.startTs) {
                    // Still in progress - show time since start, capped at 30 min for timeline
                    const now = Math.floor(Date.now() / 1000);
                    const elapsedSecs = now - story.startTs;
                    story.totalDurationSecs = elapsedSecs; // Display shows actual elapsed
                    story.duration = formatDuration(story.totalDurationSecs);
                    // Set endTs for timeline bar rendering, capped at 30 min
                    story.endTs = story.startTs + Math.min(elapsedSecs, MAX_IN_PROGRESS_SECS);
                } else {
                    story.totalDurationSecs = 0;
                    story.duration = '';
                }

                // Set completed timestamp if all tasks are done
                if (allTasksCompleted && story.endTs) {
                    story.completed = formatTimestamp(story.endTs);
                }

                return story;
            });

            // Sort by start time (most recent first)
            resultArr.sort((a, b) => (b.startTs || 0) - (a.startTs || 0));

            return resultArr;
        }

        // CSV parser wrapper
        function parseOrchestrator(text) {
            if (!text || !text.trim()) {
                return [];
            }
            console.log('Parsing sprint-runner.csv, lines:', text.trim().split('\n').length);
            const result = parseOrchestratorCSV(text);
            console.log('Parsed stories:', result.map(s => `${s.storyId} (${s.commands?.length || 0} cmds, ${s.completed ? 'done' : 'in-progress'})`));
            return result;
        }

        // ============================================================
        // YAML Parser
        // ============================================================

        function parseSprintStatus(text) {
            const data = {
                metadata: {},
                epics: {},
                stories: []
            };

            const lines = text.split('\n');
            let currentEpic = null;

            for (let line of lines) {
                if (line.trim().startsWith('#') || !line.trim()) continue;

                if (line.match(/^(\w+):\s*(.+)$/)) {
                    const [, key, value] = line.match(/^(\w+):\s*(.+)$/);
                    if (!line.startsWith(' ')) {
                        data.metadata[key] = value;
                    }
                }

                if (line.match(/epic-(\w+):\s*([\w-]+)/)) {
                    const [, epicId, status] = line.match(/epic-(\w+):\s*([\w-]+)/);
                    const epicKey = `epic-${epicId}`;
                    currentEpic = epicKey;

                    if (!data.epics[epicKey]) {
                        data.epics[epicKey] = {
                            id: epicKey,
                            name: `Epic ${epicId.toUpperCase()}`,
                            status: status,
                            stories: []
                        };
                    } else {
                        data.epics[epicKey].status = status;
                    }
                }

                if (line.match(/^\s+([a-z0-9-]+):\s*([\w-]+)/) && currentEpic) {
                    const [, storyId, status] = line.match(/^\s+([a-z0-9-]+):\s*([\w-]+)/);

                    if (storyId.includes('retrospective') || storyId.startsWith('epic-')) continue;

                    const story = {
                        id: storyId,
                        name: storyId.split('-').slice(2).join(' ').replace(/-/g, ' '),
                        epic: currentEpic,
                        status: status
                    };

                    data.stories.push(story);
                    if (data.epics[currentEpic]) {
                        data.epics[currentEpic].stories.push(story);
                    }
                }
            }

            return data;
        }

        // ============================================================
        // Story Descriptions
        // ============================================================

        function showStoryTooltip(event, storyId) {
            const tooltip = document.getElementById('storyTooltip');
            const description = storyDescriptions[storyId] || 'No description available';
            tooltip.textContent = description;
            tooltip.style.left = (event.clientX + 10) + 'px';
            tooltip.style.top = (event.clientY + 10) + 'px';
            tooltip.classList.add('visible');
        }

        function hideStoryTooltip() {
            const tooltip = document.getElementById('storyTooltip');
            tooltip.classList.remove('visible');
        }

        async function loadStoryDescriptions() {
            try {
                const response = await fetch('./story-descriptions.json');
                if (response.ok) {
                    storyDescriptions = await response.json();
                    console.log('Loaded story descriptions:', Object.keys(storyDescriptions).length);
                }
            } catch (e) {
                console.log('Story descriptions not available:', e);
            }
        }

        // ============================================================
        // Render Functions
        // ============================================================

        function renderSummaryCards(data) {
            const epics = Object.values(data.epics);
            const totalEpics = epics.filter(e => !e.id.includes('retrospective')).length;
            const epicsInProgress = epics.filter(e => {
                const status = (e.status || '').toLowerCase().trim();
                return status === 'in-progress' || status === 'in_progress' || status === 'inprogress';
            }).length;

            const stories = data.stories.filter(s => !s.id.includes('retrospective'));
            const storiesDone = stories.filter(s => s.status === 'done').length;
            const storiesTotal = stories.length;
            const completionPercent = storiesTotal > 0 ? Math.round((storiesDone / storiesTotal) * 100) : 0;

            const currentStory = stories.find(s => s.status !== 'done' && s.status !== 'backlog');

            document.getElementById('totalEpics').textContent = totalEpics;
            document.getElementById('epicsInProgress').textContent = epicsInProgress;
            document.getElementById('storiesProgress').textContent = `${storiesDone}/${storiesTotal}`;
            document.getElementById('storiesPercent').textContent = `${completionPercent}%`;

            if (currentStory) {
                document.getElementById('currentStory').textContent = currentStory.id;
                const statusClass = normalizeStatusForClass(currentStory.status);
                const safeStatus = escapeHtml(currentStory.status);
                document.getElementById('currentStoryStatus').innerHTML = `<span class="badge badge-${statusClass}">${safeStatus}</span>`;
            } else if (storiesDone === storiesTotal && storiesTotal > 0) {
                document.getElementById('currentStory').textContent = 'All complete!';
                document.getElementById('currentStoryStatus').textContent = '';
            } else {
                document.getElementById('currentStory').textContent = '-';
                document.getElementById('currentStoryStatus').textContent = '';
            }
        }

        function renderEpicBoard(data) {
            const backlogEl = document.getElementById('epicsBacklog');
            const inProgressEl = document.getElementById('epicsInProgressCol');
            const doneEl = document.getElementById('epicsDone');

            // Capture currently expanded epic IDs before update (Story 5-SR-7)
            const previouslyExpanded = new Set(
                Array.from(document.querySelectorAll('.epic-card.expanded'))
                    .map(el => el.dataset.epicId)
            );

            // Build map of existing cards for incremental update
            const existingCards = new Map();
            document.querySelectorAll('.epic-card').forEach(card => {
                existingCards.set(card.dataset.epicId, card);
            });

            // Clear columns (we'll re-add cards)
            backlogEl.innerHTML = '';
            inProgressEl.innerHTML = '';
            doneEl.innerHTML = '';

            const epics = Object.values(data.epics).filter(e => !e.id.includes('retrospective'));

            epics.forEach(epic => {
                const epicStories = epic.stories.filter(s => !s.id.includes('retrospective'));
                const doneStories = epicStories.filter(s => s.status === 'done').length;
                const totalStories = epicStories.length;
                const progress = totalStories > 0 ? (doneStories / totalStories) * 100 : 0;

                let totalDurationSecs = 0;
                epicStories.forEach(story => {
                    const activity = state.orchestratorData?.find(a => a.storyId === story.id);
                    if (activity?.totalDurationSecs) {
                        totalDurationSecs += activity.totalDurationSecs;
                    }
                });
                const totalDuration = totalDurationSecs > 0 ? formatDuration(totalDurationSecs) : '';

                const safeEpicName = escapeHtml(epic.name);
                const safeTotalDuration = escapeHtml(totalDuration);

                // Check if card already exists
                let card = existingCards.get(epic.id);
                const wasExpanded = previouslyExpanded.has(epic.id);

                if (card) {
                    // Update existing card in-place (incremental update)
                    const progressEl = card.querySelector('.epic-card-progress');
                    if (progressEl) progressEl.textContent = `${doneStories}/${totalStories} stories`;

                    const durationEl = card.querySelector('.epic-card-duration');
                    if (safeTotalDuration) {
                        if (durationEl) {
                            durationEl.textContent = safeTotalDuration;
                        } else {
                            const metaEl = card.querySelector('.epic-card-meta');
                            if (metaEl) {
                                const newDuration = document.createElement('span');
                                newDuration.className = 'epic-card-duration';
                                newDuration.textContent = safeTotalDuration;
                                metaEl.appendChild(newDuration);
                            }
                        }
                    } else if (durationEl) {
                        durationEl.remove();
                    }

                    const progressFill = card.querySelector('.epic-card-progress-fill');
                    if (progressFill) progressFill.style.width = `${progress}%`;

                    existingCards.delete(epic.id);
                } else {
                    // Create new card
                    card = document.createElement('div');
                    card.className = 'epic-card';
                    card.dataset.epicId = epic.id;

                    card.innerHTML = `
                        <div class="epic-card-header">
                            <div class="epic-card-title">${safeEpicName}</div>
                            <span class="epic-expand-icon">&#9654;</span>
                        </div>
                        <div class="epic-card-meta">
                            <span class="epic-card-progress">${doneStories}/${totalStories} stories</span>
                            ${safeTotalDuration ? `<span class="epic-card-duration">${safeTotalDuration}</span>` : ''}
                        </div>
                        <div class="epic-card-progress-bar">
                            <div class="epic-card-progress-fill" style="width: ${progress}%"></div>
                        </div>
                        <div class="epic-stories-list" style="display: none;"></div>
                    `;
                }

                // Auto-detect epic status based on story completion
                // (overrides YAML status for accuracy)
                let effectiveStatus;
                if (totalStories > 0 && doneStories === totalStories) {
                    // All stories done = epic is done
                    effectiveStatus = 'done';
                } else if (doneStories > 0 || epicStories.some(s => s.status !== 'backlog')) {
                    // At least one story started or done = epic in progress
                    effectiveStatus = 'in-progress';
                } else {
                    // All stories in backlog = epic in backlog
                    effectiveStatus = 'backlog';
                }

                if (effectiveStatus === 'done') {
                    doneEl.appendChild(card);
                } else if (effectiveStatus === 'in-progress') {
                    inProgressEl.appendChild(card);
                } else {
                    backlogEl.appendChild(card);
                }

                // Restore expanded state (Story 5-SR-7)
                if (wasExpanded && !card.classList.contains('expanded')) {
                    // Re-expand with fresh data
                    card.classList.add('expanded');
                    const storiesList = card.querySelector('.epic-stories-list');
                    if (storiesList && epicStories.length > 0) {
                        storiesList.innerHTML = epicStories.map(story => {
                            const safeId = escapeHtml(story.id);
                            const safeIdJs = escapeJsString(story.id);
                            const statusClass = normalizeStatusForClass(story.status);
                            const safeStatus = escapeHtml(story.status);
                            return `
                                <div class="epic-story-item"
                                     data-story-id="${safeId}"
                                     onmouseenter="showStoryTooltip(event, '${safeIdJs}')"
                                     onmouseleave="hideStoryTooltip()">
                                    <span class="story-name">${safeId}</span>
                                    <span class="badge badge-${statusClass}">${safeStatus}</span>
                                </div>
                            `;
                        }).join('');
                        storiesList.style.display = 'block';
                    }
                }
            });

            // Remove cards that no longer exist in data
            existingCards.forEach(card => card.remove());

            if (!backlogEl.children.length) {
                backlogEl.innerHTML = '<div class="empty-state">No epics</div>';
            }
            if (!inProgressEl.children.length) {
                inProgressEl.innerHTML = '<div class="empty-state">No epics</div>';
            }
            if (!doneEl.children.length) {
                doneEl.innerHTML = '<div class="empty-state">No epics</div>';
            }

            attachEpicCardHandlers();

            // Save UI state after render (Story 5-SR-7)
            saveUIState();
        }

        function toggleEpicCard(epicId) {
            const sanitizedId = CSS.escape(epicId);
            const card = document.querySelector(`.epic-card[data-epic-id="${sanitizedId}"]`);
            if (!card) return;

            const isExpanded = card.classList.toggle('expanded');
            const storiesList = card.querySelector('.epic-stories-list');

            if (isExpanded && state.sprintData) {
                const epic = state.sprintData.epics[epicId];
                if (epic && epic.stories.length > 0) {
                    const stories = epic.stories.filter(s => !s.id.includes('retrospective'));
                    storiesList.innerHTML = stories.map(story => {
                        const safeId = escapeHtml(story.id);
                        const safeIdJs = escapeJsString(story.id);
                        const statusClass = normalizeStatusForClass(story.status);
                        const safeStatus = escapeHtml(story.status);
                        return `
                            <div class="epic-story-item"
                                 data-story-id="${safeId}"
                                 onmouseenter="showStoryTooltip(event, '${safeIdJs}')"
                                 onmouseleave="hideStoryTooltip()">
                                <span class="story-name">${safeId}</span>
                                <span class="badge badge-${statusClass}">${safeStatus}</span>
                            </div>
                        `;
                    }).join('');
                    storiesList.style.display = 'block';
                }
            } else {
                storiesList.style.display = 'none';
            }

            // Save UI state when epic expansion changes (Story 5-SR-7)
            saveUIState();
        }

        function attachEpicCardHandlers() {
            document.querySelectorAll('.epic-card').forEach(card => {
                card.addEventListener('click', (e) => {
                    if (!e.target.closest('.epic-story-item')) {
                        toggleEpicCard(card.dataset.epicId);
                    }
                });
            });
        }

        function renderStoryTable(data, epicFilter = 'all', statusFilter = 'all') {
            const tbody = document.getElementById('storyTableBody');
            const tableContainer = tbody.closest('.table-container');
            const stories = data.stories.filter(s => !s.id.includes('retrospective'));

            // Save scroll position before update (Story 5-SR-7)
            const scrollPos = saveScrollPosition(tableContainer);

            let filtered = stories;
            if (epicFilter !== 'all') {
                filtered = filtered.filter(s => s.epic === epicFilter);
            }
            if (statusFilter !== 'all') {
                filtered = filtered.filter(s => s.status === statusFilter);
            }

            if (filtered.length === 0) {
                tbody.innerHTML = '<tr><td colspan="5" class="empty-state">No stories found</td></tr>';
                return;
            }

            // Build map of existing rows for incremental update (Story 5-SR-7)
            const existingRows = new Map();
            tbody.querySelectorAll('.story-row').forEach(row => {
                existingRows.set(row.dataset.storyId, row);
            });

            const newRowIds = new Set(filtered.map(s => s.id));

            filtered.forEach((story, index) => {
                const activity = state.orchestratorData?.find(a => a.storyId === story.id);
                const duration = activity?.duration || '-';
                const safeId = escapeHtml(story.id);
                const safeIdJs = escapeJsString(story.id);
                const safeName = escapeHtml(story.name || story.id);
                const safeEpic = escapeHtml(story.epic);
                const safeDuration = escapeHtml(duration);
                const statusClass = normalizeStatusForClass(story.status);
                const safeStatus = escapeHtml(story.status);

                let row = existingRows.get(story.id);

                if (row) {
                    // Update existing row in-place
                    const cells = row.querySelectorAll('td');
                    if (cells[0]) updateTextContent(cells[0], safeId);
                    if (cells[1]) updateTextContent(cells[1], safeName);
                    if (cells[2]) updateTextContent(cells[2], safeEpic);
                    if (cells[3]) updateTextContent(cells[3], safeDuration);
                    if (cells[4]) {
                        const badge = cells[4].querySelector('.badge');
                        if (badge) {
                            badge.className = `badge badge-${statusClass}`;
                            updateTextContent(badge, safeStatus);
                        }
                    }
                    existingRows.delete(story.id);

                    // Ensure row is in correct position
                    if (tbody.children[index] !== row) {
                        tbody.insertBefore(row, tbody.children[index] || null);
                    }
                } else {
                    // Create new row
                    row = document.createElement('tr');
                    row.className = 'story-row';
                    row.dataset.storyId = safeId;
                    row.setAttribute('onmouseenter', `showStoryTooltip(event, '${safeIdJs}')`);
                    row.setAttribute('onmouseleave', 'hideStoryTooltip()');
                    row.innerHTML = `
                        <td class="story-id">${safeId}</td>
                        <td>${safeName}</td>
                        <td>${safeEpic}</td>
                        <td class="story-duration">${safeDuration}</td>
                        <td><span class="badge badge-${statusClass}">${safeStatus}</span></td>
                    `;
                    // Insert at correct position
                    tbody.insertBefore(row, tbody.children[index] || null);
                }
            });

            // Remove rows that no longer exist
            existingRows.forEach(row => row.remove());

            // Restore scroll position after update (Story 5-SR-7)
            restoreScrollPosition(tableContainer, scrollPos);
        }

        function updateEpicFilter(data) {
            const select = document.getElementById('epicFilter');
            const currentValue = select.value;
            const epics = Object.values(data.epics).filter(e => !e.id.includes('retrospective'));

            select.innerHTML = '<option value="all">All Epics</option>';
            epics.forEach(epic => {
                const option = document.createElement('option');
                option.value = epic.id;
                option.textContent = epic.name;
                select.appendChild(option);
            });

            if (currentValue && Array.from(select.options).some(opt => opt.value === currentValue)) {
                select.value = currentValue;
            }
        }

        function renderActivityLog(activities) {
            const logEl = document.getElementById('activityLog');
            console.log('renderActivityLog called with', activities?.length, 'activities');
            console.log('Activity IDs:', activities?.map(a => `${a.storyId}:${a.completed ? 'done' : 'in-progress'}`));

            if (!activities || activities.length === 0) {
                logEl.innerHTML = '<div class="empty-state">No activity yet</div>';
                return;
            }

            // Capture current expanded/collapsed state before update (Story 5-SR-7)
            const expandedIndices = new Set();
            const collapsedCommands = new Map(); // Map<activityIndex, Set<cmdIndex>>
            logEl.querySelectorAll('.activity-item').forEach(item => {
                const idx = parseInt(item.dataset.index, 10);
                if (!item.classList.contains('collapsed')) {
                    expandedIndices.add(idx);
                }
                // Track collapsed commands within this activity
                const collapsedCmds = new Set();
                item.querySelectorAll('.command-group.collapsed').forEach(cmd => {
                    const cmdIdx = parseInt(cmd.dataset.cmdIndex, 10);
                    collapsedCmds.add(cmdIdx);
                });
                if (collapsedCmds.size > 0) {
                    collapsedCommands.set(idx, collapsedCmds);
                }
            });

            // Save scroll position
            const scrollPos = saveScrollPosition(logEl);

            const toRender = activities.slice(0, 10);
            console.log('Rendering', toRender.length, 'activities:', toRender.map(a => a.storyId));

            logEl.innerHTML = toRender.map((activity, index) => {
                const isCompleted = activity.completed && activity.completed !== '';
                const statusClass = isCompleted ? 'completed' : 'in-progress';
                const isCollapsed = index > 0;
                const badgeText = isCompleted ? 'Done' : 'In Progress';

                const description = escapeHtml(storyDescriptions[activity.storyId] || '');
                const safeStoryId = escapeHtml(activity.storyId);
                const safeEpic = escapeHtml(activity.epic);
                const safeStarted = escapeHtml(activity.started || '');
                const safeDuration = escapeHtml(activity.duration || '');

                // Build hierarchical command/task structure
                // Hide task-id level if command has only one task (no granularity to show)
                const commandsHtml = (activity.commands || []).map((cmd, cmdIndex) => {
                    const safeCmdName = escapeHtml(cmd.command);
                    const safeCmdDuration = escapeHtml(cmd.totalDuration || '');
                    const hasInProgressTasks = cmd.tasks && cmd.tasks.some(t => t.status === 'in-progress');
                    const hasSingleTask = !cmd.tasks || cmd.tasks.length <= 1;
                    const cmdStatusIcon = hasInProgressTasks ? '\u23f3' : '\u2713';
                    const cmdStatusClass = hasInProgressTasks ? 'in-progress' : 'completed';

                    // Only show task list if there are multiple tasks
                    let tasksHtml = '';
                    if (!hasSingleTask) {
                        tasksHtml = cmd.tasks.map(task => {
                            const safeTaskId = escapeHtml(task.taskId);
                            const safeTaskDuration = escapeHtml(task.duration || '');
                            const safeTaskMessage = escapeHtml(task.message || '');
                            const isTaskInProgress = task.status === 'in-progress';
                            const statusIcon = isTaskInProgress ? '\u23f3' : '\u2713';
                            const statusClass = isTaskInProgress ? 'in-progress' : 'completed';

                            return `
                                <div class="task-item${isTaskInProgress ? ' task-in-progress' : ''}">
                                    <div class="task-item-left">
                                        <span class="task-prefix">\u2514\u2500</span>
                                        <span class="task-name">${safeTaskId}</span>
                                    </div>
                                    <div class="task-item-right">
                                        <span class="task-duration">${safeTaskDuration || (isTaskInProgress ? 'running...' : '-')}</span>
                                        <span class="task-status ${statusClass}">${statusIcon}</span>
                                    </div>
                                </div>
                                ${safeTaskMessage ? `<div class="task-message">${safeTaskMessage}</div>` : ''}
                            `;
                        }).join('');
                    }

                    // If single task, show simpler command row without expand toggle
                    if (hasSingleTask) {
                        return `
                            <div class="command-group single-task" data-cmd-index="${cmdIndex}">
                                <div class="command-header-simple">
                                    <span class="command-name">${safeCmdName}</span>
                                    ${hasInProgressTasks ? '<span class="activity-badge" style="margin-left: 8px;">Running</span>' : ''}
                                    <span class="command-duration">${safeCmdDuration || '-'}</span>
                                    <span class="task-status ${cmdStatusClass}">${cmdStatusIcon}</span>
                                </div>
                            </div>
                        `;
                    }

                    return `
                        <div class="command-group" data-cmd-index="${cmdIndex}">
                            <div class="command-header" onclick="toggleCommand(${index}, ${cmdIndex})">
                                <div class="command-header-left">
                                    <span class="command-toggle">
                                        <svg width="12" height="12" viewBox="0 0 12 12" fill="currentColor">
                                            <path d="M4 2l4 4-4 4z"/>
                                        </svg>
                                    </span>
                                    <span class="command-name">${safeCmdName}</span>
                                    ${hasInProgressTasks ? '<span class="activity-badge" style="margin-left: 8px;">Running</span>' : ''}
                                </div>
                                <span class="command-duration">${safeCmdDuration || '-'}</span>
                            </div>
                            <div class="command-tasks">
                                ${tasksHtml}
                            </div>
                        </div>
                    `;
                }).join('');

                return `
                    <div class="activity-item ${statusClass}${isCollapsed ? ' collapsed' : ''}" data-index="${index}">
                        <div class="activity-header" onclick="toggleActivity(${index})">
                            <div class="activity-title-row">
                                <span class="activity-toggle">
                                    <svg width="12" height="12" viewBox="0 0 12 12" fill="currentColor">
                                        <path d="M4 2l4 4-4 4z"/>
                                    </svg>
                                </span>
                                <span class="activity-story">${safeStoryId}</span>
                                <span class="activity-badge">${badgeText}</span>
                            </div>
                            <div class="activity-meta-right">
                                ${safeDuration ? `<span class="activity-duration">${safeDuration}</span>` : ''}
                                <span class="activity-date">${safeStarted}</span>
                            </div>
                        </div>
                        <div class="activity-body">
                            <div class="activity-meta">
                                Epic: ${safeEpic}
                            </div>
                            ${description ? `<div class="activity-description">${description}</div>` : ''}
                            <div class="activity-commands">
                                ${commandsHtml || '<div class="empty-state">No commands recorded</div>'}
                            </div>
                        </div>
                    </div>
                `;
            }).join('');

            // Restore expanded/collapsed state (Story 5-SR-7)
            logEl.querySelectorAll('.activity-item').forEach(item => {
                const idx = parseInt(item.dataset.index, 10);
                // First item defaults to expanded, others to collapsed
                // But if we captured a state, honor it
                if (expandedIndices.size > 0) {
                    // Use captured state
                    if (expandedIndices.has(idx)) {
                        item.classList.remove('collapsed');
                    } else if (idx > 0) {
                        item.classList.add('collapsed');
                    }
                }
                // Restore collapsed commands
                const collapsedCmds = collapsedCommands.get(idx);
                if (collapsedCmds) {
                    item.querySelectorAll('.command-group').forEach(cmd => {
                        const cmdIdx = parseInt(cmd.dataset.cmdIndex, 10);
                        if (collapsedCmds.has(cmdIdx)) {
                            cmd.classList.add('collapsed');
                        }
                    });
                }
            });

            // Restore scroll position (Story 5-SR-7)
            restoreScrollPosition(logEl, scrollPos);

            // Save UI state (Story 5-SR-7)
            saveUIState();
        }

        function toggleActivity(index) {
            const item = document.querySelector(`.activity-item[data-index="${index}"]`);
            if (item) {
                item.classList.toggle('collapsed');
                // Save UI state when activity expansion changes (Story 5-SR-7)
                saveUIState();
            }
        }

        function toggleCommand(activityIndex, cmdIndex) {
            const item = document.querySelector(`.activity-item[data-index="${activityIndex}"]`);
            if (item) {
                const cmdGroup = item.querySelectorAll('.command-group')[cmdIndex];
                if (cmdGroup) {
                    cmdGroup.classList.toggle('collapsed');
                }
            }
            event.stopPropagation();
        }

        // ============================================================
        // TIMELINE VIEW - REDESIGNED IMPLEMENTATION
        // ============================================================

        // Initialize column resize functionality
        function initColumnResize() {
            const handle = document.getElementById('resizeHandle');
            if (!handle) return;

            handle.addEventListener('mousedown', startResize);
            document.addEventListener('mousemove', doResize);
            document.addEventListener('mouseup', stopResize);
        }

        // Initialize cursor line for timeline alignment visualization
        function initTimelineCursorLine() {
            const container = document.getElementById('timelineScrollContainer');
            const cursorLine = document.getElementById('timelineCursorLine');
            if (!container || !cursorLine) return;

            container.addEventListener('mousemove', (e) => {
                const rect = container.getBoundingClientRect();
                const x = e.clientX - rect.left + container.scrollLeft;
                cursorLine.style.left = x + 'px';
                cursorLine.style.display = 'block';
            });

            container.addEventListener('mouseleave', () => {
                cursorLine.style.display = 'none';
            });
        }

        function startResize(e) {
            resizeState.isResizing = true;
            resizeState.startX = e.clientX;
            resizeState.startWidth = timelineState.labelColumnWidth;
            document.getElementById('resizeHandle').classList.add('active');
            document.body.style.cursor = 'col-resize';
            document.body.style.userSelect = 'none';
            e.preventDefault();
        }

        function doResize(e) {
            if (!resizeState.isResizing) return;

            const diff = e.clientX - resizeState.startX;
            const newWidth = Math.min(
                Math.max(resizeState.startWidth + diff, timelineState.minLabelWidth),
                timelineState.maxLabelWidth
            );

            timelineState.labelColumnWidth = newWidth;
            document.documentElement.style.setProperty('--timeline-label-width', newWidth + 'px');
        }

        function stopResize() {
            if (!resizeState.isResizing) return;

            resizeState.isResizing = false;
            document.getElementById('resizeHandle')?.classList.remove('active');
            document.body.style.cursor = '';
            document.body.style.userSelect = '';

            // Persist to localStorage
            localStorage.setItem('timeline-label-width', timelineState.labelColumnWidth);
        }

        // Restore column width from localStorage
        function restoreColumnWidth() {
            const saved = localStorage.getItem('timeline-label-width');
            if (saved) {
                const width = parseInt(saved, 10);
                if (!isNaN(width) && width >= timelineState.minLabelWidth && width <= timelineState.maxLabelWidth) {
                    timelineState.labelColumnWidth = width;
                    document.documentElement.style.setProperty('--timeline-label-width', width + 'px');
                }
            }
        }

        // Set block size in minutes
        function setBlockSizeMinutes(minutes) {
            const parsed = parseInt(minutes, 10);
            if (isNaN(parsed) || parsed < 1 || parsed > 480) {
                document.getElementById('blockSizeInput').value = timelineState.blockSizeMinutes;
                return;
            }

            timelineState.blockSizeMinutes = parsed;
            renderTimeline();
        }

        /**
         * Convert timestamp to X position using compacted block layout.
         * Uses timestampToXCompact when compacted blocks are available.
         */
        function timestampToX(timestamp) {
            // Use compact positioning if available
            if (timelineState.compactedBlocks && timelineState.compactedBlocks.length > 0) {
                return timestampToXCompact(timestamp);
            }

            // Fallback to linear positioning
            const { timelineStartTs, blockSizeMinutes, zoomLevel } = timelineState;
            if (!timelineStartTs || !blockSizeMinutes) return 0;

            const blockWidthPx = COLUMN_WIDTH_PX * (zoomLevel / 100);
            const timeOffset = timestamp - timelineStartTs;
            const timeOffsetMinutes = timeOffset / 60;
            return (timeOffsetMinutes / blockSizeMinutes) * blockWidthPx;
        }

        /**
         * Generate time blocks based on timeline bounds.
         * These blocks are then passed to compactEmptyBlocks() which merges
         * consecutive empty blocks and calculates final positions.
         */
        function generateTimeBlocks() {
            const { timelineStartTs, timelineEndTs, blockSizeMinutes, zoomLevel } = timelineState;

            if (!timelineStartTs || !timelineEndTs) return [];

            // Fixed column width scaled by zoom
            const blockWidthPx = COLUMN_WIDTH_PX * (zoomLevel / 100);
            const totalSeconds = timelineEndTs - timelineStartTs;
            const totalMinutes = totalSeconds / 60;
            const blockCount = Math.ceil(totalMinutes / blockSizeMinutes);

            // Initial width estimate (will be recalculated after compaction)
            timelineState.totalTimelineWidth = blockCount * blockWidthPx;

            const blocks = [];
            for (let i = 0; i < blockCount; i++) {
                const blockStartTs = timelineStartTs + (i * blockSizeMinutes * 60);
                const minutesFromStart = i * blockSizeMinutes;

                // Format label based on total minutes (smart format)
                let label;
                if (minutesFromStart >= 60) {
                    const hours = Math.floor(minutesFromStart / 60);
                    const mins = minutesFromStart % 60;
                    label = mins > 0 ? `${hours}h ${mins}m` : `${hours}h`;
                } else {
                    label = `${minutesFromStart}m`;
                }

                blocks.push({
                    timestamp: blockStartTs,
                    label: label,
                    widthPx: blockWidthPx,
                    xPosition: i * blockWidthPx  // Pre-calculate X position for grid line
                });
            }

            return blocks;
        }

        /**
         * Detect empty blocks and compact consecutive empty blocks into single gap indicators.
         * Returns compacted blocks with position mapping for bar rendering.
         */
        function compactEmptyBlocks(blocks, activities, blockSizeMinutes, blockWidthPx) {
            const COMPACT_WIDTH = 20;
            const blockSizeSeconds = blockSizeMinutes * 60;

            // First, mark which blocks are empty
            const markedBlocks = blocks.map((block) => {
                const blockStart = block.timestamp;
                const blockEnd = blockStart + blockSizeSeconds;

                const hasContent = activities.some(activity => {
                    const storyOverlaps = (
                        activity.startTs < blockEnd &&
                        (activity.endTs || activity.startTs + 3600) > blockStart
                    );
                    if (storyOverlaps) return true;

                    return (activity.steps || []).some(step => {
                        const stepEnd = step.endTs || step.startTs + 60;
                        return step.startTs < blockEnd && stepEnd > blockStart;
                    });
                });

                return { ...block, isEmpty: !hasContent };
            });

            // Merge consecutive empty blocks into single compact gaps
            // Labels restart at 0 after each gap
            const compactedBlocks = [];
            let currentGap = null;
            let xPosition = 0;
            let minutesSinceGap = 0; // Reset after each gap

            // Helper to format time label
            function formatLabel(minutes) {
                if (minutes >= 60) {
                    const hours = Math.floor(minutes / 60);
                    const mins = minutes % 60;
                    return mins > 0 ? `${hours}h ${mins}m` : `${hours}h`;
                }
                return `${minutes}m`;
            }

            markedBlocks.forEach((block) => {
                if (block.isEmpty) {
                    if (!currentGap) {
                        // Start new gap
                        currentGap = {
                            isCompact: true,
                            isEmpty: true,
                            label: '',
                            gapStartTs: block.timestamp,
                            gapEndTs: block.timestamp + blockSizeSeconds,
                            widthPx: COMPACT_WIDTH
                        };
                    } else {
                        // Extend existing gap
                        currentGap.gapEndTs = block.timestamp + blockSizeSeconds;
                    }
                } else {
                    // Flush pending gap and reset minute counter
                    if (currentGap) {
                        currentGap.xPosition = xPosition;
                        compactedBlocks.push(currentGap);
                        xPosition += COMPACT_WIDTH;
                        currentGap = null;
                        minutesSinceGap = 0; // Reset after gap
                    }
                    // Add non-empty block with label showing block END time
                    minutesSinceGap += blockSizeMinutes;
                    compactedBlocks.push({
                        ...block,
                        label: formatLabel(minutesSinceGap),
                        isCompact: false,
                        xPosition: xPosition,
                        widthPx: blockWidthPx
                    });
                    xPosition += blockWidthPx;
                }
            });

            // Flush final gap
            if (currentGap) {
                currentGap.xPosition = xPosition;
                compactedBlocks.push(currentGap);
                xPosition += COMPACT_WIDTH;
            }

            // Store total width and position mapping
            timelineState.totalTimelineWidth = xPosition;
            timelineState.compactedBlocks = compactedBlocks;

            return compactedBlocks;
        }

        /**
         * Convert timestamp to X position accounting for compacted gaps.
         */
        function timestampToXCompact(timestamp) {
            const blocks = timelineState.compactedBlocks;
            if (!blocks || blocks.length === 0) return 0;

            const blockSizeSeconds = timelineState.blockSizeMinutes * 60;

            for (let i = 0; i < blocks.length; i++) {
                const block = blocks[i];

                if (block.isCompact) {
                    // Gap block - check if timestamp falls within gap
                    if (timestamp >= block.gapStartTs && timestamp < block.gapEndTs) {
                        // Position at start of compact gap (don't interpolate within gap)
                        return block.xPosition;
                    }
                } else {
                    // Normal block
                    const blockStart = block.timestamp;
                    const blockEnd = blockStart + blockSizeSeconds;

                    if (timestamp >= blockStart && timestamp < blockEnd) {
                        // Interpolate within block
                        const progress = (timestamp - blockStart) / blockSizeSeconds;
                        return block.xPosition + (progress * block.widthPx);
                    }
                }
            }

            // After last block - return end position
            const lastBlock = blocks[blocks.length - 1];
            return lastBlock.xPosition + lastBlock.widthPx;
        }

        // Toggle story visibility via checkbox
        function toggleStoryVisibility(storyId, visible) {
            if (visible) {
                timelineState.hiddenStories.delete(storyId);
            } else {
                timelineState.hiddenStories.add(storyId);
            }

            // Re-render timeline to update sort order and bounds
            renderTimeline();

            // Save UI state when visibility changes (Story 5-SR-7)
            saveUIState();
        }

        // Hide all stories in timeline
        function hideAllStories() {
            const timelineData = getTimelineData(state.orchestratorData);
            if (!timelineData) return;

            timelineData.forEach(activity => {
                timelineState.hiddenStories.add(activity.storyId);
            });

            // Re-render timeline with all stories hidden (moved to bottom)
            renderTimeline();
        }

        // Show all stories in timeline
        function showAllStories() {
            timelineState.hiddenStories.clear();

            // Remove any empty state message
            document.querySelectorAll('.timeline-empty').forEach(el => el.remove());

            // Rebuild timeline with full bounds
            renderTimeline();
        }

        // Get timeline data with processing
        function getTimelineData(orchestratorData) {
            if (!orchestratorData) return null;

            const hash = hashString(JSON.stringify(orchestratorData));
            if (hash === timelineCache.dataHash && timelineCache.data) {
                return timelineCache.data;
            }

            // Filter activities with valid data - newest first (matches Activity tab order)
            const validActivities = orchestratorData
                .filter(a => a.steps && a.steps.length > 0);

            timelineCache.data = validActivities;
            timelineCache.dataHash = hash;
            return timelineCache.data;
        }

        // Zoom timeline
        function zoomTimeline(direction) {
            const levels = [50, 75, 100, 150, 200];
            const currentIndex = levels.indexOf(timelineState.zoomLevel);

            if (direction === 'in' && currentIndex < levels.length - 1) {
                timelineState.zoomLevel = levels[currentIndex + 1];
            } else if (direction === 'out' && currentIndex > 0) {
                timelineState.zoomLevel = levels[currentIndex - 1];
            }

            document.getElementById('zoomLevel').textContent = timelineState.zoomLevel + '%';
            renderTimeline();
        }

        // Toggle story row expansion via label click (multiple can be expanded)
        function toggleStoryRow(storyId) {
            const sanitizedId = CSS.escape(String(storyId || ''));
            const row = document.querySelector(`.timeline-row[data-story-id="${sanitizedId}"]`);
            if (!row) return;

            const wasExpanded = row.classList.contains('expanded');

            // Toggle current row (allow multiple expansions)
            row.classList.toggle('expanded', !wasExpanded);

            if (wasExpanded) {
                timelineState.expandedStoryIds.delete(storyId);
            } else {
                timelineState.expandedStoryIds.add(storyId);
            }

            // Save UI state when timeline row expansion changes (Story 5-SR-7)
            saveUIState();
        }

        // Toggle command expand/collapse in timeline
        function toggleTimelineCommand(cmdKey) {
            const cmdGroup = document.querySelector(`.timeline-command-group[data-cmd-key="${CSS.escape(cmdKey)}"]`);
            if (!cmdGroup) return;

            const wasExpanded = !cmdGroup.classList.contains('collapsed');
            cmdGroup.classList.toggle('collapsed', wasExpanded);

            // Store state (default is expanded=true, so we only store when collapsed)
            if (wasExpanded) {
                timelineState.expandedCommands.set(cmdKey, false);
            } else {
                timelineState.expandedCommands.delete(cmdKey); // Remove to use default (expanded)
            }
        }

        // Show timeline tooltip
        function showTimelineTooltip(event, storyId, duration, stepCount, started) {
            const tooltip = document.getElementById('timelineTooltip');
            if (!tooltip) return;

            const safeSteps = Math.max(0, parseInt(stepCount, 10) || 0);

            const titleDiv = document.createElement('div');
            titleDiv.className = 'timeline-tooltip-title';
            titleDiv.textContent = storyId || ''; // textContent handles escaping

            const metaDiv = document.createElement('div');
            metaDiv.className = 'timeline-tooltip-meta';

            // Build meta content safely using DOM methods
            metaDiv.appendChild(document.createTextNode('Duration: ' + (duration || 'In progress')));
            metaDiv.appendChild(document.createElement('br'));
            metaDiv.appendChild(document.createTextNode('Steps: ' + safeSteps));
            if (started) {
                metaDiv.appendChild(document.createElement('br'));
                metaDiv.appendChild(document.createTextNode('Started: ' + started));
            }

            tooltip.innerHTML = '';
            tooltip.appendChild(titleDiv);
            tooltip.appendChild(metaDiv);

            tooltip.style.left = (event.clientX + 10) + 'px';
            tooltip.style.top = (event.clientY - 10) + 'px';
            tooltip.classList.add('visible');
        }

        function hideTimelineTooltip() {
            const tooltip = document.getElementById('timelineTooltip');
            if (tooltip) {
                tooltip.classList.remove('visible');
            }
        }

        // Render timeline visualization
        function renderTimeline() {
            const hoursEl = document.getElementById('timelineHours');
            const gridEl = document.getElementById('timelineGrid');
            const rowsEl = document.getElementById('timelineRows');
            const bodyEl = document.getElementById('timelineBody');
            const scrollContainer = document.getElementById('timelineScrollContainer');

            if (!hoursEl || !gridEl || !rowsEl || !bodyEl) {
                console.warn('Timeline elements not found');
                return;
            }

            // Get processed timeline data
            const timelineData = getTimelineData(state.orchestratorData);

            if (!timelineData || timelineData.length === 0) {
                hoursEl.innerHTML = '';
                gridEl.innerHTML = '';
                rowsEl.innerHTML = '<div class="timeline-empty">No timeline data available</div>';
                return;
            }

            // Separate visible and hidden stories, maintaining original chronological order
            const visibleActivities = timelineData.filter(
                a => !timelineState.hiddenStories.has(a.storyId)
            );
            const hiddenActivities = timelineData.filter(
                a => timelineState.hiddenStories.has(a.storyId)
            );

            // Sorted display order: visible stories first (chronological), then hidden stories at bottom
            const sortedActivities = [...visibleActivities, ...hiddenActivities];

            // Calculate timeline bounds from timestamps (fallback for missing timestamps)
            const allStartTs = visibleActivities.map(a => a.startTs).filter(ts => ts);

            if (allStartTs.length === 0 && visibleActivities.length > 0) {
                // Fallback: use sequential positioning with realistic base timestamp
                let offset = Math.floor(Date.now() / 1000) - (timelineData.length * 3600);
                timelineData.forEach(a => {
                    a.startTs = offset;
                    const dur = a.totalDurationSecs || 3600;
                    a.endTs = offset + dur;
                    offset = a.endTs + 300;
                });
            }

            // Calculate bounds from visible stories only
            const startTimestamps = visibleActivities.map(a => a.startTs).filter(ts => ts != null);
            const endTimestamps = visibleActivities.map(a => a.endTs || a.startTs + 3600).filter(ts => ts != null);

            timelineState.timelineStartTs = startTimestamps.length > 0 ? Math.min(...startTimestamps) : 0;
            timelineState.timelineEndTs = endTimestamps.length > 0 ? Math.max(...endTimestamps) : 3600;

            // Generate time blocks and compact empty ones
            const blockWidthPx = COLUMN_WIDTH_PX * (timelineState.zoomLevel / 100);
            let blocks = [];

            if (visibleActivities.length > 0) {
                const rawBlocks = generateTimeBlocks();
                blocks = compactEmptyBlocks(rawBlocks, visibleActivities, timelineState.blockSizeMinutes, blockWidthPx);
            }
            timelineState.processedBlocks = blocks;

            console.log('Timeline blocks:', blocks.length, 'compact:', blocks.filter(b => b.isCompact).length);

            // Render time header - compact blocks get small width
            hoursEl.innerHTML = '';
            blocks.forEach(block => {
                const hourDiv = document.createElement('div');
                hourDiv.className = 'timeline-hour' + (block.isCompact ? ' compact' : '');
                hourDiv.style.minWidth = block.widthPx + 'px';
                hourDiv.style.width = block.widthPx + 'px';
                hourDiv.textContent = block.isCompact ? '' : block.label;
                hoursEl.appendChild(hourDiv);
            });

            // Render grid lines - compact blocks get small width
            gridEl.innerHTML = '';
            blocks.forEach(block => {
                const gridLine = document.createElement('div');
                gridLine.className = 'timeline-grid-line' + (block.isCompact ? ' compact' : '');
                gridLine.style.minWidth = block.widthPx + 'px';
                gridLine.style.width = block.widthPx + 'px';
                gridEl.appendChild(gridLine);
            });

            // Render story rows (visible first, then hidden at bottom)
            rowsEl.innerHTML = '';
            sortedActivities.forEach(activity => {
                const isHidden = timelineState.hiddenStories.has(activity.storyId);
                const isCompleted = activity.completed && activity.completed !== '';

                const safeStoryId = escapeHtml(activity.storyId);
                const safeDuration = escapeHtml(activity.duration || '');
                const safeStepCount = activity.steps ? activity.steps.length : 0;
                const safeStarted = escapeHtml(activity.started || '');

                // Create row container - hidden stories get 'hidden-story' class for muted styling
                const row = document.createElement('div');
                row.className = 'timeline-row' + (isHidden ? ' hidden-story' : '');
                row.setAttribute('data-story-id', safeStoryId);

                // Create row main area (label + content)
                const rowMain = document.createElement('div');
                rowMain.className = 'timeline-row-main';

                // Create row label with checkbox
                const label = document.createElement('div');
                label.className = 'timeline-row-label';
                label.title = safeStoryId;

                // Add visibility checkbox
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'story-visibility-checkbox';
                checkbox.dataset.storyId = safeStoryId;
                checkbox.checked = !isHidden;
                checkbox.addEventListener('change', (e) => {
                    e.stopPropagation();
                    toggleStoryVisibility(activity.storyId, e.target.checked);
                });
                checkbox.addEventListener('click', (e) => e.stopPropagation());

                // Only show expand icon for visible stories (hidden ones have no content to expand)
                if (!isHidden) {
                    const expandIcon = document.createElement('span');
                    expandIcon.className = 'label-expand-icon';
                    expandIcon.innerHTML = '&#9654;';
                    label.appendChild(checkbox);
                    label.appendChild(expandIcon);
                } else {
                    label.appendChild(checkbox);
                }

                const titleSpan = document.createElement('span');
                titleSpan.className = 'label-title';
                titleSpan.textContent = activity.storyId;

                const durationSpan = document.createElement('span');
                durationSpan.className = 'label-duration';
                durationSpan.textContent = activity.duration || '';

                label.appendChild(titleSpan);
                label.appendChild(durationSpan);

                // Only add click handler for expand on visible stories
                if (!isHidden) {
                    label.addEventListener('click', () => toggleStoryRow(safeStoryId));
                }

                // Create row content - set explicit width to match grid
                const content = document.createElement('div');
                content.className = 'timeline-row-content';
                content.style.width = timelineState.totalTimelineWidth + 'px';
                content.style.minWidth = timelineState.totalTimelineWidth + 'px';

                // Only render timeline bar for visible stories
                // Use block-based timestampToX() - bars scale with block size
                if (!isHidden && blocks.length > 0) {
                    const barLeft = timestampToX(activity.startTs);
                    // For in-progress stories without endTs, use current time capped at 30 min
                    const MAX_IN_PROGRESS_SECS = 30 * 60;
                    const now = Math.floor(Date.now() / 1000);
                    const fallbackEnd = activity.startTs + Math.min(now - activity.startTs, MAX_IN_PROGRESS_SECS);
                    const barRight = timestampToX(activity.endTs || fallbackEnd);
                    const barWidth = Math.max(barRight - barLeft, 20); // Minimum width for visibility

                    const bar = document.createElement('div');
                    bar.className = `timeline-bar story-bar ${isCompleted ? '' : 'in-progress'}`;
                    bar.style.left = barLeft + 'px';
                    bar.style.width = barWidth + 'px';
                    // Hide text if bar is too narrow
                    const showStoryLabel = barWidth >= 50;
                    bar.innerHTML = showStoryLabel ? `<span class="bar-label">${safeDuration || '...'}</span>` : '';
                    bar.addEventListener('mouseenter', (e) => showTimelineTooltip(e, safeStoryId, safeDuration, safeStepCount, safeStarted));
                    bar.addEventListener('mouseleave', () => hideTimelineTooltip());
                    content.appendChild(bar);
                }

                rowMain.appendChild(label);
                rowMain.appendChild(content);
                row.appendChild(rowMain);

                // Only create command rows for visible stories
                if (!isHidden) {
                    const commandRows = document.createElement('div');
                    commandRows.className = 'timeline-command-rows';

                    // Generate command rows - use continuous positioning
                    const MAX_IN_PROGRESS_SECS = 30 * 60;
                    const now = Math.floor(Date.now() / 1000);

                    (activity.steps || []).forEach((step, stepIndex) => {
                        const cmdLeft = timestampToX(step.startTs);
                        // For in-progress commands without endTs, use current time capped at 30 min
                        const cmdFallbackEnd = step.startTs + Math.min(now - step.startTs, MAX_IN_PROGRESS_SECS);
                        const cmdRight = timestampToX(step.endTs || cmdFallbackEnd);
                        const cmdWidth = Math.max(cmdRight - cmdLeft, 20); // Minimum width for visibility
                        const cmdClass = getCommandClass(step.command);
                        const safeCmdDuration = escapeHtml(step.duration || '');
                        const hasInProgressTasks = step.tasks && step.tasks.some(t => t.status === 'in-progress');
                        const hasTasks = step.tasks && step.tasks.length > 1;

                        // Create command group container for expand/collapse
                        const cmdGroupKey = `${activity.storyId}|${step.command}|${stepIndex}`;
                        const isExpanded = timelineState.expandedCommands ?
                            (timelineState.expandedCommands.get(cmdGroupKey) !== false) : true; // Default expanded

                        const cmdGroup = document.createElement('div');
                        cmdGroup.className = 'timeline-command-group' + (isExpanded ? '' : ' collapsed');
                        cmdGroup.dataset.cmdKey = cmdGroupKey;

                        const cmdRow = document.createElement('div');
                        cmdRow.className = 'timeline-command-row';

                        const cmdRowLabel = document.createElement('div');
                        cmdRowLabel.className = 'timeline-command-row-label';

                        // Add expand/collapse toggle if there are tasks
                        if (hasTasks) {
                            const toggleIcon = document.createElement('span');
                            toggleIcon.className = 'cmd-expand-icon';
                            toggleIcon.innerHTML = '&#9654;';
                            toggleIcon.addEventListener('click', (e) => {
                                e.stopPropagation();
                                toggleTimelineCommand(cmdGroupKey);
                            });
                            cmdRowLabel.appendChild(toggleIcon);
                        }

                        const cmdLabelText = document.createElement('span');
                        cmdLabelText.textContent = step.command;
                        cmdRowLabel.appendChild(cmdLabelText);
                        cmdRowLabel.title = step.command;

                        // Make label clickable to toggle
                        if (hasTasks) {
                            cmdRowLabel.style.cursor = 'pointer';
                            cmdRowLabel.addEventListener('click', () => toggleTimelineCommand(cmdGroupKey));
                        }

                        const cmdRowContent = document.createElement('div');
                        cmdRowContent.className = 'timeline-command-row-content';
                        cmdRowContent.style.width = timelineState.totalTimelineWidth + 'px';
                        cmdRowContent.style.minWidth = timelineState.totalTimelineWidth + 'px';

                        const cmdBar = document.createElement('div');
                        cmdBar.className = `command-bar ${cmdClass}${hasInProgressTasks ? ' in-progress-stripe' : ''}`;
                        cmdBar.style.left = cmdLeft + 'px';
                        cmdBar.style.width = cmdWidth + 'px';
                        // Hide text if bar is too narrow
                        const showCmdLabel = cmdWidth >= 40;
                        cmdBar.innerHTML = showCmdLabel ? `<span class="command-label">${safeCmdDuration}</span>` : '';
                        cmdBar.title = `${step.command}: ${step.duration || ''}`;

                        cmdRowContent.appendChild(cmdBar);
                        cmdRow.appendChild(cmdRowLabel);
                        cmdRow.appendChild(cmdRowContent);
                        cmdGroup.appendChild(cmdRow);

                        // Container for tasks (can be collapsed)
                        const tasksContainer = document.createElement('div');
                        tasksContainer.className = 'timeline-tasks-container';

                        // Add task-level rows within command only if multiple tasks exist
                        // Single task = no granularity to show, just the command is enough
                        if (step.tasks && step.tasks.length > 1) {
                            step.tasks.forEach(task => {
                                const taskLeft = timestampToX(task.startTs);
                                // For in-progress tasks without endTs, use current time capped at 30 min
                                const taskFallbackEnd = task.startTs + Math.min(now - task.startTs, MAX_IN_PROGRESS_SECS);
                                const taskRight = timestampToX(task.endTs || taskFallbackEnd);
                                const taskWidth = Math.max(taskRight - taskLeft, 15);
                                const isTaskInProgress = task.status === 'in-progress';
                                const safeTaskMessage = escapeHtml(task.message || '');

                                const taskRow = document.createElement('div');
                                taskRow.className = 'timeline-task-row';

                                const taskRowLabel = document.createElement('div');
                                taskRowLabel.className = 'timeline-task-row-label';
                                taskRowLabel.textContent = task.taskId;
                                taskRowLabel.title = task.taskId;

                                const taskRowContent = document.createElement('div');
                                taskRowContent.className = 'timeline-task-row-content';
                                taskRowContent.style.width = timelineState.totalTimelineWidth + 'px';
                                taskRowContent.style.minWidth = timelineState.totalTimelineWidth + 'px';

                                const taskBar = document.createElement('div');
                                taskBar.className = `task-bar ${isTaskInProgress ? 'in-progress' : 'completed'}`;
                                taskBar.style.left = taskLeft + 'px';
                                taskBar.style.width = taskWidth + 'px';
                                const showTaskLabel = taskWidth >= 30;
                                taskBar.innerHTML = showTaskLabel ? `<span class="task-label">${escapeHtml(task.duration || '')}</span>` : '';
                                taskBar.title = safeTaskMessage || `${task.taskId}: ${task.duration || (isTaskInProgress ? 'running...' : '')}`;

                                taskRowContent.appendChild(taskBar);
                                taskRow.appendChild(taskRowLabel);
                                taskRow.appendChild(taskRowContent);
                                tasksContainer.appendChild(taskRow);

                                // Add message row below task if message exists
                                if (safeTaskMessage) {
                                    const msgRow = document.createElement('div');
                                    msgRow.className = 'timeline-message-row';

                                    const msgLabel = document.createElement('div');
                                    msgLabel.className = 'timeline-message-label';

                                    const msgContent = document.createElement('div');
                                    msgContent.className = 'timeline-message-content';
                                    msgContent.style.width = timelineState.totalTimelineWidth + 'px';
                                    msgContent.style.minWidth = timelineState.totalTimelineWidth + 'px';

                                    const msgText = document.createElement('span');
                                    msgText.className = 'timeline-message-text';
                                    msgText.textContent = safeTaskMessage;
                                    msgText.style.marginLeft = taskLeft + 'px';

                                    msgContent.appendChild(msgText);
                                    msgRow.appendChild(msgLabel);
                                    msgRow.appendChild(msgContent);
                                    tasksContainer.appendChild(msgRow);
                                }
                            });
                        }

                        cmdGroup.appendChild(tasksContainer);
                        commandRows.appendChild(cmdGroup);
                    });

                    row.appendChild(commandRows);
                }

                rowsEl.appendChild(row);
            });

            // Auto-scroll to end on initial render
            if (scrollContainer && timelineData.length > 0) {
                if (!timelineCache.hasScrolled) {
                    setTimeout(() => {
                        scrollContainer.scrollLeft = scrollContainer.scrollWidth;
                        timelineCache.hasScrolled = true;
                    }, 100);
                }
            }
        }

        // ============================================================
        // Tab Switching and Updates
        // ============================================================

        function switchTab(tabName) {
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.tab === tabName);
            });
            document.querySelectorAll('.tab-panel').forEach(panel => {
                panel.classList.toggle('active', panel.id === `tab-${tabName}`);
            });
            if (tabName === 'timeline') {
                timelineCache.hasScrolled = false;
                renderTimeline();
            }
            // Persist active tab
            localStorage.setItem('dashboard-active-tab', tabName);
        }

        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.addEventListener('click', () => switchTab(btn.dataset.tab));
        });

        // Restore active tab from localStorage
        function restoreActiveTab() {
            const savedTab = localStorage.getItem('dashboard-active-tab');
            if (savedTab) {
                switchTab(savedTab);
            }
        }

        function updateTabCounts(sprintData, orchestratorData) {
            if (sprintData) {
                const epics = Object.values(sprintData.epics).filter(e => !e.id.includes('retrospective'));
                const stories = sprintData.stories.filter(s => !s.id.includes('retrospective'));
                document.getElementById('epicsCount').textContent = epics.length;
                document.getElementById('storiesCount').textContent = stories.length;
            }
            if (orchestratorData) {
                document.getElementById('activityCount').textContent = orchestratorData.length;
            }
        }

        function updateLastUpdatedTime() {
            if (!state.lastUpdateTime) return;

            const now = Date.now();
            const secondsAgo = Math.floor((now - state.lastUpdateTime) / 1000);

            let timeText = 'just now';
            if (secondsAgo > 0 && secondsAgo < 60) {
                timeText = `${secondsAgo}s ago`;
            } else if (secondsAgo >= 60 && secondsAgo < 3600) {
                const mins = Math.floor(secondsAgo / 60);
                timeText = `${mins}m ago`;
            } else if (secondsAgo >= 3600) {
                const hours = Math.floor(secondsAgo / 3600);
                timeText = `${hours}h ago`;
            }

            document.getElementById('lastUpdated').textContent = `Last updated: ${timeText}`;
        }

        // ============================================================
        // Data Loading and Auto-refresh
        // ============================================================

        async function refreshViaFetch() {
            try {
                let sprintText = null;
                let orchText = null;

                const sprintResponse = await fetch('./sprint-status.yaml');
                if (sprintResponse.ok) {
                    sprintText = await sprintResponse.text();
                }

                const csvResponse = await fetch('./sprint-runner.csv?t=' + Date.now());
                if (csvResponse.ok) {
                    orchText = await csvResponse.text();
                    console.log('Loading sprint-runner.csv, length:', orchText.length, 'lines:', orchText.split('\n').length);
                }

                const combinedData = (sprintText || '') + '|' + (orchText || '');
                const newHash = hashString(combinedData);

                if (newHash === state.lastDataHash) {
                    return;
                }

                state.lastDataHash = newHash;
                state.lastUpdateTime = Date.now();

                if (sprintText) {
                    state.sprintData = parseSprintStatus(sprintText);
                    renderSummaryCards(state.sprintData);
                    renderEpicBoard(state.sprintData);
                    renderStoryTable(state.sprintData,
                        document.getElementById('epicFilter').value,
                        document.getElementById('statusFilter').value);
                }

                if (orchText) {
                    state.orchestratorData = parseOrchestrator(orchText);
                    renderActivityLog(state.orchestratorData);
                }

                updateTabCounts(state.sprintData, state.orchestratorData);
            } catch (e) {
                console.log('Fetch refresh failed:', e);
            }
        }

        async function tryAutoLoad() {
            try {
                await loadStoryDescriptions();

                const sprintResponse = await fetch('./sprint-status.yaml');
                if (sprintResponse.ok) {
                    const sprintText = await sprintResponse.text();
                    state.sprintData = parseSprintStatus(sprintText);
                    state.lastUpdateTime = Date.now();
                    renderSummaryCards(state.sprintData);
                    updateEpicFilter(state.sprintData);

                    // Restore filter values before rendering table (Story 5-SR-7)
                    try {
                        const filtersJson = localStorage.getItem(UI_STATE_KEYS.FILTERS);
                        if (filtersJson) {
                            const filters = JSON.parse(filtersJson);
                            const epicFilter = document.getElementById('epicFilter');
                            const statusFilter = document.getElementById('statusFilter');
                            // Only set if option exists in filter
                            if (epicFilter && filters.epic && Array.from(epicFilter.options).some(o => o.value === filters.epic)) {
                                epicFilter.value = filters.epic;
                            }
                            if (statusFilter && filters.status) {
                                statusFilter.value = filters.status;
                            }
                        }
                    } catch (e) {
                        console.warn('Failed to restore filters:', e);
                    }

                    renderEpicBoard(state.sprintData);

                    // Render story table with restored filters
                    const epicFilter = document.getElementById('epicFilter').value;
                    const statusFilter = document.getElementById('statusFilter').value;
                    renderStoryTable(state.sprintData, epicFilter, statusFilter);

                    // Restore expanded epics after render (Story 5-SR-7)
                    restoreExpandedEpics();
                }

                let orchText = null;
                const csvResponse = await fetch('./sprint-runner.csv?t=' + Date.now());
                if (csvResponse.ok) {
                    orchText = await csvResponse.text();
                    console.log('Loading sprint-runner.csv, length:', orchText.length, 'lines:', orchText.split('\n').length);
                }

                if (orchText) {
                    state.orchestratorData = parseOrchestrator(orchText);
                    console.log('Parsed activities:', state.orchestratorData.length, 'stories:', state.orchestratorData.map(a => a.storyId));
                    state.lastUpdateTime = Date.now();
                    renderActivityLog(state.orchestratorData);

                    // Restore expanded activities after render (Story 5-SR-7)
                    restoreExpandedActivities();
                }

                if (state.sprintData || state.orchestratorData) {
                    document.getElementById('dashboardContent').classList.add('visible');
                    document.getElementById('updateDot').classList.remove('inactive');
                    state.autoLoadWorks = true;
                    updateTabCounts(state.sprintData, state.orchestratorData);

                    // Restore scroll positions after initial render (Story 5-SR-7)
                    setTimeout(restoreScrollPositions, 100);

                    if (!state.watchInterval) {
                        state.isWatching = true;
                        state.watchInterval = setInterval(async () => {
                            await refreshViaFetch();
                        }, 5000);
                        console.log('Auto-refresh enabled (5s interval)');
                    }
                }
            } catch (e) {
                console.log('Auto-load failed:', e);
                state.autoLoadWorks = false;
                document.getElementById('lastUpdated').textContent = 'Failed to load - serve via HTTP';
            }
        }

        // Filter event listeners
        document.getElementById('epicFilter').addEventListener('change', (e) => {
            if (state.sprintData) {
                const statusFilter = document.getElementById('statusFilter').value;
                renderStoryTable(state.sprintData, e.target.value, statusFilter);
                // Save UI state when filter changes (Story 5-SR-7)
                saveUIState();
            }
        });

        document.getElementById('statusFilter').addEventListener('change', (e) => {
            if (state.sprintData) {
                const epicFilter = document.getElementById('epicFilter').value;
                renderStoryTable(state.sprintData, epicFilter, e.target.value);
                // Save UI state when filter changes (Story 5-SR-7)
                saveUIState();
            }
        });

        // Initialize (Story 5-SR-7: Restore UI state before initial render)
        restoreUIState();
        restoreColumnWidth();
        initColumnResize();
        initTimelineCursorLine();
        restoreActiveTab();
        tryAutoLoad();

        // Update time display
        setInterval(updateLastUpdatedTime, 1000);

        // Save scroll positions periodically to localStorage (Story 5-SR-7)
        setInterval(saveUIState, 5000);

        // ============================================================
        // SPRINT RUN TAB FUNCTIONALITY (Story 5-SR-6)
        // ============================================================

        // Sprint Run State
        const sprintRunState = {
            ws: null,
            wsReconnectTimer: null,
            wsReconnectAttempts: 0,
            isRunning: false,
            isStopping: false,
            currentBatchId: null,
            maxCycles: 0,
            currentCycle: 0,
            activeStories: [],
            currentOperation: null,
            autoScroll: true,
            userScrolled: false,
            // Epic 6: Enhanced real-time state
            connectionStatus: 'disconnected',  // connected, connecting, reconnecting, disconnected
            eventQueue: [],                    // Queue events during reconnection
            activeOperations: new Map(),       // Map of task_id -> operation data
            runningTimers: new Map(),          // Map of task_id -> timer interval ID
            lastEventTimestamp: 0,             // For state reconciliation
            storyExpansionState: new Map(),    // Track expanded stories for auto-expand
            pendingAnimations: new Set()       // Track elements with pending animations
        };

        // Toast Notifications (AC: #6)
        function showToast(message, type = 'info', title = null, duration = 5000) {
            const container = document.getElementById('toastContainer');
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;

            const icons = {
                error: '&#10060;',
                success: '&#10004;',
                warning: '&#9888;',
                info: '&#8505;'
            };

            toast.innerHTML = `
                <span class="toast-icon">${icons[type] || icons.info}</span>
                <div class="toast-content">
                    ${title ? `<div class="toast-title">${title}</div>` : ''}
                    <div class="toast-message">${message}</div>
                </div>
                <button class="toast-close" onclick="this.parentElement.remove()">&times;</button>
            `;

            container.appendChild(toast);

            // Auto-dismiss (errors stay longer or persist)
            if (type !== 'error' || duration > 0) {
                setTimeout(() => {
                    if (toast.parentElement) {
                        toast.style.animation = 'slideIn 0.3s ease reverse';
                        setTimeout(() => toast.remove(), 300);
                    }
                }, type === 'error' ? 10000 : duration);
            }
        }

        // ============================================================
        // WebSocket Connection Management (Epic 6 - Section 7)
        // ============================================================

        function connectSprintWebSocket() {
            const wsUrl = `ws://${window.location.host}/ws`;

            // Determine status based on reconnect attempts
            const isReconnecting = sprintRunState.wsReconnectAttempts > 0;
            updateWsConnectionStatus(isReconnecting ? 'reconnecting' : 'connecting');

            try {
                sprintRunState.ws = new WebSocket(wsUrl);

                sprintRunState.ws.onopen = () => {
                    console.log('WebSocket connected');
                    updateWsConnectionStatus('connected');

                    const wasReconnecting = sprintRunState.wsReconnectAttempts > 0;
                    sprintRunState.wsReconnectAttempts = 0;

                    if (wasReconnecting) {
                        addLogEntry({ type: 'system', message: 'Reconnected to server' }, 'system');
                        // Request full state for reconciliation
                        requestStateReconciliation();
                    } else {
                        addLogEntry({ type: 'system', message: 'Connected to server' }, 'system');
                    }

                    // Process any queued events
                    processEventQueue();
                };

                sprintRunState.ws.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);

                        // Track last event timestamp for reconciliation
                        if (data.timestamp) {
                            sprintRunState.lastEventTimestamp = Math.max(
                                sprintRunState.lastEventTimestamp,
                                data.timestamp
                            );
                        }

                        handleWebSocketEvent(data);
                    } catch (e) {
                        console.error('Failed to parse WebSocket message:', e);
                    }
                };

                sprintRunState.ws.onclose = (event) => {
                    console.log('WebSocket disconnected', event.code, event.reason);
                    updateWsConnectionStatus('disconnected');

                    // Stop all running timers on disconnect
                    stopAllTimers();

                    scheduleWsReconnect();
                };

                sprintRunState.ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    // Don't update status here - onclose will fire next
                };
            } catch (e) {
                console.error('Failed to create WebSocket:', e);
                updateWsConnectionStatus('disconnected');
                scheduleWsReconnect();
            }
        }

        function scheduleWsReconnect() {
            if (sprintRunState.wsReconnectTimer) return;

            // Exponential backoff: 1s, 2s, 4s, 8s, 16s, max 30s
            const baseDelay = 1000;
            const delay = Math.min(baseDelay * Math.pow(2, sprintRunState.wsReconnectAttempts), 30000);
            sprintRunState.wsReconnectAttempts++;

            console.log(`Scheduling reconnect attempt ${sprintRunState.wsReconnectAttempts} in ${delay}ms`);
            updateWsConnectionStatus('reconnecting');

            sprintRunState.wsReconnectTimer = setTimeout(() => {
                sprintRunState.wsReconnectTimer = null;
                connectSprintWebSocket();
            }, delay);
        }

        function updateWsConnectionStatus(status) {
            sprintRunState.connectionStatus = status;

            const dot = document.getElementById('wsConnectionDot');
            const text = document.getElementById('wsConnectionText');
            const statusContainer = document.querySelector('.ws-connection-status');

            if (!dot || !text) return;

            dot.className = 'ws-connection-dot ' + status;

            // Set appropriate text and tooltip
            const statusConfig = {
                connected: {
                    text: 'Connected',
                    tooltip: 'Connected to server'
                },
                connecting: {
                    text: 'Connecting...',
                    tooltip: 'Connecting to server...'
                },
                reconnecting: {
                    text: `Reconnecting (${sprintRunState.wsReconnectAttempts})...`,
                    tooltip: `Reconnecting to server (attempt ${sprintRunState.wsReconnectAttempts}). Click to retry now.`
                },
                disconnected: {
                    text: 'Disconnected',
                    tooltip: 'Disconnected from server. Click to retry.'
                }
            };

            const config = statusConfig[status] || statusConfig.disconnected;
            text.textContent = config.text;

            if (statusContainer) {
                statusContainer.title = config.tooltip;
                // Make clickable when disconnected or reconnecting
                statusContainer.style.cursor = (status === 'disconnected' || status === 'reconnecting')
                    ? 'pointer'
                    : 'default';
            }
        }

        // Click handler for connection status (retry on click)
        document.querySelector('.ws-connection-status')?.addEventListener('click', function() {
            const status = sprintRunState.connectionStatus;
            if (status === 'disconnected' || status === 'reconnecting') {
                // Cancel any pending reconnect
                if (sprintRunState.wsReconnectTimer) {
                    clearTimeout(sprintRunState.wsReconnectTimer);
                    sprintRunState.wsReconnectTimer = null;
                }
                // Reset attempts for immediate retry
                sprintRunState.wsReconnectAttempts = 0;
                connectSprintWebSocket();
            }
        });

        // Process queued events after reconnection
        function processEventQueue() {
            if (sprintRunState.eventQueue.length === 0) return;

            console.log(`Processing ${sprintRunState.eventQueue.length} queued events`);
            const queue = [...sprintRunState.eventQueue];
            sprintRunState.eventQueue = [];

            queue.forEach(event => handleWebSocketEvent(event));
        }

        // Queue event during reconnection
        function queueEvent(event) {
            // Only queue if we're reconnecting and have a batch running
            if (sprintRunState.connectionStatus === 'reconnecting' && sprintRunState.isRunning) {
                sprintRunState.eventQueue.push(event);
                // Limit queue size to prevent memory issues
                if (sprintRunState.eventQueue.length > 100) {
                    sprintRunState.eventQueue.shift();
                }
            }
        }

        // Request state reconciliation after reconnect
        function requestStateReconciliation() {
            if (sprintRunState.ws && sprintRunState.ws.readyState === WebSocket.OPEN) {
                // Send ping to get fresh state
                sprintRunState.ws.send(JSON.stringify({
                    type: 'ping',
                    last_timestamp: sprintRunState.lastEventTimestamp
                }));
            }
        }

        // ============================================================
        // Animation System (Epic 4 - UI/UX Spec Section 3)
        // ============================================================

        /**
         * Check if user prefers reduced motion
         * @returns {boolean}
         */
        function prefersReducedMotion() {
            return window.matchMedia('(prefers-reduced-motion: reduce)').matches;
        }

        /**
         * Apply a one-shot animation class to an element
         * Automatically removes the class after animation completes
         * @param {HTMLElement} element - The element to animate
         * @param {string} animationClass - The CSS animation class to apply
         * @param {number} duration - Animation duration in ms (default: 600)
         */
        function triggerAnimation(element, animationClass, duration = 600) {
            if (!element || prefersReducedMotion()) return;

            // Track pending animations to prevent duplicates
            const animKey = `${element.id || element.className}-${animationClass}`;
            if (sprintRunState.pendingAnimations.has(animKey)) return;

            sprintRunState.pendingAnimations.add(animKey);
            element.classList.add(animationClass);

            setTimeout(() => {
                element.classList.remove(animationClass);
                sprintRunState.pendingAnimations.delete(animKey);
            }, duration);
        }

        /**
         * Trigger completion flash animation (Section 3.4)
         * @param {HTMLElement} element - Element that just completed
         */
        function triggerCompletionAnimation(element) {
            triggerAnimation(element, 'just-completed', 600);
        }

        /**
         * Trigger error shake animation (Section 3.5)
         * @param {HTMLElement} element - Element with error
         */
        function triggerErrorAnimation(element) {
            triggerAnimation(element, 'error-shake', 500);
        }

        /**
         * Trigger new item slide animation (Section 3.1)
         * @param {HTMLElement} element - New element entering
         */
        function triggerNewItemAnimation(element) {
            triggerAnimation(element, 'new-item-slide', 300);
        }

        /**
         * Trigger status change highlight animation
         * @param {HTMLElement} element - Element with status change
         */
        function triggerStatusChangeAnimation(element) {
            triggerAnimation(element, 'status-changed', 600);
        }

        /**
         * Add running animation class to element (Section 3.2)
         * @param {HTMLElement} element - Element in running state
         */
        function startRunningAnimation(element) {
            if (!element || prefersReducedMotion()) return;
            element.classList.add('operation-running');
        }

        /**
         * Remove running animation class from element
         * @param {HTMLElement} element - Element no longer running
         */
        function stopRunningAnimation(element) {
            if (!element) return;
            element.classList.remove('operation-running');
        }

        /**
         * Add shimmer animation to progress bar (Section 3.3)
         * @param {HTMLElement} progressBar - Progress bar element
         */
        function startProgressAnimation(progressBar) {
            if (!progressBar || prefersReducedMotion()) return;
            progressBar.classList.add('progress-active');
        }

        /**
         * Remove shimmer animation from progress bar
         * @param {HTMLElement} progressBar - Progress bar element
         */
        function stopProgressAnimation(progressBar) {
            if (!progressBar) return;
            progressBar.classList.remove('progress-active');
        }

        /**
         * Expand/collapse an element with animation (Section 3.6)
         * @param {HTMLElement} element - Element to expand/collapse
         * @param {boolean} expand - true to expand, false to collapse
         */
        function toggleExpand(element, expand) {
            if (!element) return;

            if (expand) {
                element.classList.remove('collapsed');
                element.classList.add('expanded');
            } else {
                element.classList.remove('expanded');
                element.classList.add('collapsed');
            }

            // Update chevron if present
            const chevron = element.querySelector('.expand-chevron');
            if (chevron) {
                if (expand) {
                    chevron.classList.add('rotated');
                } else {
                    chevron.classList.remove('rotated');
                }
            }
        }

        /**
         * Apply new-entry animation to log entry
         * @param {HTMLElement} entry - Log entry element
         * @param {string} status - Status type (start, end, error, etc.)
         */
        function animateLogEntry(entry, status) {
            if (!entry || prefersReducedMotion()) return;

            entry.classList.add('new-entry');

            // Remove animation class after completion to allow re-animation
            setTimeout(() => {
                entry.classList.remove('new-entry');
            }, 300);
        }

        /**
         * Update story badge with animation
         * @param {string} storyKey - Story identifier
         * @param {string} newStatus - New status value
         */
        function animateStoryStatusChange(storyKey, newStatus) {
            // Find all badge elements for this story
            const escapedKey = CSS.escape(storyKey);
            const badges = document.querySelectorAll(`[data-story-key="${escapedKey}"] .badge, .badge[data-story="${escapedKey}"]`);

            badges.forEach(badge => {
                if (!prefersReducedMotion()) {
                    triggerStatusChangeAnimation(badge);
                }
            });
        }

        // WebSocket Event Handling (AC: #5)
        function handleWebSocketEvent(event) {
            const { type, payload, timestamp } = event;

            switch (type) {
                case 'init':
                    // Initial state hydration from server (Epic 6)
                    if (payload.batch) {
                        handleBatchState(payload.batch);
                    }
                    if (payload.events) {
                        // Sort events by timestamp for proper ordering
                        const sortedEvents = [...payload.events].sort((a, b) =>
                            (a.timestamp || 0) - (b.timestamp || 0));
                        sortedEvents.forEach(e => addLogEntry(e, getEventStatus(e)));
                        // Restore active operations from historical events
                        restoreActiveOperationsFromEvents(sortedEvents);
                    }
                    break;

                case 'batch:start':
                    sprintRunState.isRunning = true;
                    sprintRunState.isStopping = false;
                    sprintRunState.currentBatchId = payload.batch_id;
                    sprintRunState.maxCycles = payload.max_cycles || 0;
                    sprintRunState.currentCycle = 0;
                    // Epic 6: Clear stale state from previous batch
                    sprintRunState.activeOperations.clear();
                    stopAllTimers();
                    updateSprintUI();
                    showProgressSection(true);
                    addLogEntry({ type, payload, timestamp }, 'start');
                    updateTabIndicator(true);
                    // Epic 6: Animate progress section entrance
                    triggerNewItemAnimation(document.getElementById('sprintProgressSection'));
                    break;

                case 'batch:end':
                    sprintRunState.isRunning = false;
                    sprintRunState.isStopping = false;
                    sprintRunState.currentOperation = null;
                    // Epic 6: Stop all timers and clear active operations
                    stopAllTimers();
                    sprintRunState.activeOperations.clear();
                    renderActiveOperationsDisplay();
                    updateSprintUI();
                    // Epic 4: Stop progress animation and trigger completion
                    const progressFill = document.getElementById('sprintProgressFill');
                    if (progressFill) {
                        stopProgressAnimation(progressFill);
                        progressFill.classList.remove('progress-indeterminate');
                    }
                    // Trigger completion animation on progress section
                    const progressSection = document.getElementById('sprintProgressSection');
                    if (progressSection && payload.status === 'completed') {
                        triggerCompletionAnimation(progressSection);
                    }
                    addLogEntry({ type, payload, timestamp }, payload.status === 'completed' ? 'end' : 'system');
                    updateTabIndicator(false);
                    if (payload.status === 'completed') {
                        showToast(`Batch completed: ${payload.cycles_completed} cycles`, 'success', 'Sprint Complete');
                    } else if (payload.status === 'stopped') {
                        showToast('Batch stopped by user', 'warning', 'Sprint Stopped');
                    } else if (payload.status === 'error') {
                        showToast('Batch ended with errors', 'error', 'Sprint Error');
                    }
                    break;

                case 'cycle:start':
                    sprintRunState.currentCycle = payload.cycle_number;
                    sprintRunState.activeStories = payload.story_keys || [];
                    updateProgress();
                    updateActiveStories();
                    addLogEntry({ type, payload, timestamp }, 'start');
                    break;

                case 'cycle:end':
                    updateProgress();
                    addLogEntry({ type, payload, timestamp }, 'end');
                    break;

                case 'command:start':
                    sprintRunState.currentOperation = `${payload.story_key} ${payload.command} (${payload.task_id})`;
                    updateCurrentOperation();
                    // Epic 6: Track active operations and start timer
                    sprintRunState.activeOperations.set(payload.task_id, {
                        storyKey: payload.story_key,
                        command: payload.command,
                        taskId: payload.task_id,
                        message: '',
                        startTime: timestamp || Date.now()
                    });
                    startCommandTimer(payload.task_id, timestamp || Date.now());
                    renderActiveOperationsDisplay();
                    autoExpandStoryRow(payload.story_key);
                    addLogEntry({ type, payload, timestamp }, 'start');
                    break;

                case 'command:progress':
                    // Epic 6: Update active operation message
                    const progOp = sprintRunState.activeOperations.get(payload.task_id);
                    if (progOp) {
                        progOp.message = payload.message || '';
                        updateActiveOperationMessage(payload.task_id, payload.message);
                    }
                    addLogEntry({ type, payload, timestamp }, 'progress');
                    break;

                case 'command:end':
                    // Epic 6: Stop timer and animate completion
                    stopCommandTimer(payload.task_id);
                    const opElement = document.querySelector(`[data-operation-task="${CSS.escape(payload.task_id)}"]`);
                    if (opElement) {
                        if (payload.status === 'error' || payload.status === 'failed') {
                            triggerErrorAnimation(opElement);
                        } else {
                            triggerCompletionAnimation(opElement);
                        }
                        setTimeout(() => {
                            sprintRunState.activeOperations.delete(payload.task_id);
                            renderActiveOperationsDisplay();
                        }, 600);
                    } else {
                        sprintRunState.activeOperations.delete(payload.task_id);
                        renderActiveOperationsDisplay();
                    }
                    if (sprintRunState.currentOperation &&
                        sprintRunState.currentOperation.includes(payload.story_key)) {
                        sprintRunState.currentOperation = null;
                        updateCurrentOperation();
                    }
                    // Trigger error animation if command failed
                    if (payload.status === 'error' || payload.status === 'failed') {
                        const opCard = document.getElementById('sprintCurrentOp')?.closest('.card, .active-operation-card');
                        if (opCard) triggerErrorAnimation(opCard);
                    }
                    addLogEntry({ type, payload, timestamp }, (payload.status === 'error' || payload.status === 'failed') ? 'error' : 'end');
                    break;

                case 'story:status':
                    updateStoryBadge(payload.story_key, payload.new_status);
                    addLogEntry({ type, payload, timestamp }, 'system');
                    break;

                case 'error':
                    addLogEntry({ type, payload, timestamp }, 'error');
                    showToast(payload.message, 'error', 'Error');
                    // Epic 4: Trigger error animation on error events
                    const errorCard = document.getElementById('sprintCurrentOp')?.closest('.card, .active-operation-card');
                    if (errorCard) triggerErrorAnimation(errorCard);
                    break;

                case 'context:create':
                case 'context:refresh':
                case 'context:complete':
                    addLogEntry({ type, payload, timestamp }, 'system');
                    break;

                case 'batch:warning':
                    // Handle batch warning events
                    // Support both 'message' (schema) and 'warning' (legacy) keys
                    const warningMessage = payload.message || payload.warning || 'Warning occurred';
                    const warningType = payload.warning_type || 'general';
                    addLogEntry({ type, payload, timestamp }, 'warning');
                    // Adjust toast type based on warning_type
                    const toastType = warningType === 'context_unavailable' ? 'info' : 'warning';
                    showToast(warningMessage, toastType, `Warning: ${warningType}`);
                    break;

                case 'pong':
                    // Server acknowledged ping - no action needed
                    break;

                default:
                    console.log('Unknown WebSocket event:', type, payload);
            }
        }

        function getEventStatus(event) {
            // Handle database event format (has 'status' field)
            if (event.status) {
                const s = event.status.toLowerCase();
                if (s === 'start') return 'start';
                if (s === 'end' || s === 'complete' || s === 'completed') return 'end';
                if (s === 'progress') return 'progress';
                if (s === 'error' || s === 'failed') return 'error';
                return 'system';
            }
            // Handle WebSocket event format (has 'type' field)
            if (event.type?.includes('start')) return 'start';
            if (event.type?.includes('end') || event.type?.includes('complete')) return 'end';
            if (event.type?.includes('progress')) return 'progress';
            if (event.type?.includes('error')) return 'error';
            return 'system';
        }

        function handleBatchState(batch) {
            if (batch && batch.status === 'running') {
                sprintRunState.isRunning = true;
                sprintRunState.currentBatchId = batch.id;
                sprintRunState.maxCycles = batch.max_cycles;
                sprintRunState.currentCycle = batch.cycles_completed || 0;
                updateSprintUI();
                showProgressSection(true);
                updateTabIndicator(true);
            }
        }

        // ============================================================
        // Timer System (Epic 6 - Section 7.3)
        // ============================================================

        function startCommandTimer(taskId, startTime) {
            stopCommandTimer(taskId);
            const startTs = typeof startTime === 'number' ? startTime : Date.now();
            const updateTimer = () => {
                const elapsed = Math.floor((Date.now() - startTs) / 1000);
                updateTimerDisplay(taskId, formatTimerDuration(elapsed));
            };
            updateTimer();
            const intervalId = setInterval(updateTimer, 1000);
            sprintRunState.runningTimers.set(taskId, intervalId);
        }

        function stopCommandTimer(taskId) {
            const intervalId = sprintRunState.runningTimers.get(taskId);
            if (intervalId) {
                clearInterval(intervalId);
                sprintRunState.runningTimers.delete(taskId);
            }
        }

        function stopAllTimers() {
            sprintRunState.runningTimers.forEach(intervalId => clearInterval(intervalId));
            sprintRunState.runningTimers.clear();
        }

        function formatTimerDuration(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function updateTimerDisplay(taskId, timeText) {
            const timerEl = document.querySelector(`[data-timer-task="${CSS.escape(taskId)}"]`);
            if (timerEl) timerEl.textContent = timeText;
        }

        // ============================================================
        // Active Operations Display (Epic 6 - Section 2.3)
        // ============================================================

        function renderActiveOperationsDisplay() {
            const container = document.getElementById('sprintActiveStories');
            if (!container) return;
            if (sprintRunState.activeOperations.size === 0) {
                container.innerHTML = sprintRunState.activeStories.length > 0
                    ? sprintRunState.activeStories.map(key =>
                        `<span class="sprint-story-badge in-progress" data-story="${escapeHtml(key)}">${escapeHtml(key)}</span>`).join('')
                    : '';
                return;
            }
            let html = '';
            sprintRunState.activeOperations.forEach((op, taskId) => {
                const cmdColors = getCommandTypeColors(op.command);
                html += `<div class="active-operation-card operation-running" data-operation-task="${escapeHtml(taskId)}">
                    <div class="active-operation-header">
                        <span class="active-operation-story">${escapeHtml(op.storyKey)}</span>
                        <span class="active-operation-timer" data-timer-task="${escapeHtml(taskId)}">0:00</span>
                    </div>
                    <span class="active-operation-command" style="background: ${cmdColors.bg}; color: ${cmdColors.text};">${escapeHtml(op.command)}</span>
                    <div class="active-operation-progress"><div class="active-operation-progress-fill progress-active"></div></div>
                    <div class="active-operation-message">${escapeHtml(op.message || 'Starting...')}</div>
                </div>`;
            });
            container.innerHTML = html;
            container.querySelectorAll('.active-operation-card').forEach(card => triggerNewItemAnimation(card));
        }

        function updateActiveOperationMessage(taskId, message) {
            const msgEl = document.querySelector(`[data-operation-task="${CSS.escape(taskId)}"] .active-operation-message`);
            if (msgEl) msgEl.textContent = message || '';
        }

        function getCommandTypeColors(command) {
            const colors = {
                'sprint-create-story': { bg: '#dbeafe', text: '#1e40af' },
                'create-story': { bg: '#dbeafe', text: '#1e40af' },
                'sprint-story-review': { bg: '#fef3c7', text: '#92400e' },
                'story-review': { bg: '#fef3c7', text: '#92400e' },
                'sprint-create-tech-spec': { bg: '#e0e7ff', text: '#3730a3' },
                'create-tech-spec': { bg: '#e0e7ff', text: '#3730a3' },
                'sprint-tech-spec-review': { bg: '#ede9fe', text: '#5b21b6' },
                'tech-spec-review': { bg: '#ede9fe', text: '#5b21b6' },
                'sprint-dev-story': { bg: '#dcfce7', text: '#166534' },
                'dev-story': { bg: '#dcfce7', text: '#166534' },
                'sprint-code-review': { bg: '#f3e8ff', text: '#6b21a8' },
                'code-review': { bg: '#f3e8ff', text: '#6b21a8' },
                'sprint-commit': { bg: '#ccfbf1', text: '#115e59' },
                'commit': { bg: '#ccfbf1', text: '#115e59' }
            };
            return colors[command] || { bg: '#e8e7e5', text: '#787774' };
        }

        // ============================================================
        // State Restoration (Epic 6 - Section 7.4)
        // ============================================================

        function restoreActiveOperationsFromEvents(events) {
            const activeOps = new Map();
            events.forEach(event => {
                const type = event.type;
                const payload = event.payload || event;
                if (type === 'command:start') {
                    activeOps.set(payload.task_id, {
                        storyKey: payload.story_key, command: payload.command,
                        taskId: payload.task_id, message: '', startTime: event.timestamp || Date.now()
                    });
                } else if (type === 'command:end') {
                    activeOps.delete(payload.task_id);
                } else if (type === 'command:progress' && activeOps.has(payload.task_id)) {
                    activeOps.get(payload.task_id).message = payload.message || '';
                }
            });
            sprintRunState.activeOperations = activeOps;
            activeOps.forEach((op, taskId) => startCommandTimer(taskId, op.startTime));
            renderActiveOperationsDisplay();
        }

        function autoExpandStoryRow(storyKey) {
            sprintRunState.storyExpansionState.set(storyKey, true);
            const storyRow = document.querySelector(`[data-story-id="${CSS.escape(storyKey)}"]`);
            if (storyRow && !storyRow.classList.contains('expanded')) {
                const expandIcon = storyRow.querySelector('.timeline-row-expand');
                if (expandIcon) expandIcon.click();
            }
        }

        // Event Log (AC: #5)
        function addLogEntry(event, status) {
            const entries = document.getElementById('sprintLogEntries');

            // Remove empty state message if present
            const emptyMsg = entries.querySelector('.log-empty');
            if (emptyMsg) emptyMsg.remove();

            const entry = document.createElement('div');
            entry.className = `log-entry ${status}`;

            // Handle timestamp - database events use seconds, WebSocket uses milliseconds
            let timestamp;
            if (event.timestamp) {
                // Database timestamps are in seconds, WebSocket in milliseconds
                const ts = event.timestamp < 10000000000 ? event.timestamp * 1000 : event.timestamp;
                timestamp = formatLogTime(ts);
            } else {
                timestamp = formatLogTime(Date.now());
            }

            // Handle both WebSocket format (payload object) and database format (flat fields)
            // Database events have: story_key, command, task_id, status, message directly on event
            // WebSocket events have: type, payload: { story_key, command, task_id, message }
            const payload = event.payload || {};
            const storyKey = payload.story_key || event.story_key || '-';
            const command = payload.command || event.command || event.type?.split(':')[0] || '-';
            const taskId = payload.task_id || event.task_id || '-';
            const message = payload.message || event.message || '';

            if (event.type === 'system' || status === 'system') {
                entry.innerHTML = `
                    <span class="log-timestamp">${timestamp}</span>
                    <span class="log-message">${message || event.type || 'System event'}</span>
                `;
            } else {
                entry.innerHTML = `
                    <span class="log-timestamp">${timestamp}</span>
                    <span class="log-story-key">${storyKey}</span>
                    <span class="log-command">${command}</span>
                    <span class="log-task-id">${taskId}</span>
                    <span class="log-status ${status}">${status}</span>
                    <span class="log-message">${message}</span>
                `;
            }

            // Insert at top (newest first)
            entries.insertBefore(entry, entries.firstChild);

            // Trigger animation for new log entry (Epic 4 - Section 3.1)
            animateLogEntry(entry, status);

            // Auto-scroll handling
            if (sprintRunState.autoScroll && !sprintRunState.userScrolled) {
                const logContainer = document.getElementById('sprintLog');
                logContainer.scrollTop = 0;
            }

            // Limit entries to prevent memory issues
            while (entries.children.length > 500) {
                entries.removeChild(entries.lastChild);
            }
        }

        function formatLogTime(timestamp) {
            const date = new Date(timestamp);
            return date.toLocaleTimeString('en-US', { hour12: false });
        }

        function clearSprintLog() {
            const entries = document.getElementById('sprintLogEntries');
            entries.innerHTML = '<div class="log-empty">Log cleared. Events will appear here.</div>';
        }

        function toggleAutoScroll() {
            sprintRunState.autoScroll = !sprintRunState.autoScroll;
            document.getElementById('autoScrollState').textContent = sprintRunState.autoScroll ? 'ON' : 'OFF';
        }

        // Auto-scroll detection
        document.getElementById('sprintLog')?.addEventListener('scroll', function() {
            const isAtTop = this.scrollTop < 50;
            sprintRunState.userScrolled = !isAtTop;
        });

        // Control Panel (AC: #2, #3, #4)
        function updateSprintUI() {
            const startBtn = document.getElementById('sprintStartBtn');
            const stopBtn = document.getElementById('sprintStopBtn');
            const batchInput = document.getElementById('batchSizeInput');
            const runAllCheckbox = document.getElementById('runAllCheckbox');
            const statusValue = document.getElementById('sprintStatusValue');

            if (sprintRunState.isRunning) {
                startBtn.disabled = true;
                stopBtn.disabled = sprintRunState.isStopping;
                batchInput.disabled = true;
                runAllCheckbox.disabled = true;

                if (sprintRunState.isStopping) {
                    statusValue.textContent = 'Stopping...';
                    statusValue.className = 'sprint-status-value stopping';
                } else {
                    const cycleText = sprintRunState.maxCycles > 0
                        ? `Running cycle ${sprintRunState.currentCycle}/${sprintRunState.maxCycles}`
                        : `Running cycle ${sprintRunState.currentCycle}`;
                    statusValue.textContent = cycleText;
                    statusValue.className = 'sprint-status-value running';
                }
            } else {
                startBtn.disabled = false;
                stopBtn.disabled = true;
                batchInput.disabled = runAllCheckbox.checked;
                runAllCheckbox.disabled = false;
                statusValue.textContent = 'Idle';
                statusValue.className = 'sprint-status-value idle';
            }
        }

        function updateCurrentOperation() {
            const opDisplay = document.getElementById('sprintCurrentOp');
            const opCard = opDisplay?.closest('.card, .active-operation-card');

            opDisplay.textContent = sprintRunState.currentOperation || '-';

            // Epic 4: Trigger running animation when operation is active
            if (opCard) {
                if (sprintRunState.currentOperation) {
                    startRunningAnimation(opCard);
                } else {
                    stopRunningAnimation(opCard);
                    // Trigger completion animation when operation ends
                    triggerCompletionAnimation(opCard);
                }
            }
        }

        function showProgressSection(show) {
            const section = document.getElementById('sprintProgressSection');
            section.style.display = show ? 'block' : 'none';
        }

        function updateProgress() {
            const fill = document.getElementById('sprintProgressFill');
            const stats = document.getElementById('sprintProgressStats');

            // Epic 4: Handle unlimited mode with indeterminate progress
            const isUnlimited = sprintRunState.maxCycles <= 0;

            if (isUnlimited) {
                // Use indeterminate progress animation for unlimited mode
                fill.style.width = '100%';
                if (!fill.classList.contains('progress-indeterminate')) {
                    fill.classList.remove('progress-active');
                    fill.classList.add('progress-indeterminate');
                }
            } else {
                const progress = (sprintRunState.currentCycle / sprintRunState.maxCycles) * 100;
                fill.style.width = `${Math.min(progress, 100)}%`;
                fill.classList.remove('progress-indeterminate');

                // Add shimmer animation when running
                if (sprintRunState.isRunning && !fill.classList.contains('progress-active')) {
                    startProgressAnimation(fill);
                } else if (!sprintRunState.isRunning) {
                    stopProgressAnimation(fill);
                }
            }

            stats.textContent = sprintRunState.maxCycles > 0
                ? `${sprintRunState.currentCycle}/${sprintRunState.maxCycles} cycles`
                : `${sprintRunState.currentCycle} cycles`;
        }

        function updateActiveStories() {
            const container = document.getElementById('sprintActiveStories');
            container.innerHTML = sprintRunState.activeStories.map(key =>
                `<span class="sprint-story-badge in-progress" data-story="${key}">${key}</span>`
            ).join('');
        }

        function updateStoryBadge(storyKey, status) {
            // Use CSS.escape for safe selector (Epic 6 - Fix 1.3)
            const escapedKey = CSS.escape(storyKey);
            const badge = document.querySelector(`.sprint-story-badge[data-story="${escapedKey}"]`);
            if (badge) {
                badge.className = `sprint-story-badge ${status === 'done' ? 'done' : 'in-progress'}`;
                // Trigger status change animation (Epic 4 - Status transitions)
                triggerStatusChangeAnimation(badge);
            }
        }

        function updateTabIndicator(isActive) {
            const countSpan = document.getElementById('sprintrunCount');
            if (isActive) {
                countSpan.textContent = '';
                countSpan.classList.add('active');
            } else {
                countSpan.textContent = '';
                countSpan.classList.remove('active');
            }
        }

        // Start/Stop Actions (AC: #3, #4)
        async function startSprint() {
            const batchInput = document.getElementById('batchSizeInput');
            const runAllCheckbox = document.getElementById('runAllCheckbox');

            const batchSize = runAllCheckbox.checked ? 'all' : parseInt(batchInput.value, 10);

            if (!runAllCheckbox.checked && (isNaN(batchSize) || batchSize < 1)) {
                showToast('Please enter a valid batch size (positive number)', 'warning');
                return;
            }

            try {
                const response = await fetch('/api/orchestrator/start', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ batch_size: batchSize })
                });

                if (!response.ok) {
                    const error = await response.text();
                    throw new Error(error || 'Failed to start sprint');
                }

                // UI updates will come via WebSocket
                showToast('Sprint started', 'success');

            } catch (error) {
                console.error('Failed to start sprint:', error);
                showToast(error.message || 'Failed to start sprint', 'error');
            }
        }

        async function stopSprint() {
            sprintRunState.isStopping = true;
            updateSprintUI();

            try {
                const response = await fetch('/api/orchestrator/stop', {
                    method: 'POST'
                });

                if (!response.ok) {
                    throw new Error('Failed to stop sprint');
                }

                showToast('Stop signal sent. Waiting for current operation to complete...', 'warning');

            } catch (error) {
                console.error('Failed to stop sprint:', error);
                showToast(error.message || 'Failed to stop sprint', 'error');
                sprintRunState.isStopping = false;
                updateSprintUI();
            }
        }

        // Event Listeners
        document.getElementById('sprintStartBtn')?.addEventListener('click', startSprint);
        document.getElementById('sprintStopBtn')?.addEventListener('click', stopSprint);

        document.getElementById('runAllCheckbox')?.addEventListener('change', function() {
            const batchInput = document.getElementById('batchSizeInput');
            batchInput.disabled = this.checked;
            if (this.checked) {
                batchInput.value = '';
            } else {
                batchInput.value = localStorage.getItem('dashboard-sprintrun-batchsize') || '2';
            }
            saveSprintRunPrefs();
        });

        document.getElementById('batchSizeInput')?.addEventListener('change', saveSprintRunPrefs);

        // Persistence (Story 5-SR-7 pattern)
        function saveSprintRunPrefs() {
            const batchInput = document.getElementById('batchSizeInput');
            const runAllCheckbox = document.getElementById('runAllCheckbox');

            if (batchInput.value && !runAllCheckbox.checked) {
                localStorage.setItem('dashboard-sprintrun-batchsize', batchInput.value);
            }
            localStorage.setItem('dashboard-sprintrun-runall', runAllCheckbox.checked);
        }

        function restoreSprintRunPrefs() {
            const savedBatchSize = localStorage.getItem('dashboard-sprintrun-batchsize');
            const savedRunAll = localStorage.getItem('dashboard-sprintrun-runall') === 'true';

            if (savedBatchSize) {
                document.getElementById('batchSizeInput').value = savedBatchSize;
            }
            document.getElementById('runAllCheckbox').checked = savedRunAll;
            document.getElementById('batchSizeInput').disabled = savedRunAll;
        }

        // Initialize Sprint Run Tab
        function initSprintRunTab() {
            restoreSprintRunPrefs();
            connectSprintWebSocket();
            updateSprintUI();
        }

        // Initialize when DOM is ready
        initSprintRunTab();

        // ============================================================
        // COMPONENT SYSTEM (Epic 3)
        // Reusable UI component factory functions
        // ============================================================

        /** Create a Batch Card for history sidebar */
        function createBatchCard(batch, isSelected = false, isCurrent = false) {
            const statusClass = batch.status || 'completed';
            const duration = batch.duration_seconds ? formatDuration(batch.duration_seconds) : (batch.status === 'running' ? 'running...' : '-');
            let classes = 'batch-card';
            if (isCurrent) classes += ' batch-card--current';
            if (isSelected) classes += ' batch-card--selected';
            return `<div class="${classes}" data-batch-id="${batch.id}"><div class="batch-card__header"><span class="batch-card__status-icon batch-card__status-icon--${statusClass}"></span><span class="batch-card__id">Batch #${escapeHtml(batch.id)}</span></div><div class="batch-card__label">${escapeHtml(batch.status)}</div><div class="batch-card__stats">${batch.cycles_completed || 0}/${batch.max_cycles || 0} cycles</div><div class="batch-card__duration">${escapeHtml(duration)}</div></div>`;
        }

        /** Create a Story Card (expandable) */
        function createStoryCard(story, isExpanded = false) {
            const storyKey = story.storyId || story.id || '';
            const duration = story.duration || story.totalDuration || '';
            const commands = story.commands || story.steps || [];
            const expandedClass = isExpanded ? 'story-card--expanded' : '';
            const commandsHtml = commands.map(cmd => createCommandGroup(cmd)).join('');
            return `<div class="story-card ${expandedClass}" data-story-key="${escapeHtml(storyKey)}"><div class="story-card__header" onclick="toggleStoryCard('${escapeJsString(storyKey)}')"><span class="story-card__chevron">&#9654;</span><span class="story-card__key">${escapeHtml(storyKey)}</span><span class="story-card__title">${escapeHtml(story.name || '')}</span>${createStatusBadge(story.status || 'pending')}<span class="story-card__duration">${escapeHtml(duration)}</span></div><div class="story-card__content"><div class="story-card__commands">${commandsHtml}</div></div></div>`;
        }

        /** Toggle story card expansion */
        function toggleStoryCard(storyKey) {
            const card = document.querySelector(`.story-card[data-story-key="${CSS.escape(storyKey)}"]`);
            if (card) { card.classList.toggle('story-card--expanded'); saveUIState(); }
        }

        /** Create a Command Group (expandable with tasks) */
        function createCommandGroup(cmd, isExpanded = true) {
            const command = cmd.command || cmd.stepName || '';
            const duration = cmd.totalDuration || cmd.duration || '';
            const tasks = cmd.tasks || [];
            const expandedClass = isExpanded ? 'command-group-v2--expanded' : '';
            const tasksHtml = tasks.map(task => createTaskRow(task)).join('');
            if (tasks.length <= 1) {
                return `<div class="command-group-v2 ${expandedClass}"><div class="command-group-v2__header">${createCommandBadge(command)}<span class="command-group-v2__duration">${escapeHtml(duration)}</span></div></div>`;
            }
            return `<div class="command-group-v2 ${expandedClass}" data-command="${escapeHtml(command)}"><div class="command-group-v2__header" onclick="toggleCommandGroup(this)"><span class="command-group-v2__chevron">&#9654;</span>${createCommandBadge(command)}<span class="command-group-v2__duration">${escapeHtml(duration)}</span></div><div class="command-group-v2__tasks">${tasksHtml}</div></div>`;
        }

        /** Toggle command group expansion */
        function toggleCommandGroup(headerEl) {
            const group = headerEl.closest('.command-group-v2');
            if (group) group.classList.toggle('command-group-v2--expanded');
        }

        /** Create a Task Row */
        function createTaskRow(task) {
            const taskId = task.taskId || task.id || '';
            const duration = task.duration || '';
            const message = task.message || '';
            const status = task.status || 'pending';
            return `<div class="task-row-v2" data-task-id="${escapeHtml(taskId)}"><span class="task-row-v2__name">${escapeHtml(taskId)}</span>${createStatusBadge(status)}<span class="task-row-v2__duration">${escapeHtml(duration)}</span>${message ? `<span class="task-row-v2__message" title="${escapeHtml(message)}">${escapeHtml(message)}</span>` : ''}</div>`;
        }

        /** Create a Status Badge */
        function createStatusBadge(status) {
            const normalizedStatus = normalizeStatusForClass(status);
            const displayStatus = status.replace(/-/g, ' ');
            return `<span class="status-badge-v2 status-badge-v2--${normalizedStatus}"><span class="status-badge-v2__icon"></span>${escapeHtml(displayStatus)}</span>`;
        }

        /** Create a Command Badge */
        function createCommandBadge(command, solid = false) {
            const commandType = getCommandType(command);
            const solidClass = solid ? 'command-badge--solid' : '';
            return `<span class="command-badge command-badge--${commandType} ${solidClass}">${escapeHtml(command)}</span>`;
        }

        /** Get command type for styling */
        function getCommandType(command) {
            if (!command) return 'default';
            const baseCommand = command.split(' ')[0].split('#')[0].trim().toLowerCase();
            const knownCommands = ['create-story', 'story-review', 'create-tech-spec', 'tech-spec-review', 'dev-story', 'code-review', 'commit'];
            return knownCommands.includes(baseCommand) ? baseCommand : 'default';
        }

        /** Create a Progress Bar */
        function createProgressBar(progress, options = {}) {
            const { variant = 'success', size = 'normal', active = false, unlimited = false } = options;
            let containerClasses = 'progress-bar-v2';
            if (size === 'thin') containerClasses += ' progress-bar-v2--thin';
            if (size === 'thick') containerClasses += ' progress-bar-v2--thick';
            if (active) containerClasses += ' progress-bar-v2--active';
            if (unlimited) containerClasses += ' progress-bar-v2--unlimited';
            const fillClass = `progress-bar-v2__fill progress-bar-v2__fill--${variant}`;
            const width = unlimited ? 30 : Math.min(100, Math.max(0, progress));
            return `<div class="${containerClasses}"><div class="${fillClass}" style="width: ${width}%"></div></div>`;
        }

        /** Create a Control Button */
        function createControlButton(type, label, options = {}) {
            const { disabled = false, icon = '', onclick = '' } = options;
            const iconHtml = icon ? `<span class="control-btn__icon">${icon}</span>` : '';
            const disabledAttr = disabled ? 'disabled' : '';
            const onclickAttr = onclick ? `onclick="${escapeHtml(onclick)}"` : '';
            return `<button class="control-btn control-btn--${type}" ${disabledAttr} ${onclickAttr}>${iconHtml}${escapeHtml(label)}</button>`;
        }

        /** Create an Operation Card */
        function createOperationCard(operation) {
            const storyKey = operation.storyKey || operation.storyId || '';
            const command = operation.command || '';
            const message = operation.message || '';
            const elapsedSeconds = operation.elapsedSeconds || 0;
            const elapsedStr = formatDuration(elapsedSeconds);
            return `<div class="operation-card operation-card--running" data-story-key="${escapeHtml(storyKey)}"><div class="operation-card__header"><span class="operation-card__story-key">${escapeHtml(storyKey)}</span>${createCommandBadge(command, true)}<span class="operation-card__timer">${escapeHtml(elapsedStr)}</span></div><div class="operation-card__progress"><div class="operation-card__progress-bar"><div class="operation-card__progress-fill"></div></div></div>${message ? `<div class="operation-card__message">${escapeHtml(message)}</div>` : ''}</div>`;
        }

        /** Create a Connection Indicator */
        function createConnectionIndicator(status, text) {
            return `<div class="connection-indicator connection-indicator--${status}"><span class="connection-indicator__icon"></span><span class="connection-indicator__text">${escapeHtml(text)}</span></div>`;
        }

        /** Update connection indicator in the UI */
        function updateConnectionIndicator(status, text) {
            const indicator = document.getElementById('connectionIndicator');
            if (indicator) {
                indicator.className = `connection-indicator connection-indicator--${status}`;
                const textEl = indicator.querySelector('.connection-indicator__text');
                if (textEl) textEl.textContent = text;
            }
        }

        /** Animation helpers */
        function animateElement(element, animationClass, duration = 500) {
            const el = typeof element === 'string' ? document.querySelector(element) : element;
            if (!el) return;
            el.classList.add(animationClass);
            setTimeout(() => el.classList.remove(animationClass), duration);
        }
        function flashSuccess(element) { animateElement(element, 'just-completed', 800); }
        function shakeError(element) { animateElement(element, 'error-shake', 500); }
        function slideInNew(element) { animateElement(element, 'new-item-slide', 300); }

        // ============================================================
        // BATCH HISTORY SIDEBAR (Epic 5)
        // ============================================================

        const batchHistoryState = {
            batches: [],
            selectedBatchId: null,
            currentBatchId: null,
            isLoading: false,
            hasMore: true,
            offset: 0,
            limit: 20,
            sidebarCollapsed: false,
            viewingPastBatch: false
        };

        // Format batch time
        function formatBatchTime(timestamp) {
            if (!timestamp) return '-';
            const date = new Date(timestamp);
            return date.toLocaleString('en-US', {
                month: 'short',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });
        }

        // Format batch duration
        function formatBatchDuration(seconds) {
            if (!seconds || seconds <= 0) return '-';
            if (seconds < 60) return `${Math.round(seconds)}s`;
            if (seconds < 3600) {
                const mins = Math.floor(seconds / 60);
                const secs = Math.round(seconds % 60);
                return secs > 0 ? `${mins}m ${secs}s` : `${mins}m`;
            }
            const hours = Math.floor(seconds / 3600);
            const mins = Math.floor((seconds % 3600) / 60);
            return mins > 0 ? `${hours}h ${mins}m` : `${hours}h`;
        }

        // Toggle sidebar collapse
        function toggleBatchSidebar() {
            const sidebar = document.getElementById('batchSidebar');
            if (!sidebar) return;
            batchHistoryState.sidebarCollapsed = !batchHistoryState.sidebarCollapsed;
            sidebar.classList.toggle('collapsed', batchHistoryState.sidebarCollapsed);
            localStorage.setItem('batch-sidebar-collapsed', batchHistoryState.sidebarCollapsed);
        }

        // Render batch list
        function renderBatchList() {
            const container = document.getElementById('batchSidebarContent');
            if (!container) return;

            if (batchHistoryState.isLoading && batchHistoryState.batches.length === 0) {
                container.innerHTML = '<div class="batch-sidebar__loading">Loading batches...</div>';
                return;
            }

            if (batchHistoryState.batches.length === 0) {
                container.innerHTML = '<div class="batch-sidebar__empty">No batch runs yet</div>';
                return;
            }

            let html = '';
            batchHistoryState.batches.forEach((batch, idx) => {
                const isCurrent = batch.status === 'running';
                const isSelected = batch.id === batchHistoryState.selectedBatchId;
                const statusClass = batch.status || 'completed';

                let classes = 'batch-sidebar__item';
                if (isCurrent) classes += ' batch-sidebar__item--current';
                if (isSelected) classes += ' batch-sidebar__item--selected';

                const duration = batch.duration_seconds
                    ? formatBatchDuration(batch.duration_seconds)
                    : (isCurrent ? 'running...' : '-');

                html += `
                    <div class="${classes}" data-batch-id="${batch.id}" onclick="selectBatch(${batch.id})">
                        <div class="batch-sidebar__item-header">
                            <span class="batch-sidebar__status-dot batch-sidebar__status-dot--${statusClass}"></span>
                            <span class="batch-sidebar__batch-id">Batch #${batch.id}</span>
                            <span class="batch-sidebar__status-label">${batch.status}</span>
                        </div>
                        <div class="batch-sidebar__stats">
                            ${batch.cycles_completed}/${batch.max_cycles} cycles, ${batch.story_count || 0} stories
                        </div>
                        <div class="batch-sidebar__duration">${duration}</div>
                    </div>
                `;
            });

            container.innerHTML = html;

            // Update load more button
            const loadMoreBtn = document.getElementById('loadMoreBatches');
            if (loadMoreBtn) {
                loadMoreBtn.disabled = !batchHistoryState.hasMore || batchHistoryState.isLoading;
                loadMoreBtn.textContent = batchHistoryState.isLoading ? 'Loading...' : 'Load More...';
            }
        }

        // Fetch batch list from API
        async function fetchBatches(append = false) {
            if (batchHistoryState.isLoading) return;

            batchHistoryState.isLoading = true;
            if (!append) {
                batchHistoryState.offset = 0;
                renderBatchList();
            }

            try {
                const url = `/api/batches?limit=${batchHistoryState.limit}&offset=${batchHistoryState.offset}`;
                const response = await fetch(url);
                if (!response.ok) throw new Error('Failed to fetch batches');

                const data = await response.json();

                if (append) {
                    batchHistoryState.batches = [...batchHistoryState.batches, ...data.batches];
                } else {
                    batchHistoryState.batches = data.batches;
                }

                batchHistoryState.hasMore = batchHistoryState.batches.length < data.total;
                batchHistoryState.offset = batchHistoryState.batches.length;

                // Track current running batch
                const runningBatch = batchHistoryState.batches.find(b => b.status === 'running');
                if (runningBatch) {
                    batchHistoryState.currentBatchId = runningBatch.id;
                }

                renderBatchList();
            } catch (e) {
                console.error('Failed to fetch batches:', e);
                if (!append) {
                    const container = document.getElementById('batchSidebarContent');
                    if (container) {
                        container.innerHTML = '<div class="batch-sidebar__empty">Failed to load batches</div>';
                    }
                }
            } finally {
                batchHistoryState.isLoading = false;
            }
        }

        // Load more batches
        function loadMoreBatches() {
            if (batchHistoryState.hasMore && !batchHistoryState.isLoading) {
                fetchBatches(true);
            }
        }

        // Select a batch to view
        async function selectBatch(batchId) {
            // If selecting current running batch, show live view
            if (batchId === batchHistoryState.currentBatchId) {
                returnToLiveView();
                return;
            }

            batchHistoryState.selectedBatchId = batchId;
            batchHistoryState.viewingPastBatch = true;

            // Update sidebar selection
            document.querySelectorAll('.batch-sidebar__item').forEach(el => {
                el.classList.toggle('batch-sidebar__item--selected',
                    parseInt(el.dataset.batchId) === batchId);
            });

            // Fetch and display batch details
            try {
                const response = await fetch(`/api/batches/${batchId}`);
                if (!response.ok) throw new Error('Failed to fetch batch');

                const data = await response.json();
                renderPastBatchView(data);
            } catch (e) {
                console.error('Failed to fetch batch details:', e);
                showToast('Failed to load batch details', 'error');
            }
        }

        // Render past batch view
        function renderPastBatchView(data) {
            const { batch, stories, stats } = data;

            // Create past batch view content
            const pastBatchHtml = `
                <div class="past-batch-header">
                    <button class="past-batch-header__back" onclick="returnToLiveView()">
                        &larr; Back to Live
                    </button>
                    <div class="past-batch-header__info">
                        <div class="past-batch-header__title">Batch #${batch.id}</div>
                        <div class="past-batch-header__meta">
                            ${formatBatchTime(batch.started_at)} -
                            ${batch.ended_at ? formatBatchTime(batch.ended_at) : 'In Progress'}
                        </div>
                    </div>
                    <span class="past-batch-header__status past-batch-header__status--${batch.status}">
                        ${batch.status}
                    </span>
                </div>

                <div class="batch-summary-stats">
                    <div class="batch-summary-stat">
                        <div class="batch-summary-stat__value">${stats.story_count}</div>
                        <div class="batch-summary-stat__label">Stories</div>
                    </div>
                    <div class="batch-summary-stat">
                        <div class="batch-summary-stat__value">${stats.cycles_completed}/${stats.max_cycles}</div>
                        <div class="batch-summary-stat__label">Cycles</div>
                    </div>
                    <div class="batch-summary-stat">
                        <div class="batch-summary-stat__value">${stats.stories_done}/${stats.story_count}</div>
                        <div class="batch-summary-stat__label">Completed</div>
                    </div>
                    <div class="batch-summary-stat">
                        <div class="batch-summary-stat__value">${stats.duration_seconds ? formatBatchDuration(stats.duration_seconds) : '-'}</div>
                        <div class="batch-summary-stat__label">Duration</div>
                    </div>
                </div>

                <div class="past-batch-stories">
                    <div class="past-batch-stories__header">Stories in this Batch</div>
                    ${stories.map(story => `
                        <div class="past-batch-story">
                            <span class="past-batch-story__key">${escapeHtml(story.story_key)}</span>
                            <span class="past-batch-story__epic">${escapeHtml(story.epic_id)}</span>
                            <span class="past-batch-story__status">
                                <span class="status-badge status-${story.status}">${story.status}</span>
                            </span>
                            <span class="past-batch-story__duration">
                                ${story.duration_seconds ? formatBatchDuration(story.duration_seconds) : '-'}
                            </span>
                            <span class="past-batch-story__commands">${story.command_count} commands</span>
                        </div>
                    `).join('')}
                    ${stories.length === 0 ? '<div class="past-batch-story">No stories in this batch</div>' : ''}
                </div>
            `;

            // Insert past batch view, hide normal dashboard content
            const dashboardContent = document.getElementById('dashboardContent');
            if (!dashboardContent) return;

            // Store original content if not already stored
            if (!dashboardContent.dataset.originalHtml) {
                dashboardContent.dataset.originalHtml = dashboardContent.innerHTML;
            }

            dashboardContent.innerHTML = pastBatchHtml;
        }

        // Return to live view
        function returnToLiveView() {
            batchHistoryState.selectedBatchId = null;
            batchHistoryState.viewingPastBatch = false;

            // Update sidebar selection
            document.querySelectorAll('.batch-sidebar__item').forEach(el => {
                el.classList.remove('batch-sidebar__item--selected');
            });

            // Restore original dashboard content
            const dashboardContent = document.getElementById('dashboardContent');
            if (dashboardContent && dashboardContent.dataset.originalHtml) {
                dashboardContent.innerHTML = dashboardContent.dataset.originalHtml;
                delete dashboardContent.dataset.originalHtml;

                // Re-render current data
                if (state.sprintData) {
                    renderSummaryCards(state.sprintData);
                    renderEpicBoard(state.sprintData);
                    renderStoryTable(state.sprintData,
                        document.getElementById('epicFilter')?.value || 'all',
                        document.getElementById('statusFilter')?.value || 'all');
                    restoreExpandedEpics();
                }
                if (state.orchestratorData) {
                    renderActivityLog(state.orchestratorData);
                    restoreExpandedActivities();
                }
                updateTabCounts(state.sprintData, state.orchestratorData);
            }
        }

        // Initialize batch history
        function initBatchHistory() {
            // Restore sidebar collapsed state
            const savedCollapsed = localStorage.getItem('batch-sidebar-collapsed');
            if (savedCollapsed === 'true') {
                batchHistoryState.sidebarCollapsed = true;
                const sidebar = document.getElementById('batchSidebar');
                if (sidebar) sidebar.classList.add('collapsed');
            }

            // Attach event listeners
            const loadMoreBtn = document.getElementById('loadMoreBatches');
            if (loadMoreBtn) {
                loadMoreBtn.addEventListener('click', loadMoreBatches);
            }

            const toggleBtn = document.querySelector('.batch-sidebar__toggle');
            if (toggleBtn) {
                toggleBtn.addEventListener('click', toggleBatchSidebar);
            }

            // Fetch initial batch list
            fetchBatches();

            // Refresh batch list periodically
            setInterval(() => {
                if (!batchHistoryState.viewingPastBatch) {
                    fetchBatches();
                }
            }, 30000); // Every 30 seconds
        }

        // Initialize batch history
        initBatchHistory();
    </script>
</body>
</html>
